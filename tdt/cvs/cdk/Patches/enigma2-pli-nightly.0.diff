diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/configure.ac enigma2-nightly.patched/configure.ac
--- enigma2-nightly.org/configure.ac	2013-08-11 08:11:18.750306141 +0200
+++ enigma2-nightly.patched/configure.ac	2013-08-11 09:48:28.290174375 +0200
@@ -33,10 +33,50 @@
 	AS_HELP_STRING([--with-gstversion],[use gstreamer version (major.minor)]),
 	[GST_MAJORMINOR=$withval],[GST_MAJORMINOR=0.10])
 
+AC_ARG_ENABLE(libeplayer3,
+	[  --enable-libeplayer3          enable TDT libeplayer3 as player engine supportt],
+	[AC_DEFINE(ENABLE_LIBEPLAYER3,1,[enable TDT libeplayer3 as player engine support])])
+
+AM_CONDITIONAL(ENABLE_LIBEPLAYER3,test "$enable_libeplayer3" = "yes")
+if test "$enable_libeplayer3" = "yes"; then
+	AC_DEFINE(ENABLE_LIBEPLAYER3,1,[include TDT libeplayer3 as player engine support])
+fi
+
+AC_ARG_ENABLE(mediafwgstreamer,
+	[  --enable-mediafwgstreamer      enable gstreamer as player engine supportt],
+	[AC_DEFINE(ENABLE_MEDIAFWGSTREAMER,1,[enable gstreamer as player engine support])])
+
+AM_CONDITIONAL(ENABLE_MEDIAFWGSTREAMER,test "$enable_mediafwgstreamer" = "yes")
+if test "$enable_mediafwgstreamer" = "yes"; then
+	AC_DEFINE(ENABLE_MEDIAFWGSTREAMER,1,[include gstreamer as player engine support])
+fi
+
+if test "$enable_mediafwgstreamer" = "yes"; then
 PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+else
+PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+fi
 PKG_CHECK_MODULES(LIBDDVD, libdreamdvd, HAVE_LIBDDVD="yes", HAVE_LIBDDVD="no")
 AM_CONDITIONAL(HAVE_LIBDDVD, test "$HAVE_LIBDDVD" = "yes")
 
+AC_ARG_ENABLE([tf7700],
+	[AS_HELP_STRING(--enable-tf7700,    enable topfield tf7700 stuff)],
+	[case "${enableval}" in
+		yes) enable_tf7700=true ;;
+		no) enable_tf7700=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-tf7700]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_TF7700], [test x$enable_tf7700 = xtrue])
+
+AC_ARG_ENABLE([cuberevo],
+	[AS_HELP_STRING(--enable-cuberevo,    enable cuberevo stuff)],
+	[case "${enableval}" in
+		yes) enable_cuberevo=true ;;
+		no) enable_cuberevo=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-cuberevo]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_CUBEREVO], [test x$enable_cuberevo = xtrue])
+
 AC_CHECK_LIB([dl], [dlopen], [LIBDL_LIBS="-ldl"], [AC_MSG_ERROR([Could not find libdl])])
 AC_SUBST(LIBDL_LIBS)
 AC_CHECK_LIB([jpeg], [jpeg_set_defaults], [LIBJPEG_LIBS="-ljpeg"], [AC_MSG_ERROR([Could not find libjpeg])])
@@ -85,6 +125,15 @@
 fi
 AM_CONDITIONAL(HAVE_COLORLCD, test x"$withcolorlcd" != xno)
 
+AC_ARG_WITH(graphlcd,
+	AC_HELP_STRING([--with-graphlcd], [use GraphLCD color display, yes or no]),
+	[[withgraphlcd=$withval]],
+	[[withgraphlcd=no]]
+)
+if test x"$withgraphlcd" != xno ; then
+	AC_DEFINE(HAVE_GRAPHLCD, 1,[Define when using a GraphLCD color display device])
+fi
+AM_CONDITIONAL(HAVE_GRAPHLCD, test x"$withgraphlcd" != xno)
 
 AC_ARG_WITH(oldpvr,
 	AC_HELP_STRING([--with-oldpvr], [use /dev/misc/pvr instead of /dev/dvb/adapterX/dvrX, yes or no]),
@@ -203,15 +252,12 @@
 lib/python/Plugins/Extensions/MediaPlayer/meta/Makefile
 lib/python/Plugins/Extensions/MediaScanner/Makefile
 lib/python/Plugins/Extensions/MediaScanner/meta/Makefile
-lib/python/Plugins/Extensions/Modem/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/meta/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/data/Makefile
 lib/python/Plugins/Extensions/SocketMMI/Makefile
 lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
 lib/python/Plugins/Extensions/SocketMMI/src/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/meta/Makefile
 lib/python/Plugins/PLi/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/meta/Makefile
@@ -248,6 +294,10 @@
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 po/Makefile
 main/Makefile
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/configure.ac~ enigma2-nightly.patched/configure.ac~
--- enigma2-nightly.org/configure.ac~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/configure.ac~	2013-08-11 08:18:45.430296040 +0200
@@ -0,0 +1,299 @@
+AC_INIT([enigma2],[3.0.0],[enigma2-devel@lists.elitedvb.net])
+AM_INIT_AUTOMAKE([dist-bzip2 no-define tar-pax -Wno-portability])
+AC_CONFIG_HEADERS([enigma2_config.h])
+
+# Silent rules are available since 1.11, but older versions
+# are still in use. So don't use them unconditionally.
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+
+AC_USE_SYSTEM_EXTENSIONS
+AC_SYS_LARGEFILE
+
+AC_PROG_CC
+AC_PROG_CXX
+m4_ifdef([LT_INIT], [LT_INIT], [AC_PROG_LIBTOOL])
+AC_CONFIG_MACRO_DIR([m4])
+
+AC_PATH_PROG(MSGFMT, msgfmt, AC_MSG_ERROR(Could not find msgfmt))
+
+AM_PATH_PYTHON
+AX_PYTHON_DEVEL
+AX_PKG_SWIG
+AX_SWIG_ENABLE_CXX
+AX_SWIG_PYTHON
+AX_PTHREAD
+
+TUXBOX_APPS_DVB
+
+AM_CONDITIONAL(HAVE_GIT_DIR, test -d "$srcdir/.git")
+AM_CONDITIONAL(HAVE_FAKE_GIT_DIR, test -f "$srcdir/.git/last_commit_info")
+
+dnl versions of gstreamer and plugins-base
+AC_ARG_WITH(gstversion,
+	AS_HELP_STRING([--with-gstversion],[use gstreamer version (major.minor)]),
+	[GST_MAJORMINOR=$withval],[GST_MAJORMINOR=0.10])
+
+AC_ARG_ENABLE(libeplayer3,
+	[  --enable-libeplayer3          enable TDT libeplayer3 as player engine supportt],
+	[AC_DEFINE(ENABLE_LIBEPLAYER3,1,[enable TDT libeplayer3 as player engine support])])
+
+AM_CONDITIONAL(ENABLE_LIBEPLAYER3,test "$enable_libeplayer3" = "yes")
+if test "$enable_libeplayer3" = "yes"; then
+	AC_DEFINE(ENABLE_LIBEPLAYER3,1,[include TDT libeplayer3 as player engine support])
+fi
+
+if ! test "$enable_libeplayer3" = "yes"; then
+PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+else
+PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+fi
+PKG_CHECK_MODULES(LIBDDVD, libdreamdvd, HAVE_LIBDDVD="yes", HAVE_LIBDDVD="no")
+AM_CONDITIONAL(HAVE_LIBDDVD, test "$HAVE_LIBDDVD" = "yes")
+
+AC_ARG_ENABLE([tf7700],
+	[AS_HELP_STRING(--enable-tf7700,    enable topfield tf7700 stuff)],
+	[case "${enableval}" in
+		yes) enable_tf7700=true ;;
+		no) enable_tf7700=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-tf7700]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_TF7700], [test x$enable_tf7700 = xtrue])
+
+AC_ARG_ENABLE([cuberevo],
+	[AS_HELP_STRING(--enable-cuberevo,    enable cuberevo stuff)],
+	[case "${enableval}" in
+		yes) enable_cuberevo=true ;;
+		no) enable_cuberevo=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-cuberevo]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_CUBEREVO], [test x$enable_cuberevo = xtrue])
+
+AC_CHECK_LIB([dl], [dlopen], [LIBDL_LIBS="-ldl"], [AC_MSG_ERROR([Could not find libdl])])
+AC_SUBST(LIBDL_LIBS)
+AC_CHECK_LIB([jpeg], [jpeg_set_defaults], [LIBJPEG_LIBS="-ljpeg"], [AC_MSG_ERROR([Could not find libjpeg])])
+AC_SUBST(LIBJPEG_LIBS)
+AC_CHECK_LIB([ungif], [DGifOpen], [LIBGIF_LIBS="-lungif"], [AC_CHECK_LIB([gif], [DGifOpen], [LIBGIF_LIBS="-lgif"], [AC_MSG_ERROR([Could not find libgif or libungif])])])
+AC_SUBST(LIBGIF_LIBS)
+
+AC_LANG_PUSH([C++])
+AC_CHECK_LIB([xmlccwrap], [exit], [LIBXMLCCWRAP_LIBS="-lxmlccwrap"], [AC_MSG_ERROR([Could not find libxmlccwrap])])
+AC_SUBST(LIBXMLCCWRAP_LIBS)
+AC_LANG_POP
+
+AC_ARG_WITH(boxtype,
+	[  --with-boxtype=NAME box type [[none,dm7025,dm800...]]],
+	[BOXTYPE="$withval"],[BOXTYPE="dm800"])
+AC_SUBST(BOXTYPE)
+AC_DEFINE_UNQUOTED(BOXTYPE,"$BOXTYPE",[box type])
+
+AM_CONDITIONAL(DREAMBOX, test `echo "$BOXTYPE" | cut -b 1-2` == "dm")
+AM_CONDITIONAL(HAVE_TEMPFANCONTROL, test "$BOXTYPE" == dm8000 -o "$BOXTYPE" == dm800se -o "$BOXTYPE" == dm500hd)
+if test `echo "$BOXTYPE" | cut -b 1-2` == "dm"; then
+	AC_DEFINE(DREAMBOX, 1, [Dreambox hardware])
+	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
+fi
+if test "$BOXTYPE" == "vusolo2" -o "$BOXTYPE" == "vuduo2"; then
+	AC_DEFINE(VUPLUS_RC_WORKAROUND, 1, [workaround for problem with vusolo2/vuduo2 event/rc driver])
+fi
+
+AC_ARG_WITH(textlcd,
+	AC_HELP_STRING([--with-textlcd], [use ascii based lcd, yes or no]),
+	[[withtextlcd=$withval]],
+	[[withtextlcd=no]]
+)
+if test x"$withtextlcd" != xno ; then
+	AC_DEFINE(HAVE_TEXTLCD, 1,[Define when using an ascii based lcd device])
+fi
+AM_CONDITIONAL(HAVE_TEXTLCD, test x"$withtextlcd" != xno)
+
+AC_ARG_WITH(colorlcd,
+	AC_HELP_STRING([--with-colorlcd], [use 96x64 16bpp color display, yes or no]),
+	[[withcolorlcd=$withval]],
+	[[withcolorlcd=no]]
+)
+if test x"$withcolorlcd" != xno ; then
+	AC_DEFINE(HAVE_COLORLCD, 1,[Define when using a 96x64 color display device])
+fi
+AM_CONDITIONAL(HAVE_COLORLCD, test x"$withcolorlcd" != xno)
+
+AC_ARG_WITH(graphlcd,
+	AC_HELP_STRING([--with-graphlcd], [use GraphLCD color display, yes or no]),
+	[[withgraphlcd=$withval]],
+	[[withgraphlcd=no]]
+)
+if test x"$withgraphlcd" != xno ; then
+	AC_DEFINE(HAVE_GRAPHLCD, 1,[Define when using a GraphLCD color display device])
+fi
+AM_CONDITIONAL(HAVE_GRAPHLCD, test x"$withgraphlcd" != xno)
+
+AC_ARG_WITH(oldpvr,
+	AC_HELP_STRING([--with-oldpvr], [use /dev/misc/pvr instead of /dev/dvb/adapterX/dvrX, yes or no]),
+	[[witholdpvr=$withval]],
+	[[witholdpvr=no]]
+)
+if test x"$witholdpvr" != xno ; then
+	AC_DEFINE(HAVE_OLDPVR, 1,[Define when using /dev/misc/pvr])
+fi
+AM_CONDITIONAL(HAVE_OLDPVR, test x"$witholdpvr" != xno)
+
+if test `echo "$BOXTYPE" | cut -b 1-2` == "vu"; then
+	AC_DEFINE(FORCE_NO_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration does not have alphablending support, though the autodetection might indicate that it does])
+	AC_DEFINE(FORCE_NO_FILL_ACCELERATION, 1,[define when the framebuffer acceleration does not have fill support])
+	AC_DEFINE(FORCE_ADVANCED_REMOTE, 1,[define to fixup the input device identification when the remote control is actually an 'advanced' remote (with play/forward/rewind keys)])
+fi
+
+AC_ARG_WITH(libsdl,
+	AS_HELP_STRING([--with-libsdl],[use libsdl, yes or no]),
+	[with_libsdl=$withval],[with_libsdl=no])
+if test "$with_libsdl" = "yes"; then
+	PKG_CHECK_MODULES(LIBSDL, sdl)
+fi
+AM_CONDITIONAL(HAVE_LIBSDL, test "$with_libsdl" = "yes")
+
+AC_ARG_WITH(libxine,
+	AS_HELP_STRING([--with-libxine],[use libxine, yes or no]),
+	[with_libxine=$withval],[with_libxine=no])
+if test "$with_libxine" = "yes"; then
+	PKG_CHECK_MODULES(LIBXINE, libxine)
+	AC_DEFINE([WITH_XINE],[1],[Define to 1 if you have libxine])
+fi
+AM_CONDITIONAL(HAVE_LIBXINE, test "$with_libxine" = "yes")
+
+AC_ARG_WITH(debug,
+	AS_HELP_STRING([--without-debug],[disable debugging code]),
+	[with_debug="$withval"],[with_debug="yes"])
+if test "$with_debug" = "yes"; then
+	DEBUG_CFLAGS="-ggdb3"
+	AC_DEFINE([DEBUG],[1],[Define to 1 to enable debugging code])
+fi
+
+AC_ARG_WITH(memcheck,
+	AS_HELP_STRING([--with-memcheck],[enable memory leak checks]),
+	[with_memcheck="$withval"],[with_memcheck="no"])
+if test "$with_memcheck" = "yes"; then
+	AC_DEFINE([MEMLEAK_CHECK],[1],[Define to 1 to enable memory leak checks])
+fi
+
+AC_ARG_WITH(po,
+	AS_HELP_STRING([--with-po],[enable updating of po files]),
+	[with_po="$withval"],[with_po="no"])
+if test "$with_po" = "yes"; then
+	AC_PATH_PROG(MSGINIT, msginit)
+	AC_PATH_PROG(MSGMERGE, msgmerge)
+	AC_PATH_PROG(MSGUNIQ, msguniq)
+	AC_PATH_PROG(XGETTEXT, xgettext)
+	if test -z "$MSGINIT" -o -z "$MSGMERGE" -o -z "$MSGUNIQ" -o -z "$XGETTEXT"; then
+		AC_MSG_ERROR([Could not find required gettext tools])
+	fi
+fi
+AM_CONDITIONAL(UPDATE_PO, test "$with_po" = "yes")
+
+ENIGMA2_CFLAGS="-fno-rtti -fno-exceptions"
+AC_SUBST(ENIGMA2_CFLAGS)
+
+CPPFLAGS="$CPPFLAGS $PYTHON_CPPFLAGS"
+CFLAGS="$CFLAGS $DEBUG_CFLAGS -Wall"
+CXXFLAGS="$CXXFLAGS $DEBUG_CFLAGS -Wall $BASE_CFLAGS $ENIGMA2_CFLAGS $PTHREAD_CFLAGS"
+
+AC_CONFIG_FILES([
+Makefile
+data/Makefile
+data/fonts/Makefile
+data/countries/Makefile
+data/extensions/Makefile
+data/keymaps/Makefile
+data/rc_models/Makefile
+data/rc_models/et4x00/Makefile
+data/rc_models/et6x00/Makefile
+data/rc_models/et9500/Makefile
+data/rc_models/et9x00/Makefile
+data/rc_models/vu/Makefile
+data/rc_models/xp1000/Makefile
+data/skin_default/Makefile
+data/skin_default/menu/Makefile
+data/skin_default/icons/Makefile
+data/skin_default/buttons/Makefile
+data/skin_default/spinner/Makefile
+include/Makefile
+lib/Makefile
+lib/base/eenv.cpp
+lib/python/Makefile
+lib/python/Components/Makefile
+lib/python/Components/Converter/Makefile
+lib/python/Components/Renderer/Makefile
+lib/python/Components/Sources/Makefile
+lib/python/Screens/Makefile
+lib/python/Plugins/Makefile
+lib/python/Plugins/SystemPlugins/CableScan/Makefile
+lib/python/Plugins/SystemPlugins/FastScan/Makefile
+lib/python/Plugins/SystemPlugins/OSDPositionSetup/Makefile
+lib/python/Plugins/SystemPlugins/OSD3DSetup/Makefile
+lib/python/Plugins/SystemPlugins/HdmiCEC/Makefile
+lib/python/Plugins/SystemPlugins/VideoClippingSetup/Makefile
+lib/python/Plugins/Extensions/CutListEditor/Makefile
+lib/python/Plugins/Extensions/CutListEditor/meta/Makefile
+lib/python/Plugins/Extensions/DVDBurn/Makefile
+lib/python/Plugins/Extensions/DVDBurn/meta/Makefile
+lib/python/Plugins/Extensions/DVDPlayer/Makefile
+lib/python/Plugins/Extensions/DVDPlayer/meta/Makefile
+lib/python/Plugins/Extensions/GraphMultiEPG/Makefile
+lib/python/Plugins/Extensions/GraphMultiEPG/meta/Makefile
+lib/python/Plugins/Extensions/Makefile
+lib/python/Plugins/Extensions/MediaPlayer/Makefile
+lib/python/Plugins/Extensions/MediaPlayer/meta/Makefile
+lib/python/Plugins/Extensions/MediaScanner/Makefile
+lib/python/Plugins/Extensions/MediaScanner/meta/Makefile
+lib/python/Plugins/Extensions/PicturePlayer/Makefile
+lib/python/Plugins/Extensions/PicturePlayer/meta/Makefile
+lib/python/Plugins/Extensions/PicturePlayer/data/Makefile
+lib/python/Plugins/Extensions/SocketMMI/Makefile
+lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
+lib/python/Plugins/Extensions/SocketMMI/src/Makefile
+lib/python/Plugins/PLi/Makefile
+lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
+lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/meta/Makefile
+lib/python/Plugins/SystemPlugins/DefaultServicesScanner/Makefile
+lib/python/Plugins/SystemPlugins/DefaultServicesScanner/meta/Makefile
+lib/python/Plugins/SystemPlugins/DiseqcTester/Makefile
+lib/python/Plugins/SystemPlugins/DiseqcTester/meta/Makefile
+lib/python/Plugins/SystemPlugins/FrontprocessorUpgrade/Makefile
+lib/python/Plugins/SystemPlugins/FrontprocessorUpgrade/meta/Makefile
+lib/python/Plugins/SystemPlugins/Hotplug/Makefile
+lib/python/Plugins/SystemPlugins/Hotplug/meta/Makefile
+lib/python/Plugins/SystemPlugins/Makefile
+lib/python/Plugins/SystemPlugins/TempFanControl/Makefile
+lib/python/Plugins/SystemPlugins/TempFanControl/meta/Makefile
+lib/python/Plugins/SystemPlugins/NetworkWizard/Makefile
+lib/python/Plugins/SystemPlugins/NetworkWizard/meta/Makefile
+lib/python/Plugins/SystemPlugins/NFIFlash/Makefile
+lib/python/Plugins/SystemPlugins/NFIFlash/meta/Makefile
+lib/python/Plugins/SystemPlugins/PositionerSetup/Makefile
+lib/python/Plugins/SystemPlugins/PositionerSetup/meta/Makefile
+lib/python/Plugins/SystemPlugins/SatelliteEquipmentControl/Makefile
+lib/python/Plugins/SystemPlugins/SatelliteEquipmentControl/meta/Makefile
+lib/python/Plugins/SystemPlugins/Satfinder/Makefile
+lib/python/Plugins/SystemPlugins/Satfinder/meta/Makefile
+lib/python/Plugins/SystemPlugins/SkinSelector/Makefile
+lib/python/Plugins/SystemPlugins/SkinSelector/meta/Makefile
+lib/python/Plugins/SystemPlugins/SoftwareManager/Makefile
+lib/python/Plugins/SystemPlugins/SoftwareManager/meta/Makefile
+lib/python/Plugins/SystemPlugins/VideoEnhancement/Makefile
+lib/python/Plugins/SystemPlugins/VideoEnhancement/meta/Makefile
+lib/python/Plugins/SystemPlugins/VideoTune/Makefile
+lib/python/Plugins/SystemPlugins/VideoTune/meta/Makefile
+lib/python/Plugins/SystemPlugins/Videomode/Makefile
+lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
+lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
+lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
+lib/python/Tools/Makefile
+po/Makefile
+main/Makefile
+tools/Makefile
+tools/enigma2.sh
+enigma2.pc
+])
+AC_OUTPUT
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/eptrlist.h enigma2-nightly.patched/lib/base/eptrlist.h
--- enigma2-nightly.org/lib/base/eptrlist.h	2013-08-11 08:11:19.054306134 +0200
+++ enigma2-nightly.patched/lib/base/eptrlist.h	2013-08-11 08:18:50.226296679 +0200
@@ -175,7 +175,7 @@
 	{
 		// added a new item to the list... in order
 		// returns a iterator to the new item
-		return insert( std::lower_bound( std::list<T*>::begin(), std::list<T*>::end(), e, less()), e );
+		return this->insert( std::lower_bound( std::list<T*>::begin(), std::list<T*>::end(), e, less()), e );
 	}
 
 };
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/etpm.cpp enigma2-nightly.patched/lib/base/etpm.cpp
--- enigma2-nightly.org/lib/base/etpm.cpp	2013-08-11 08:11:19.054306134 +0200
+++ enigma2-nightly.patched/lib/base/etpm.cpp	2013-08-11 08:18:50.230296490 +0200
@@ -6,14 +6,17 @@
 #include <string.h>
 #include <sys/un.h>
 #include <unistd.h>
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 #include <openssl/bn.h>
 #include <openssl/sha.h>
+#endif
 #include <lib/base/eerror.h>
 
 #include "etpm.h"
 
 eTPM::eTPM()
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	struct sockaddr_un addr;
 	unsigned char buf[8];
 	unsigned int tag;
@@ -53,6 +56,7 @@
 
 	parse_data(val, len);
 	free(val);
+#endif
 }
 
 eTPM::~eTPM()
@@ -63,6 +67,7 @@
 
 bool eTPM::send_cmd(enum tpmd_cmd cmd, const void *data, size_t len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[len + 4];
 
 	buf[0] = (cmd >> 8) & 0xff;
@@ -77,11 +82,13 @@
 		return false;
 	}
 
+#endif
 	return true;
 }
 
 void* eTPM::recv_cmd(unsigned int *tag, size_t *len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[4];
 	void *val;
 
@@ -111,10 +118,14 @@
 	}
 
 	return val;
+#else
+	return NULL;
+#endif
 }
 
 void eTPM::parse_data(const unsigned char *data, size_t datalen)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned int i;
 	unsigned int tag;
 	unsigned int len;
@@ -140,19 +151,23 @@
 			break;
 		}
 	}
+#endif
 }
 
 std::string eTPM::getCert(cert_type type)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (type == TPMD_DT_LEVEL2_CERT && level2_cert_read)
 		return std::string((char*)level2_cert, 210);
 	else if (type == TPMD_DT_LEVEL3_CERT && level3_cert_read)
 		return std::string((char*)level3_cert, 210);
+#endif
 	return "";
 }
 
 std::string eTPM::challenge(std::string rnd)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (rnd.length() == 8)
 	{
 		if (!send_cmd(TPMD_CMD_COMPUTE_SIGNATURE, rnd.c_str(), 8))
@@ -169,5 +184,6 @@
 		free(val);
 		return ret;
 	}
+#endif
 	return "";
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/filepush.cpp enigma2-nightly.patched/lib/base/filepush.cpp
--- enigma2-nightly.org/lib/base/filepush.cpp	2013-08-11 08:11:19.054306134 +0200
+++ enigma2-nightly.patched/lib/base/filepush.cpp	2013-08-11 08:18:50.230296490 +0200
@@ -4,6 +4,15 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 
+#if defined(__sh__) // this allows filesystem tasks to be prioritised
+#include <sys/vfs.h>
+#define USBDEVICE_SUPER_MAGIC 0x9fa2
+#define EXT2_SUPER_MAGIC      0xEF53
+#define EXT3_SUPER_MAGIC      0xEF53
+#define SMB_SUPER_MAGIC       0x517B
+#define NFS_SUPER_MAGIC       0x6969
+#define MSDOS_SUPER_MAGIC     0x4d44 /* MD */
+#endif
 //#define SHOW_WRITE_TIME
 
 eFilePushThread::eFilePushThread(int io_prio_class, int io_prio_level, int blocksize, size_t buffersize)
@@ -57,10 +66,30 @@
 	off_t current_span_offset = 0;
 	size_t current_span_remaining = 0;
 
+#if defined(__sh__)
+// opens video device for the reverse playback workaround
+// Changes in this file are cause e2 doesnt tell the player to play reverse
+	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+// Fix to ensure that event evtEOF is called at end of playbackl part 1/3
+	bool already_empty = false;
+#endif
+
 	while (!m_stop)
 	{
 		if (m_sg && !current_span_remaining)
 		{
+#if defined (__sh__) // tells the player to play in reverse
+#define VIDEO_DISCONTINUITY                   _IO('o', 84)
+#define DVB_DISCONTINUITY_SKIP                0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+			if ((m_sg->getSkipMode() != 0))
+			{
+				// inform the player about the jump in the stream data
+				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+			}
+#endif
 			m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining);
 			ASSERT(!(current_span_remaining % m_blocksize));
 			m_current_position = current_span_offset;
@@ -127,7 +156,19 @@
 				{
 					case 0:
 						eDebug("wait for driver eof timeout");
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 2/3
+						if (already_empty)
+						{
+							break;
+						}
+						else
+						{
+							already_empty = true;
+							continue;
+						}
+#else
 						continue;
+#endif
 					case 1:
 						eDebug("wait for driver eof ok");
 						break;
@@ -190,12 +231,18 @@
 			}
 
 			eofcount = 0;
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 3/3
+			already_empty = false;
+#endif
 			m_current_position += buf_end;
 			bytes_read += buf_end;
 			if (m_sg)
 				current_span_remaining -= buf_end;
 		}
 	}
+#if defined(__sh__) // closes video device for the reverse playback workaround
+	close(fd_video);
+#endif
 	sendEvent(evtStopped);
 
 	{ /* mutex lock scope */
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/filepush.h enigma2-nightly.patched/lib/base/filepush.h
--- enigma2-nightly.org/lib/base/filepush.h	2013-08-11 08:11:19.054306134 +0200
+++ enigma2-nightly.patched/lib/base/filepush.h	2013-08-11 08:18:50.230296490 +0200
@@ -13,6 +13,10 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	virtual int getSkipMode() = 0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/freesatv2.cpp enigma2-nightly.patched/lib/base/freesatv2.cpp
--- enigma2-nightly.org/lib/base/freesatv2.cpp	2013-08-11 08:11:19.058306134 +0200
+++ enigma2-nightly.patched/lib/base/freesatv2.cpp	2013-08-11 08:18:50.230296490 +0200
@@ -84,27 +84,32 @@
 */
 static unsigned char resolveChar(const char *str)
 {
-	const unsigned char*p = str;
-	unsigned c0 = *p++, c1 = *p++;
-	if (c1)
-		switch(c0|c1<<8)
+	if (str[1] == 0)
+		return str[0];
+
+	switch(str[0])
+	{
+		case '0':
 		{
-			case '0'|'x'<<8:
-				if ( sscanf(p,"%02x", &c1) == 1 )
-					c0 = c1;
-				break;
-			case 'E'|'S'<<8:
-				if ( !strcmp(p,"CAPE") )
-					c0 = ESCAPE;
-				break;
-			case 'S'|'T'<<8:
-				if ( !strcmp(p,"OP") )
-					c0 = STOP;
-				else if ( !strcmp(p,"ART") )
-					c0 = START;
-				break;
+			int val;
+			if ( sscanf(str,"0x%02x", &val) == 1 )
+			{
+				return val;
+			}
 		}
-	return c0;
+		break;
+		case 'E':
+			if ( strcmp(str,"ESCAPE") == 0 )
+				return ESCAPE;
+			break;
+		case 'S':
+			if ( strcmp(str,"STOP") == 0 )
+				return STOP;
+			if ( strcmp(str,"START") == 0 )
+				return START;
+			break;
+	}
+	return str[0];
 }
 
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/ioprio.cpp enigma2-nightly.patched/lib/base/ioprio.cpp
--- enigma2-nightly.org/lib/base/ioprio.cpp	2013-08-11 08:11:19.058306134 +0200
+++ enigma2-nightly.patched/lib/base/ioprio.cpp	2013-08-11 08:18:50.230296490 +0200
@@ -28,6 +28,9 @@
 #elif defined(__mips__)
 #define __NR_ioprio_set		4284
 #define __NR_ioprio_get		4285
+#elif defined(__sh__) // the correct values for our kernel
+#define __NR_ioprio_set		288
+#define __NR_ioprio_get		289
 #else
 #error "Unsupported arch"
 #endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/object.h enigma2-nightly.patched/lib/base/object.h
--- enigma2-nightly.org/lib/base/object.h	2013-08-11 08:11:19.058306134 +0200
+++ enigma2-nightly.patched/lib/base/object.h	2013-08-11 08:18:50.230296490 +0200
@@ -1,7 +1,9 @@
 #ifndef __base_object_h
 #define __base_object_h
 
+#if !defined(__sh__)
 #include <ext/atomicity.h>
+#endif
 
 #include <assert.h>
 #include <lib/base/smartptr.h>
@@ -34,23 +36,39 @@
 
 class oRefCount
 {
+#if defined(__sh__)
+	int ref;
+#else
 	mutable _Atomic_word ref;
+#endif
 public:
 	oRefCount(): ref(0) {}
 
 	int operator++()
 	{
+#if defined(__sh__)
+		return ++ref;
+#else
 		return __gnu_cxx::__exchange_and_add(&ref, 1) + 1;
+#endif
 	}
 
 	int operator--()
 	{
+#if defined(__sh__)
+		return --ref;
+#else
 		return __gnu_cxx::__exchange_and_add(&ref, -1) - 1;
+#endif
 	}
 
 	operator int() const
 	{
+#if defined(__sh__)
+		return ref;
+#else
 		return __gnu_cxx::__exchange_and_add(&ref, 0);
+#endif
 	}
 };
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/Makefile.inc enigma2-nightly.patched/lib/driver/Makefile.inc
--- enigma2-nightly.org/lib/driver/Makefile.inc	2013-08-11 08:11:19.094306135 +0200
+++ enigma2-nightly.patched/lib/driver/Makefile.inc	2013-08-11 08:18:50.230296490 +0200
@@ -9,7 +9,8 @@
 	driver/rc.cpp \
 	driver/rcinput.cpp \
 	driver/rfmod.cpp \
-	driver/hdmi_cec.cpp
+	driver/hdmi_cec.cpp \
+	driver/vfd.cpp
 
 driverincludedir = $(pkgincludedir)/lib/driver
 driverinclude_HEADERS = \
@@ -24,7 +25,8 @@
 	driver/rcinput.h \
 	driver/rcinput_swig.h \
 	driver/rfmod.h \
-	driver/hdmi_cec.h
+	driver/hdmi_cec.h \
+	driver/vfd.h
 
 if HAVE_LIBSDL
 driver_libenigma_driver_a_SOURCES += \
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/rc.cpp enigma2-nightly.patched/lib/driver/rc.cpp
--- enigma2-nightly.org/lib/driver/rc.cpp	2013-08-11 08:11:19.094306135 +0200
+++ enigma2-nightly.patched/lib/driver/rc.cpp	2013-08-11 08:24:17.106288532 +0200
@@ -151,6 +151,9 @@
 #ifdef VUPLUS_RC_WORKAROUND
 	return(false);
 #else
+	if (getDeviceName().find("RC") != std::string::npos)
+		return false;
+
 	/* check whether the input device has KEY_A, in which case we assume it is a keyboard */
 	return hasCap(keyCaps, KEY_A);
 #endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/rc.cpp~ enigma2-nightly.patched/lib/driver/rc.cpp~
--- enigma2-nightly.org/lib/driver/rc.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/driver/rc.cpp~	2013-08-11 08:11:19.094306135 +0200
@@ -0,0 +1,265 @@
+#include <lib/driver/rc.h>
+
+#include <asm/types.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+#include <lib/base/eerror.h>
+
+/*
+ *  note on the enigma input layer:
+ *  the enigma input layer (rc*) supports n different devices which
+ *  all have completely different interfaces, mapped down to 32bit + 
+ *  make/break/release codes mapped down (via xml files) to "actions".
+ *  this was necessary to support multiple remote controls with proprietary
+ *  interfaces. now everybody is using input devices, and thus adding
+ *  another input layer seems to be a bit overkill. BUT:
+ *  image a remote control with two hundred buttons. each and every function
+ *  in enigma can be bound to a button. no need to use them twice. 
+ *  for example, you would have KEY_MENU assigned to a menu for setup etc.,
+ *  but no audio and video settings, since you have special keys for that,
+ *  and you don't want to display a big menu with entries that are available
+ *  with another single key.
+ *  then image a remote control with ten buttons. do you really want to waste
+ *  KEY_MENU for a simple menu? you need the audio/video settings there too.
+ *  take this just as a (bad) example. another (better) example might be front-
+ *  button-keys. usually you have KEY_UP, KEY_DOWN, KEY_POWER. you don't want
+ *  them to behave like the remote-control-KEY_UP, KEY_DOWN and KEY_POWER,
+ *  don't you? 
+ *  so here we can map same keys of different input devices to different 
+ *  actions. have fun.
+ */
+
+eRCDevice::eRCDevice(std::string id, eRCDriver *driver): driver(driver), id(id)
+{
+	input=driver->getInput();
+	driver->addCodeListener(this);
+	eRCInput::getInstance()->addDevice(id, this);
+}
+
+eRCDevice::~eRCDevice()
+{
+	driver->removeCodeListener(this);
+	eRCInput::getInstance()->removeDevice(id.c_str());
+}
+
+eRCDriver::eRCDriver(eRCInput *input): input(input), enabled(1)
+{
+}
+
+eRCDriver::~eRCDriver()
+{
+	for (std::list<eRCDevice*>::iterator i=listeners.begin(); i!=listeners.end(); ++i)
+		delete *i;
+}
+
+void eRCShortDriver::keyPressed(int)
+{
+	__u16 rccode;
+	while (1)
+	{
+		if (read(handle, &rccode, 2)!=2)
+			break;
+		if (enabled && !input->islocked())
+			for (std::list<eRCDevice*>::iterator i(listeners.begin()); i!=listeners.end(); ++i)
+				(*i)->handleCode(rccode);
+	}
+}
+
+eRCShortDriver::eRCShortDriver(const char *filename): eRCDriver(eRCInput::getInstance())
+{
+	handle=open(filename, O_RDONLY|O_NONBLOCK);
+	if (handle<0)
+	{
+		eDebug("failed to open %s", filename);
+		sn=0;
+	} else
+	{
+		sn=eSocketNotifier::create(eApp, handle, eSocketNotifier::Read);
+		CONNECT(sn->activated, eRCShortDriver::keyPressed);
+	}
+}
+
+eRCShortDriver::~eRCShortDriver()
+{
+	if (handle>=0)
+		close(handle);
+}
+
+void eRCInputEventDriver::keyPressed(int)
+{
+	struct input_event ev;
+	while (1)
+	{
+		if (read(handle, &ev, sizeof(struct input_event))!=sizeof(struct input_event))
+			break;
+		if (enabled && !input->islocked())
+			for (std::list<eRCDevice*>::iterator i(listeners.begin()); i!=listeners.end(); ++i)
+				(*i)->handleCode((long)&ev);
+	}
+}
+
+eRCInputEventDriver::eRCInputEventDriver(const char *filename): eRCDriver(eRCInput::getInstance())
+{
+	handle=open(filename, O_RDONLY|O_NONBLOCK);
+	if (handle<0)
+	{
+		eDebug("failed to open %s", filename);
+		sn=0;
+	} else
+	{
+		sn=eSocketNotifier::create(eApp, handle, eSocketNotifier::Read);
+		CONNECT(sn->activated, eRCInputEventDriver::keyPressed);
+		memset(keyCaps, 0, sizeof(keyCaps));
+		::ioctl(handle, EVIOCGBIT(EV_KEY, sizeof(keyCaps)), keyCaps);
+		memset(evCaps, 0, sizeof(evCaps));
+		::ioctl(handle, EVIOCGBIT(0, sizeof(evCaps)), evCaps);
+	}
+}
+
+std::string eRCInputEventDriver::getDeviceName()
+{
+	char name[128]="";
+	if (handle >= 0)
+		::ioctl(handle, EVIOCGNAME(128), name);
+#ifdef FORCE_ADVANCED_REMOTE
+	if (!strcmp(name, "dreambox remote control (native)")) return "dreambox advanced remote control (native)";
+#endif
+	return name;
+}
+
+void eRCInputEventDriver::setExclusive(bool b)
+{
+	if (handle >= 0)
+	{
+		int grab = b;
+		if (::ioctl(handle, EVIOCGRAB, grab) < 0)
+			perror("EVIOCGRAB");
+	}
+}
+
+bool eRCInputEventDriver::hasCap(unsigned char *caps, int bit)
+{
+	return (caps[bit / 8] & (1 << (bit % 8)));
+}
+
+bool eRCInputEventDriver::isKeyboard()
+{
+#ifdef VUPLUS_RC_WORKAROUND
+	return(false);
+#else
+	/* check whether the input device has KEY_A, in which case we assume it is a keyboard */
+	return hasCap(keyCaps, KEY_A);
+#endif
+}
+
+bool eRCInputEventDriver::isPointerDevice()
+{
+#ifdef VUPLUS_RC_WORKAROUND
+	return(false);
+#else
+	return hasCap(evCaps, EV_REL) || hasCap(evCaps, EV_ABS);
+#endif
+}
+
+eRCInputEventDriver::~eRCInputEventDriver()
+{
+	if (handle>=0)
+		close(handle);
+}
+
+eRCConfig::eRCConfig()
+{
+	reload();
+}
+
+eRCConfig::~eRCConfig()
+{
+	save();
+}
+
+void eRCConfig::set( int delay, int repeat )
+{
+	rdelay = delay;
+	rrate = repeat;
+}
+
+void eRCConfig::reload()
+{
+	rdelay=500;
+	rrate=100;
+}
+
+void eRCConfig::save()
+{
+}
+
+eRCInput *eRCInput::instance;
+
+eRCInput::eRCInput()
+{
+	ASSERT( !instance);
+	instance=this;
+	locked = 0;
+	keyboardMode = kmNone;
+}
+
+eRCInput::~eRCInput()
+{
+}
+
+void eRCInput::close()
+{
+}
+
+bool eRCInput::open()
+{
+	return false;
+}
+
+void eRCInput::lock()
+{
+	locked=1;
+	for (std::map<std::string,eRCDevice*>::iterator i=devices.begin(); i != devices.end(); ++i)
+		i->second->setExclusive(false);
+}
+
+void eRCInput::unlock()
+{
+	locked=0;
+	for (std::map<std::string,eRCDevice*>::iterator i=devices.begin(); i != devices.end(); ++i)
+		i->second->setExclusive(true);
+}
+
+void eRCInput::addDevice(const std::string &id, eRCDevice *dev)
+{
+	devices.insert(std::pair<std::string,eRCDevice*>(id, dev));
+}
+
+void eRCInput::removeDevice(const std::string &id)
+{
+	devices.erase(id);
+}
+
+eRCDevice *eRCInput::getDevice(const std::string &id)
+{
+	std::map<std::string,eRCDevice*>::iterator i=devices.find(id);
+	if (i == devices.end())
+	{
+		eDebug("failed, possible choices are:");
+		for (std::map<std::string,eRCDevice*>::iterator i=devices.begin(); i != devices.end(); ++i)
+			eDebug("%s", i->first.c_str());
+		return 0;
+	}
+	return i->second;
+}
+
+std::map<std::string,eRCDevice*,eRCInput::lstr> &eRCInput::getDevices()
+{
+	return devices;
+}
+
+eAutoInitP0<eRCInput> init_rcinput(eAutoInitNumbers::rc, "RC Input layer");
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/vfd.cpp enigma2-nightly.patched/lib/driver/vfd.cpp
--- enigma2-nightly.org/lib/driver/vfd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/driver/vfd.cpp	2013-08-11 08:18:50.230296490 +0200
@@ -0,0 +1,529 @@
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include  <pthread.h>
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#ifdef PLATFORM_TF7700
+#include "../../misc/tools/tffpctl/frontpanel.h"
+#endif
+
+#define VFD_DEVICE "/dev/vfd"
+#define VFDICONDISPLAYONOFF   0xc0425a0a
+#define VFDDISPLAYCHARS       0xc0425a00
+#define VFDBRIGHTNESS         0xc0425a03
+//light on off
+#define VFDDISPLAYWRITEONOFF  0xc0425a05
+
+bool startloop_running = false;
+static bool icon_onoff[32];
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+bool blocked = false;
+bool requested = false;
+bool VFD_CENTER = false;
+bool scoll_loop = false;
+int VFD_SCROLL = 1;
+
+char chars[64];
+char g_str[64];
+
+struct vfd_ioctl_data
+{
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+#ifdef PLATFORM_HS7810A
+	#define VFDLENGTH 4
+#elif defined PLATFORM_OCTAGON1008
+	#define VFDLENGTH 8
+#elif defined (PLATFORM_FORTIS_HDBOX) || defined(PLATFORM_ATEVIO7500)
+	#define VFDLENGTH 12
+#else
+	#define VFDLENGTH 16
+#endif
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+		instance = new evfd;
+	return instance;
+}
+
+evfd::evfd()
+{
+	file_vfd = 0;
+	memset ( chars, ' ', 63 );
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
+
+#ifdef PLATFORM_TF7700
+char * getProgress()
+{
+	int n;
+	static char progress[20] = "0";
+	int fd = open ("/proc/progress", O_RDONLY);
+
+	if (fd < 0)
+		return 0;
+
+	n = read(fd, progress, sizeof(progress));
+	close(fd);
+
+	if (n < 0)
+		n = 0;
+	else if((n > 1) && (progress[n-1] == 0xa))
+		n--;
+
+	progress[n] = 0;
+	return progress;
+}
+
+#define MAX_CHARS 8
+
+void * start_loop (void *arg)
+{
+	int fplarge = open ("/dev/fplarge", O_WRONLY);
+	int fpsmall = open ("/dev/fpsmall", O_WRONLY);
+	int fpc = open ("/dev/fpc", O_WRONLY);
+
+	if ((fplarge < 0) || (fpsmall < 0) || (fpc < 0))
+	{
+		printf("Failed opening devices (%d, %d, %d)\n", fplarge, fpsmall, fpc);
+		return NULL;
+	}
+
+	blocked = true;
+
+	// set scroll mode
+	//frontpanel_ioctl_scrollmode scrollMode = {2, 10, 15};
+	//ioctl(fpc, FRONTPANELSCROLLMODE, &scrollMode);
+
+	// display string
+	char str[] = "        SH4 Git ENIGMA2";
+	int length = strlen(str);
+	char dispData[MAX_CHARS + 1];
+	int offset = 0;
+	int i;
+
+	frontpanel_ioctl_icons icons = {0, 0, 0xf};
+
+	// start the display loop
+	char * progress = getProgress();
+	int index = 2;
+	while (!requested)
+	{
+		// display the CD segments
+		icons.Icons2 = (((1 << index) - 1)) & 0x1ffe;
+		ioctl(fpc, FRONTPANELICON, &icons);
+		index++;
+		if (index > 13)
+		{
+			index = 2;
+			icons.BlinkMode = (~icons.BlinkMode) & 0xf;
+		}
+
+		// display the visible part of the string
+		for (i = 0; i < MAX_CHARS; i++)
+		{
+			dispData[i] = str[(offset + i) % length];
+		}
+		offset++;
+		write(fplarge, dispData, sizeof(dispData));
+		usleep(200000);
+		if ((index % 4) == 0)
+		{
+			// display progress
+			progress = getProgress();
+			write(fpsmall, progress, strlen(progress) + 1);
+			if (strncmp("100", progress, 3) == 0)
+				break;
+		}
+	}
+	// clear all icons
+	frontpanel_ioctl_icons iconsOff = {0xffffffff, 0xffffffff, 0x0};
+	ioctl(fpc, FRONTPANELICON, &iconsOff);
+
+	// clear display
+	write(fpsmall, "    ", 5);
+	write(fplarge, "        ", MAX_CHARS);
+
+	close(fplarge);
+	close(fpsmall);
+	close(fpc);
+	blocked = false;
+
+	return NULL;
+}
+#else
+
+void * start_loop (void *arg)
+{
+	evfd vfd;
+	blocked = true;
+	//vfd.vfd_clear_icons();
+	vfd.vfd_write_string("SH4 Git ENIGMA2", true);
+	//run 2 times through all icons 
+	for (int vloop = 0; vloop < 128; vloop++)
+	{
+#if !defined(PLATFORM_FORTIS_HDBOX) && !defined(PLATFORM_OCTAGON1008) && !defined(PLATFORM_ATEVIO7500) && !defined(PLATFORM_CUBEREVO) && !defined(PLATFORM_CUBEREVO_MINI) && !defined(PLATFORM_CUBEREVO_MINI2) && !defined(PLATFORM_CUBEREVO_MINI_FTA) && !defined(PLATFORM_CUBEREVO_250HD) && !defined(PLATFORM_CUBEREVO_2000HD) && !defined(PLATFORM_CUBEREVO_9500HD) && !defined(PLATFORM_HS7810A)
+		if (vloop%2 == 1)
+		{
+			vfd.vfd_set_icon( (tvfd_icon) (((vloop%32)/2)%16), ICON_OFF, true);
+			//usleep(1000);
+			vfd.vfd_set_icon( (tvfd_icon) ((((vloop%32)/2)%16)+1), ICON_ON, true);
+		}
+#else
+		if (vloop%14 == 0 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 1 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 2 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 3 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 4 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 5 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 6 )
+			vfd.vfd_set_brightness(7);
+		else if (vloop%14 == 7 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 8 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 9 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 10 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 11 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 12 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 13 )
+			vfd.vfd_set_brightness(0);
+#endif
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7);
+#if !defined(PLATFORM_FORTIS_HDBOX) && !defined(PLATFORM_OCTAGON1008) && !defined(PLATFORM_ATEVIO7500) && !defined(PLATFORM_CUBEREVO) && !defined(PLATFORM_CUBEREVO_MINI) && !defined(PLATFORM_CUBEREVO_MINI2) && !defined(PLATFORM_CUBEREVO_MINI_FTA) && !defined(PLATFORM_CUBEREVO_250HD) && !defined(PLATFORM_CUBEREVO_2000HD) && !defined(PLATFORM_CUBEREVO_9500HD) && !defined(PLATFORM_HS7810A)
+	//set all blocked icons
+	for (int id = 0x10; id < 0x20; id++)
+	{
+		vfd.vfd_set_icon((tvfd_icon)id, icon_onoff[id]);
+	}
+#endif
+	blocked = false;
+	return NULL;
+}
+#endif
+
+#if defined(PLATFORM_FORTIS_HDBOX) || defined(PLATFORM_OCTAGON1008) || defined(PLATFORM_ATEVIO7500) || defined(PLATFORM_CUBEREVO) || defined(PLATFORM_CUBEREVO_MINI) || defined(PLATFORM_CUBEREVO_MINI2) || defined(PLATFORM_CUBEREVO_MINI_FTA) || defined(PLATFORM_CUBEREVO_250HD) || defined(PLATFORM_CUBEREVO_2000HD) || defined(PLATFORM_CUBEREVO_9500HD) || defined(PLATFORM_HS7810A)
+void evfd::vfd_write_string_scrollText(char* text)
+{
+	return;
+}
+
+//we can not use a member function (vfd_write_string_scrollText) in pthread, so we use a second (same content) non member function (vfd_write_string_scrollText1)
+static void *vfd_write_string_scrollText1(void *arg)
+{
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+	bool scoll_loop = true;
+	char out[VFDLENGTH+1];
+	int i, len;
+	evfd vfd;
+	len = strlen((char *) g_str);
+	memset(out, 0, VFDLENGTH+1);
+	while (scoll_loop && (len > VFDLENGTH))
+	{
+		if (blocked)
+		{
+			usleep(250000);
+		}
+		else
+		{
+			scoll_loop = false;
+		}
+		for (i=0; i<=(len-VFDLENGTH); i++)
+		{
+			if (blocked)
+			{
+				memset(out, ' ', VFDLENGTH);
+				memcpy(out, g_str+i, VFDLENGTH);
+				vfd.vfd_write_string(out,true);
+				usleep(250000);
+			}
+			else
+			{
+				scoll_loop = false;
+				i = len-VFDLENGTH;
+			}
+		}
+		for (i=1; i < VFDLENGTH; i++)
+		{
+			if (blocked)
+			{
+				memset(out, ' ', VFDLENGTH);
+				memcpy(out, g_str+len+i-VFDLENGTH, VFDLENGTH-i);
+				vfd.vfd_write_string(out,true);
+				usleep(250000);
+			}
+			else
+			{
+				scoll_loop = false;
+				i = VFDLENGTH;
+			}
+		}
+		memcpy(out, g_str, VFDLENGTH);
+		vfd.vfd_write_string(out,true);
+		if (VFD_SCROLL != 2 || !blocked)
+			scoll_loop = false;
+	}
+	blocked = false;
+	return NULL;
+}
+
+void evfd::vfd_write_string(char * str)
+{
+	int i = strlen(str);
+	if (blocked)
+	{
+		pthread_cancel(thread_start_loop);
+		pthread_join(thread_start_loop, NULL);
+		blocked=false;
+	}
+	memset(g_str,0,64);
+	strcpy(g_str,str);
+	vfd_write_string(str, false);
+	if (i > VFDLENGTH && VFD_SCROLL)
+	{
+		blocked = true;
+		pthread_create(&thread_start_loop, NULL, vfd_write_string_scrollText1, (void *)str);
+		pthread_detach(thread_start_loop);
+	}
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int ws = 0;
+	int i = strlen(str);
+	if (VFD_CENTER)
+	{
+		if (i < VFDLENGTH)
+			ws=(VFDLENGTH-i)/2;
+		else
+			ws=0;
+	}
+	if (i > VFDLENGTH) i = VFDLENGTH;
+	struct vfd_ioctl_data data;
+	memset(data.data, ' ', VFDLENGTH);
+	if (VFD_CENTER)
+		memcpy(data.data+ws, str, VFDLENGTH-ws);
+	else
+		memcpy(data.data, str, i);
+	data.start = 0;
+	if (VFD_CENTER)
+		data.length = i+ws<=VFDLENGTH?i+ws:VFDLENGTH;
+	else
+		data.length = i;
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		write(file_vfd,data.data,data.length);
+		close (file_vfd);
+	return;
+}
+
+#else
+
+void evfd::vfd_write_string(char * str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int i;
+	i = strlen ( str );
+	if ( i > 63 ) i = 63;
+	memset ( chars, ' ', 63 );
+	memcpy ( chars, str, i);
+#ifdef PLATFORM_TF7700
+	// request the display to cancel the start loop
+	requested = true;
+	while(blocked) usleep(200000);
+	{
+#else
+	if (!blocked || force)
+	{
+#endif
+		struct vfd_ioctl_data data;
+		memset ( data.data, ' ', 63 );
+		memcpy ( data.data, str, i );
+
+		data.start = 0;
+		data.length = i;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl ( file_vfd, VFDDISPLAYCHARS, &data );
+		close (file_vfd);
+	}
+	return;
+}
+
+void evfd::vfd_write_string_scrollText(char* text)
+{
+	if (!blocked)
+	{
+		int i, len = strlen(text);
+		char* out = (char *) malloc(16);
+		for (i=0; i<=(len-16); i++)
+		{ // scroll text till end
+			memset(out, ' ', 16);
+			memcpy(out, text+i, 16);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		for (i=1; i<16; i++)
+		{ // scroll text with whitespaces from right
+			memset(out, ' ', 16);
+			memcpy(out, text+len+i-16, 16-i);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		memcpy(out, text, 16); // display first 16 chars after scrolling
+		vfd_write_string(out);
+		free (out);
+	}
+	return;
+}
+#endif
+void evfd::vfd_clear_string()
+{
+	vfd_write_string("                ");
+	return;
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff)
+{
+	vfd_set_icon(id, onoff, false);
+	return;
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff, bool force)
+{
+	icon_onoff[id] = onoff;
+	if (!blocked || force)
+	{
+		struct vfd_ioctl_data data;
+		if (!startloop_running)
+		{
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+			data.start = 0x00;
+			data.data[0] = id;
+			data.data[4] = onoff;
+			data.length = 5;
+
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+	return;
+}
+
+void evfd::vfd_clear_icons()
+{
+	for (int id = 0x10; id < 0x20; id++)
+	{
+		vfd_set_icon((tvfd_icon)id, false);
+	}
+	return;
+}
+
+void evfd::vfd_set_brightness(unsigned char setting)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDBRIGHTNESS, &data );
+	close (file_vfd);
+
+	return;
+}
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+		data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+	return;
+}
+
+void evfd::vfd_set_fan(bool onoff)
+{
+#if defined(PLATFORM_CUBEREVO) || defined(PLATFORM_CUBEREVO_MINI) || defined(PLATFORM_CUBEREVO_MINI2) || defined(PLATFORM_CUBEREVO_MINI_FTA) || defined(PLATFORM_CUBEREVO_250HD) || defined(PLATFORM_CUBEREVO_2000HD) || defined(PLATFORM_CUBEREVO_9500HD)
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+		data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, 0xc0425af8, &data);
+
+	close (file_vfd);
+#endif
+	return;
+}
+
+void evfd::vfd_set_SCROLL(int id)
+{
+	VFD_SCROLL=id;
+}
+
+void evfd::vfd_set_CENTER(bool id)
+{
+	VFD_CENTER=id;
+}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/vfd.h enigma2-nightly.patched/lib/driver/vfd.h
--- enigma2-nightly.org/lib/driver/vfd.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/driver/vfd.h	2013-08-11 08:18:50.234296344 +0200
@@ -0,0 +1,49 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+#ifndef PLATFORM_HDBOX
+typedef enum { USB = 0x10, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+#else
+typedef enum { USB = 0x10, STANDBY, SAT, REC, TIMESHIFT, TIMER, HD, LOCK, DD, MUTE, TUNER1, TUNER2, MP3, REPEAT,
+			    PLAY, PAUSE, TER, FILE, 480i, 480p, 576i, 576p, 720p, 1080i, 1080p } tvfd_icon;
+#endif
+
+class evfd
+{
+protected:
+	static evfd *instance;
+	int file_vfd;
+	int vfd_type;
+#ifdef SWIG
+	evfd();
+	~evfd();
+#endif
+public:
+#ifndef SWIG
+	evfd();
+	~evfd();
+#endif
+	void init();
+	static evfd* getInstance();
+
+	int getVfdType() { return vfd_type; }
+	void vfd_set_SCROLL(int id);
+	void vfd_set_CENTER(bool id);
+	void vfd_set_icon(tvfd_icon id, bool onoff);
+	void vfd_set_icon(tvfd_icon id, bool onoff, bool force);
+	void vfd_clear_icons();
+
+	void vfd_write_string(char * string);
+	void vfd_write_string(char * str, bool force);
+	void vfd_write_string_scrollText(char* text);
+	void vfd_clear_string();
+	
+	void vfd_set_brightness(unsigned char setting);
+	void vfd_set_light(bool onoff);
+	void vfd_set_fan(bool onoff);
+};
+
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/decoder.cpp enigma2-nightly.patched/lib/dvb/decoder.cpp
--- enigma2-nightly.org/lib/dvb/decoder.cpp	2013-08-11 08:11:19.122306128 +0200
+++ enigma2-nightly.patched/lib/dvb/decoder.cpp	2013-08-11 08:18:50.234296344 +0200
@@ -41,7 +41,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -49,6 +53,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - audio - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -56,6 +61,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	int bypass = 0;
 
 	switch (type)
@@ -91,7 +97,9 @@
 		eDebug("failed (%m)");
 	else
 		eDebug("ok");
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("AUDIO_PLAY - ");
 	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -266,7 +274,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -274,6 +286,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - video - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -282,6 +295,7 @@
 	}
 	eDebug("ok");
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("VIDEO_PLAY - ");
 	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -523,7 +537,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_PCR1 : DMX_PES_PCR0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -531,6 +549,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - pcr - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -538,6 +557,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -578,7 +598,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_TELETEXT1 : DMX_PES_TELETEXT0; // FIXME
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - ttx - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -587,6 +611,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - ttx - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -594,6 +619,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -729,12 +755,28 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__) // see comment below
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__)
+// the VIDEO_CONTINUE would reset the FASTFORWARD  command so we
+// execute the FASTFORWARD after the VIDEO_CONTINUE
+			if (s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
+#endif
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1032,6 +1074,10 @@
 		{
 			struct stat s;
 			fstat(f, &s);
+#if defined(__sh__) // our driver has a different behaviour for iframes
+			if (m_video_clip_fd >= 0)
+				finishShowSinglePic();
+#endif
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
@@ -1052,8 +1098,10 @@
 
 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
 					eDebug("VIDEO_SELECT_SOURCE MEMORY failed (%m)");
+#if not defined(__sh__)
 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
 					eDebug("VIDEO_SET_STREAMTYPE failed(%m)");
+#endif
 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
 					eDebug("VIDEO_PLAY failed (%m)");
 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
@@ -1070,7 +1118,9 @@
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				writeAll(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__)
 				m_showSinglePicTimer->start(150, true);
+#endif
 			}
 			close(f);
 		}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/dvb.cpp enigma2-nightly.patched/lib/dvb/dvb.cpp
--- enigma2-nightly.org/lib/dvb/dvb.cpp	2013-08-11 08:11:19.122306128 +0200
+++ enigma2-nightly.patched/lib/dvb/dvb.cpp	2013-08-11 08:18:50.234296344 +0200
@@ -115,6 +115,62 @@
 		m_boxtype = DM800SE;
 	else if (!strncmp(tmp, "dm7020hd\n", rd))
 		m_boxtype = DM7020HD;
+#if defined(__sh__)
+	else if (!strncmp(tmp, "adb_box\n", rd))
+		m_boxtype = ADB_BOX;
+	else if (!strncmp(tmp, "ufs910\n", rd))
+		m_boxtype = UFS910;
+	else if (!strncmp(tmp, "ufs912\n", rd))
+		m_boxtype = UFS912;
+	else if (!strncmp(tmp, "ufs913\n", rd))
+		m_boxtype = UFS913;
+	else if (!strncmp(tmp, "ufs922\n", rd))
+		m_boxtype = UFS922;
+	else if (!strncmp(tmp, "tf7700hdpvr\n", rd))
+		m_boxtype = TF7700HDPVR;
+	else if (!strncmp(tmp, "hdbox\n", rd))
+		m_boxtype = HDBOX;
+	else if (!strncmp(tmp, "hl101\n", rd))
+		m_boxtype = HL101;
+	else if (!strncmp(tmp, "spark\n", rd))
+		m_boxtype = SPARK;
+	else if (!strncmp(tmp, "spark7162\n", rd))
+		m_boxtype = SPARK7162;
+	else if (!strncmp(tmp, "vip1-v2\n", rd))
+		m_boxtype = VIP1_V2;
+	else if (!strncmp(tmp, "vip2-v1\n", rd))
+		m_boxtype = VIP2_V1;
+	else if (!strncmp(tmp, "cuberevo\n", rd))
+		m_boxtype = CUBEREVO;
+	else if (!strncmp(tmp, "cuberevo-9500hd\n", rd))
+		m_boxtype = CUBEREVO_9500HD;
+	else if (!strncmp(tmp, "cuberevo-mini\n", rd))
+		m_boxtype = CUBEREVO_MINI;
+	else if (!strncmp(tmp, "cuberevo-mini2\n", rd))
+		m_boxtype = CUBEREVO_MINI2;
+	else if (!strncmp(tmp, "cuberevo-2000hd\n", rd))
+		m_boxtype = CUBEREVO_2000HD;
+	else if (!strncmp(tmp, "cuberevo-250hd\n", rd))
+		m_boxtype = CUBEREVO_250HD;
+	else if (!strncmp(tmp, "cuberevo-mini-fta\n", rd))
+		m_boxtype = CUBEREVO_MINI_FTA;
+	else if (!strncmp(tmp, "ipbox9900\n", rd))
+		m_boxtype = IPBOX9900;
+	else if (!strncmp(tmp, "ipbox99\n", rd))
+		m_boxtype = IPBOX99;
+	else if (!strncmp(tmp, "ipbox55\n", rd))
+		m_boxtype = IPBOX55;
+	else if (!strncmp(tmp, "octagon1008\n", rd))
+		m_boxtype = OCTAGON1008;
+	else if (!strncmp(tmp, "hs7810a\n", rd))
+		m_boxtype = HS7810A;
+	else if (!strncmp(tmp, "hs7110\n", rd))
+		m_boxtype = HS7110;
+	else if (!strncmp(tmp, "whitebox\n", rd))
+		m_boxtype = WHITEBOX;
+	else if (!strncmp(tmp, "atevio7500\n", rd))
+		m_boxtype = ATEVIO7500;
+#else
 	else {
 		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
@@ -124,7 +180,7 @@
 		else
 			m_boxtype = DM8000;
 	}
-
+#endif
 	eDebug("found %zd adapter, %zd frontends(%zd sim) and %zd demux, boxtype %d",
 		m_adapter.size(), m_frontend.size(), m_simulate_frontend.size(), m_demux.size(), m_boxtype);
 
@@ -963,6 +1019,58 @@
 			}
 		}
 	}
+#if defined(__sh__) // we use our own algo for demux detection
+	else if (m_boxtype == ADB_BOX || m_boxtype == UFS910 || m_boxtype == UFS912 || m_boxtype == UFS913 || m_boxtype == UFS922 || m_boxtype == SPARK || m_boxtype == SPARK7162 || m_boxtype == TF7700HDPVR || m_boxtype == HDBOX ||
+		m_boxtype == HL101 || m_boxtype == CUBEREVO || m_boxtype == CUBEREVO_MINI || m_boxtype == CUBEREVO_MINI2 || m_boxtype == VIP1_V2 || m_boxtype == VIP2_V1 || m_boxtype == HS7810A || m_boxtype == HS7110 || m_boxtype == WHITEBOX ||
+		m_boxtype == CUBEREVO_MINI_FTA || m_boxtype == CUBEREVO_250HD || m_boxtype == CUBEREVO_2000HD || m_boxtype == CUBEREVO_9500HD || m_boxtype == OCTAGON1008 || m_boxtype == ATEVIO7500 ||
+		m_boxtype == IPBOX9900 || m_boxtype == IPBOX99 || m_boxtype == IPBOX55)
+	{
+		int n=0;
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if(fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+					{
+						// take the first unused
+						//eDebug("\nallocate demux b = %d\n",n);
+						unused = i;
+					}
+				}
+				else if (i->m_adapter == fe->m_adapter && i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					// take the demux allocated to the same
+					// frontend,  just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux b = %d\n",n);
+					return 0;
+				}
+			}
+			else if(n == (m_demux.size() - 1))
+			{
+				// Always use the last demux for PVR
+				// it is assumed that the last demux is not
+				// attached to a frontend. That is, there
+				// should be one instance of dvr & demux
+				// devices more than of frontend devices.
+				// Otherwise, playback and timeshift might
+				// interfere recording.
+				if (i->m_inuse)
+				{
+					// just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux c = %d\n",n);
+					return 0;
+				}
+				unused = i;
+				//eDebug("\nallocate demux d = %d\n", n);
+				break;
+			}
+		}
+	}
+#endif
 	else
 	{
 		iDVBAdapter *adapter = fe ? fe->m_adapter : m_adapter.begin(); /* look for a demux on the same adapter as the frontend, or the first adapter for dvr playback */
@@ -2118,6 +2226,12 @@
 			return -ENODEV;
 		}
 #else
+#if defined(__sh__) // our pvr device is called dvr
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
@@ -2134,6 +2248,7 @@
 			return -ENODEV;
 		}
 #endif
+#endif
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/dvb.h enigma2-nightly.patched/lib/dvb/dvb.h
--- enigma2-nightly.org/lib/dvb/dvb.h	2013-08-11 08:11:19.126306130 +0200
+++ enigma2-nightly.patched/lib/dvb/dvb.h	2013-08-11 08:18:50.234296344 +0200
@@ -161,7 +161,11 @@
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
+#if not defined(__sh__)
 	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD };
+#else
+	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD, ADB_BOX, UFS910, UFS912, UFS913, UFS922, TF7700HDPVR, HDBOX, HL101, CUBEREVO, CUBEREVO_MINI, CUBEREVO_MINI2, CUBEREVO_MINI_FTA, CUBEREVO_250HD, CUBEREVO_9500HD, CUBEREVO_2000HD, IPBOX9900, IPBOX99, IPBOX55, OCTAGON1008, VIP1_V2, VIP2_V1, SPARK, SPARK7162, ATEVIO7500, HS7810A, HS7110, WHITEBOX};
+#endif
 
 	int m_boxtype;
 
@@ -273,6 +277,9 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__) //see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/epgcache.cpp enigma2-nightly.patched/lib/dvb/epgcache.cpp
--- enigma2-nightly.org/lib/dvb/epgcache.cpp	2013-08-11 08:11:19.130306132 +0200
+++ enigma2-nightly.patched/lib/dvb/epgcache.cpp	2013-08-11 08:18:50.238296228 +0200
@@ -221,10 +221,22 @@
 	int tmp = ByteSize - 10;
 	memcpy(data, EITdata, 10);
 	unsigned int descriptors_length = 0;
+#ifndef __sh__
 	__u32 *p = (__u32*)(EITdata + 10);
+#else
+	// Dagobert: fix not aligned access
+	__u8 *p = (__u8*)(EITdata+10);
+#endif
 	while (tmp > 3)
 	{
+#ifndef __sh__
 		descriptorMap::iterator it = descriptors.find(*p++);
+#else
+		__u32 index = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+		// eDebug("index %d %x, %x %x %x %x\n", index, index, p[0], p[1], p[2], p[3]);
+		descriptorMap::iterator it = descriptors.find(index);
+		p += 4;
+#endif
 		if (it != descriptors.end())
 		{
 			unsigned int b = it->second.second[1] + 2;
@@ -249,12 +261,23 @@
 	if ( ByteSize )
 	{
 		CacheSize -= ByteSize;
+#ifndef __sh__
 		__u32 *d = (__u32*)(EITdata+10);
+#else	// Dagobert: fix not aligned access
+		__u8 *d = (__u8*)(EITdata+10);
+#endif
 		ByteSize -= 10;
 		while(ByteSize>3)
 		{
+#ifndef __sh__
 			descriptorMap::iterator it =
 				descriptors.find(*d++);
+#else
+			__u32 index = d[3] << 24 | d[2] << 16 | d[1] << 8 | d[0];
+			// eDebug("index %d %x, %x %x %x %x\n", index, index, d[0], d[1], d[2], d[3]);
+			descriptorMap::iterator it = descriptors.find(index);
+			d += 4;
+#endif
 			if ( it != descriptors.end() )
 			{
 				descriptorPair &p = it->second;
@@ -1790,6 +1813,45 @@
 {
 	int map;
 	iDVBSectionReader *reader = NULL;
+#ifdef __sh__
+/* Dagobert: this is still very hacky, but currently I cant find
+ * the origin of the readData call. I think the caller is
+ * responsible for the unaligned data pointer in this call.
+ * So we malloc our own memory here which _should_ be aligned.
+ *
+ * TODO: We should search for the origin of this call. As I
+ * said before I need an UML Diagram or must try to import
+ * e2 and all libs into an IDE for better overview ;)
+ *
+ */
+	const __u8 *aligned_data;
+	bool isNotAligned = false;
+
+	if ((unsigned int) data % 4 != 0)
+		isNotAligned = true;
+
+	if (isNotAligned)
+	{
+		/* see HILO macro and eit.h */
+		int len = ((data[1] & 0x0F) << 8 | data[2]) -1;
+
+		/*eDebug("len %d %x, %x %x\n", len, len, data[1], data[2]);*/
+
+		if ( EIT_SIZE >= len )
+			return;
+
+		aligned_data = (const __u8 *) malloc(len);
+
+		if ((unsigned int)aligned_data % 4 != 0)
+		{
+			eDebug("eEPGCache::channel_data::readData: ERRORERRORERROR: unaligned data pointer %p\n", aligned_data);
+		}
+
+		/*eDebug("%p %p\n", aligned_data, data); */
+		memcpy((void *) aligned_data, (const __u8 *) data, len);
+		data = aligned_data;
+	}
+#endif
 	switch (source)
 	{
 		case NOWNEXT:
@@ -1894,6 +1956,10 @@
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+		free((void *)aligned_data);
+#endif
 }
 
 #if ENABLE_FREESAT
@@ -2979,11 +3045,20 @@
 						{
 							__u8 *data = evData->EITdata;
 							int tmp = evData->ByteSize-10;
+#ifndef __sh__
 							__u32 *p = (__u32*)(data+10);
+#else	// Dagobert: Alignment fix
+							__u8 *p = (__u8*)(data+10);
+#endif
 							// search short and extended event descriptors
 							while(tmp>3)
 							{
+#ifndef __sh__
 								__u32 crc = *p++;
+#else	// Dagobert: Alignment fix
+								__u32 crc = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+								p += 4;
+#endif
 								descriptorMap::iterator it =
 									eventData::descriptors.find(crc);
 								if (it != eventData::descriptors.end())
@@ -3162,12 +3237,21 @@
 				}
 				__u8 *data = evit->second->EITdata;
 				int tmp = evit->second->ByteSize-10;
+#ifndef __sh__
 				__u32 *p = (__u32*)(data+10);
+#else	// Dagobert: Alignment fix
+				__u8 *p = (__u8*)(data+10);
+#endif
 				// check if any of our descriptor used by this event
 				int cnt=-1;
 				while(tmp>3)
 				{
+#ifndef __sh__
 					__u32 crc32 = *p++;
+#else	// Dagobert: Alignment fix
+					__u32 crc32 = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+					p += 4;
+#endif
 					for ( int i=0; i <= descridx; ++i)
 					{
 						if (descr[i] == crc32)  // found...
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/pmt.cpp enigma2-nightly.patched/lib/dvb/pmt.cpp
--- enigma2-nightly.org/lib/dvb/pmt.cpp	2013-08-11 08:11:19.138306132 +0200
+++ enigma2-nightly.patched/lib/dvb/pmt.cpp	2013-08-11 08:18:50.238296228 +0200
@@ -744,6 +744,11 @@
 			eDVBCIInterfaces::getInstance()->addPMTHandler(this);
 	} else if (!simulate) // no simulation of playback services
 	{
+		if (m_service_type == streamclient)
+		{
+			eDebug("force setServiceID(1)");
+			m_reference.setServiceID(1);
+		}
 		if (!ref.getServiceID().get() /* incorrect sid in meta file or recordings.epl*/ )
 		{
 			eDVBTSTools tstools;
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/volume.cpp enigma2-nightly.patched/lib/dvb/volume.cpp
--- enigma2-nightly.org/lib/dvb/volume.cpp	2013-08-11 08:11:19.146306132 +0200
+++ enigma2-nightly.patched/lib/dvb/volume.cpp	2013-08-11 08:18:50.238296228 +0200
@@ -34,7 +34,9 @@
 	openMixer();
 #endif
 	volumeUnMute();
+#if not defined (__sh__) // dont reset volume on start
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_appmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_appmgr.cpp	2013-08-11 08:18:50.242296078 +0200
@@ -94,6 +94,9 @@
 	eDebug("in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+#endif
 	return 0;
 }
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci.cpp	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci.cpp	2013-08-11 08:18:50.242296078 +0200
@@ -18,6 +18,11 @@
 
 #include <dvbsi++/ca_program_map_section.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+//#define x_debug
+#endif
+
 //#define CIDEBUG 1
 
 #ifdef CIDEBUG
@@ -28,6 +33,229 @@
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
+#ifdef __sh__
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+}
+
+/* from dvb-apps */
+int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+//send some data on an fd, for a special slot and connection_id
+eData eDVBCISlot::sendData(unsigned char* data, int len)
+{
+#ifdef x_debug
+	printf("%s: %p, %d\n", __func__, data, len);
+#endif
+
+	unsigned char *d = (unsigned char*) malloc(len + 5);
+
+	/* should we send a data last ? */
+	if (data != NULL)
+	{
+		if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		{
+			memcpy(d, data, len);
+		}
+		else
+		{
+			//send data_last and data
+			memcpy(d + 5, data, len);
+			d[0] = getSlotID();
+			d[1] = connection_id;
+			d[2] = T_DATA_LAST;
+			d[3] = len + 1; 		/* len */
+			d[4] = connection_id; 	/* transport connection identifier*/
+			len += 5;
+		}
+	}
+	else
+	{
+		//send a data last only
+		d[0] = getSlotID();
+		d[1] = connection_id;
+		d[2] = T_DATA_LAST;
+		d[3] = len + 1; 		/* len */
+		d[4] = connection_id; 	/* transport connection identifier*/
+		len = 5;
+	}
+
+#ifdef x_debug
+	printf("write (%d): > ", getSlotID());
+	for (int i=0; i < len; i++)
+		printf("%02x ",d[i]);
+	printf("\n");
+#endif
+
+#ifdef direct_write
+	res = write(fd, d, len);
+
+	free(d);
+	if (res < 0 || res != len)
+	{
+		printf("error writing data to fd %d, slot %d: %m\n", fd, getSlotID());
+		return eDataError;
+	}
+#else
+	sendqueue.push( queueData(d, len) );
+#endif
+	return eDataReady;
+}
+
+//send a transport connection create request
+bool eDVBCISlot::sendCreateTC()
+{
+	//printf("%s:%s >\n", FILENAME, __FUNCTION__);
+	unsigned char* data = (unsigned char*) malloc(sizeof(char) * 5);
+	tx_time.tv_sec = 0;
+	data[0] = getSlotID();
+	data[1] = getSlotID() + 1; 	/* conid */
+	data[2] = T_CREATE_T_C;
+	data[3] = 1;
+	data[4] = getSlotID() + 1 	/*conid*/;
+	write(fd, data, 5);
+	//printf("%s:%s <\n", FILENAME, __FUNCTION__);
+	return true;
+}
+
+void eDVBCISlot::process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+	switch (tpdu_tag)
+	{
+		case T_C_T_C_REPLY:
+			printf("Got CTC Replay (slot %d, con %d)\n", getSlotID(), connection_id);
+
+			tx_time.tv_sec = 0;
+
+			state = stateInserted;
+
+			//answer with data last (and if we have with data)
+			sendData(NULL, 0);
+
+			break;
+		case T_DELETE_T_C:
+//FIXME: close sessions etc; reset ?
+//we must answer here with t_c_replay
+			printf("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+			break;
+		case T_D_T_C_REPLY:
+			printf("Got \"Delete Transport Connection Replay\" from module!\n");
+			break;
+		case T_REQUEST_T_C:
+			printf("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+			break;
+		case T_DATA_MORE:
+		{
+			int new_data_length = receivedLen + asn_data_length;
+			printf("Got \"Data More\" from Module\n");
+			__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+			receivedData = new_data_buffer;
+			memcpy(receivedData + receivedLen, data, asn_data_length);
+			receivedLen = new_data_length;
+			tx_time.tv_sec = 0;
+			break;
+		}
+		case T_DATA_LAST:
+#ifdef x_debug
+			printf("Got \"Data Last\" from Module\n");
+#endif
+			tx_time.tv_sec = 0;
+			/* single package */
+			if (receivedData == NULL)
+			{
+				printf("->single package\n");
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < asn_data_length; i++)
+					printf("%02x ", data[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, data, asn_data_length);
+				eDVBCISession::pollAll();
+			}
+			else
+			{
+				/* chained package */
+				int new_data_length = receivedLen + asn_data_length;
+				printf("->chained data\n");
+				__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+				receivedData = new_data_buffer;
+				memcpy(receivedData + receivedLen, data, asn_data_length);
+				receivedLen = new_data_length;
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < receivedLen; i++)
+					printf("%02x ", receivedData[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, receivedData, receivedLen);
+				eDVBCISession::pollAll();
+//fixme: must also be moved in e2 behind the data processing ;)
+				free(receivedData);
+				receivedData = NULL;
+				receivedLen = 0;
+			}
+			break;
+		case T_SB:
+		{
+#ifdef x_debug
+			printf("Got \"SB\" from Module\n");
+#endif
+			if (data[0] & 0x80)
+			{
+				printf("->data ready (%d)\n", getSlotID());
+				// send the RCV and ask for the data
+				unsigned char send_data[5];
+				send_data[0] = getSlotID();
+				send_data[1] = connection_id;
+				send_data[2] = T_RCV;
+				send_data[3] = 1;
+				send_data[4] = connection_id;
+				write(fd, send_data, 5);
+				gettimeofday(&tx_time, 0);
+			}
+			else
+			{
+				tx_time.tv_sec = 0;
+			}
+			break;
+		}
+		default:
+			printf("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+	}
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
 {
 	int num_ci = 0;
@@ -39,7 +267,11 @@
 	while (1)
 	{
 		char filename[128];
+#ifdef __sh__
+		sprintf(filename, "/dev/dvb/adapter0/ci%d", num_ci);
+#else
 		sprintf(filename, "/dev/ci%d", num_ci);
+#endif
 
 		if (::access(filename, R_OK) < 0) break;
 
@@ -954,8 +1186,13 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+#ifdef __sh__
+		sendData(d, len);
+		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#else
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 	}
 
 	return res;
@@ -964,6 +1201,7 @@
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("CISlot %d what %d\n", getSlotID(), what);
+#ifndef __sh__
 	if(what == eSocketNotifier::Priority) {
 		if(state != stateRemoved) {
 			state = stateRemoved;
@@ -1019,6 +1257,166 @@
 		else
 			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
 	}
+#else
+	unsigned char data[1024];
+	int len = 1024;
+	unsigned char* d;
+	eData status;
+	ca_slot_info_t info;
+
+	if (what & eSocketNotifier::Read)
+	{
+		eDebugCI("eSocketNotifier::Read\n");
+		status = eDataReady;
+		len = ::read(fd, data, len);
+	}
+	else if (what & eSocketNotifier::Write)
+	{
+		eDebugCI("eSocketNotifier::Write\n");
+		status = eDataWrite;
+	}
+	else if (what & eSocketNotifier::Priority)
+	{
+		eDebugCI("eSocketNotifier::Priority\n");
+		status = eDataStatusChanged;
+	}
+
+	switch (getState())
+	{
+		case stateInvalid:
+		{
+			if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("1. cam status changed ->cam now present\n");
+					state = stateInserted;
+					mmi_active = false;
+					tx_time.tv_sec = 0;
+					application_manager = 0;
+					ca_manager = 0;
+					sendCreateTC();
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+				}
+			}
+			else
+			{
+				usleep(100000);
+			}
+		}
+		break;
+		case stateInserted:
+		{
+			if (status == eDataReady)
+			{
+				eDebugCI("received data - len %d\n", len);
+				//int s_id = data[0];
+				//int c_id = data[1];
+				//printf("%d: s_id = %d, c_id = %d\n", slot->slot, s_id, c_id);
+				d = data;
+				/* taken from the dvb-apps */
+				int data_length = len - 2;
+				d += 2; /* remove leading slot and connection id */
+				while (data_length > 0)
+				{
+					unsigned char tpdu_tag = d[0];
+					unsigned short asn_data_length;
+					int length_field_len;
+					if ((length_field_len = asn_1_decode(&asn_data_length, d + 1, data_length - 1)) < 0)
+					{
+						printf("Received data with invalid asn from module on slot %02x\n", getSlotID());
+						break;
+					}
+
+					if ((asn_data_length < 1) || (asn_data_length > (data_length - (1 + length_field_len))))
+					{
+						printf("Received data with invalid length from module on slot %02x\n", getSlotID());
+						break;
+					}
+					connection_id = d[1 + length_field_len];
+					//printf("Setting connection_id from received data to %d\n", slot->connection_id);
+					d += 1 + length_field_len + 1;
+					data_length -= (1 + length_field_len + 1);
+					asn_data_length--;
+					process_tpdu(tpdu_tag, d, asn_data_length, connection_id);
+					// skip over the consumed data
+					d += asn_data_length;
+					data_length -= asn_data_length;
+				} // while (data_length)
+			} /* data ready */
+			else if (status == eDataWrite)
+			{
+				if (!sendqueue.empty() && (tx_time.tv_sec == 0)) 
+				{
+					const queueData &qe = sendqueue.top();
+					int res = write(fd, qe.data, qe.len);
+					if (res >= 0 && (unsigned int)res == qe.len)
+					{
+						delete [] qe.data;
+						sendqueue.pop();
+						gettimeofday(&tx_time, 0);
+					}
+					else
+					{
+						printf("r = %d, %m\n", res);
+					}
+				}
+				/* the spec say's that we _must_ poll the connection
+				 * if the transport connection is in active state
+				 */
+				if ((tx_time.tv_sec == 0) && (!checkQueueSize()) && (time_after(last_poll_time, 1000)))
+				{
+					sendData(NULL, 0);
+					clock_gettime(CLOCK_MONOTONIC, &last_poll_time);
+				}
+			}
+			else if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("2. cam status changed ->cam now present\n");
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1); 
+				}
+				else if (!(info.flags & CA_CI_MODULE_READY))
+				{
+					printf("cam status changed ->cam now _not_ present\n");
+					eDVBCISession::deleteSessions(this);
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCIInterfaces::getInstance()->ciRemoved(this);
+					eDVBCI_UI::getInstance()->setState(getSlotID(),0);
+					while (sendqueue.size())
+					{
+						delete [] sendqueue.top().data;
+						sendqueue.pop();
+					}
+				}
+			}
+		}
+		break;
+		default:
+			printf("unknown state %d\n", state);
+		break;
+	}
+	notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 }
 
 DEFINE_REF(eDVBCISlot);
@@ -1037,7 +1435,11 @@
 	
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1048,10 +1450,24 @@
 	eDebugCI("CI Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	receivedLen = 0;
+	receivedData = NULL;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+		tx_time.tv_sec = 0;
+		tx_time.tv_usec = 0;
+		last_poll_time.tv_sec = 0;
+		last_poll_time.tv_nsec = 0;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
+#ifdef __sh__
+		reset();
+#endif
 	} else
 	{
 		perror(filename);
@@ -1087,6 +1503,13 @@
 {
 	eDebug("CI Slot %d: reset requested", getSlotID());
 
+#ifdef __sh__
+	state = stateInvalid;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+	eDVBCISession::deleteSessions(this);
+	eDVBCIInterfaces::getInstance()->ciRemoved(this);
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1094,6 +1517,7 @@
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif
 
 	while(sendqueue.size())
 	{
@@ -1101,7 +1525,12 @@
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci.h enigma2-nightly.patched/lib/dvb_ci/dvbci.h
--- enigma2-nightly.org/lib/dvb_ci/dvbci.h	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci.h	2013-08-11 08:18:50.242296078 +0200
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -43,6 +46,42 @@
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
 
+#ifdef __sh__
+/* ********************************** */
+/* constants taken from dvb-apps 
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+				 // layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+				 // layers
+
+typedef enum {eDataTimeout, eDataError, eDataReady, eDataWrite, eDataStatusChanged} eData;
+
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 class eDVBCISlot: public iObject, public Object
 {
 	friend class eDVBCIInterfaces;
@@ -66,6 +105,13 @@
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char connection_id;
+	bool mmi_active;
+	int receivedLen;
+	unsigned char* receivedData;
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -95,6 +141,17 @@
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(data_source source);
 	int setClockRate(int);
+#ifdef __sh__
+	bool checkQueueSize();
+	void thread();
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+	void process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+	bool sendCreateTC();
+	eData sendData(unsigned char* data, int len);
+	struct timeval tx_time;
+	struct timespec last_poll_time;
+#endif
 };
 
 struct CIPmtHandler
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_mmi.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_mmi.cpp	2013-08-11 08:18:50.246295967 +0200
@@ -25,6 +25,9 @@
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	slot->mmiClosed();
+#endif
 	slot->setMMIManager(NULL);
 	eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_resmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_resmgr.cpp	2013-08-11 08:18:50.246295967 +0200
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLine("SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLine("SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebug("");
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_session.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_session.cpp	2013-08-11 08:18:50.246295967 +0200
@@ -257,6 +257,12 @@
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seems to have some problems
+			//on some modules which "looses" the connection. So reset it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 		
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/accel.cpp enigma2-nightly.patched/lib/gdi/accel.cpp
--- enigma2-nightly.org/lib/gdi/accel.cpp	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/gdi/accel.cpp	2013-08-11 08:18:50.246295967 +0200
@@ -15,8 +15,25 @@
 // #define ACCEL_DEBUG
 
 gAccel *gAccel::instance;
+#if not defined(__sh__)
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -53,6 +70,9 @@
 {
 	instance = this;
 
+#ifdef STMFB_ACCEL
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL	
 	ati_accel_init();
 #endif
@@ -63,6 +83,9 @@
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -146,6 +169,77 @@
 
 int gAccel::blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	//eDebug( "src: %4d %4d %4d %4d\tdst: %4d %4d %4d %4d\n"
+	//		"area: %4d %4d %4d %4d\tp: %4d %4d %4d %4d\n",
+	//		src->data_phys, src->x, src->y, src->stride,
+	//		dst->data_phys, dst->x, dst->y, dst->stride, 
+	//		area.left(), area.top(), area.width(), area.height(),
+	//		p.x(), p.y(), p.width(), p.height());
+
+	int src_format = 0;
+	void *data = 0;
+	int data_phys = 0;
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+		if (accelAlloc(data, data_phys, area.height() * area.width() * 4))
+			return -1;
+
+		__u8 *srcptr=(__u8*)src->data;
+		__u8 *dstptr=(__u8*)data;
+		__u32 pal[256];
+
+		for (int i=0; i<256; ++i)
+		{
+			if (src->clut.data && (i<src->clut.colors))
+				pal[i]=(src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i]=0x010101*i;
+			if ((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i]^=0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y=0; y<area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if (data_phys)
+			accelFree(data_phys);
+		return -1;
+	}
+
+	if (data_phys)
+	{
+		stmfb_accel_blit(
+			data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(data_phys);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/fb.cpp enigma2-nightly.patched/lib/gdi/fb.cpp
--- enigma2-nightly.org/lib/gdi/fb.cpp	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/fb.cpp	2013-08-11 08:18:50.246295967 +0200
@@ -8,6 +8,9 @@
 #include <linux/kd.h>
 
 #include <lib/gdi/fb.h>
+#ifdef __sh__
+#include <linux/stmfb.h>
+#endif
 
 #ifndef FBIO_WAITFORVSYNC
 #define FBIO_WAITFORVSYNC _IOW('F', 0x20, __u32)
@@ -47,11 +50,13 @@
 	}
 
 
+#if not defined(__sh__)
 	if (ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo)<0)
 	{
 		perror("FBIOGET_VSCREENINFO");
 		goto nolfb;
 	}
+#endif
 
 	fb_fix_screeninfo fix;
 	if (ioctl(fbFd, FBIOGET_FSCREENINFO, &fix)<0)
@@ -62,8 +67,17 @@
 
 	available=fix.smem_len;
 	m_phys_mem = fix.smem_start;
+#if defined(__sh__)
+	eDebug("%dk total video mem", available/1024);
+	// The first 1920x1080x4 bytes are reserved
+	// After that we can take 1280x720x4 bytes for our virtual framebuffer
+	available -= 1920*1080*4;
+	eDebug("%dk usable video mem", available/1024);
+	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 1920*1080*4);
+#else
 	eDebug("%dk video mem", available/1024);
 	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 0);
+#endif
 	if (!lfb)
 	{
 		perror("mmap");
@@ -86,6 +100,7 @@
 
 int fbClass::showConsole(int state)
 {
+#if not defined(__sh__) 
 	int fd=open("/dev/tty0", O_RDWR);
 	if(fd>=0)
 	{
@@ -95,11 +110,19 @@
 		}
 		close(fd);
 	}
+#endif
 	return 0;
 }
 
 int fbClass::SetMode(int nxRes, int nyRes, int nbpp)
 {
+#if defined(__sh__)
+	xRes=nxRes;
+	yRes=nyRes;
+	bpp=32;
+	m_number_of_pages = 1;
+	topDiff=bottomDiff=leftDiff=rightDiff = 0;
+#else
 	screeninfo.xres_virtual=screeninfo.xres=nxRes;
 	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
 	screeninfo.height=0;
@@ -132,6 +155,7 @@
 		break;
 	}
 
+
 	if (ioctl(fbFd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
 	{
 		// try single buffering
@@ -146,11 +170,18 @@
 		eDebug(" - double buffering not available.");
 	} else
 		eDebug(" - double buffering available!");
+
 	
 	m_number_of_pages = screeninfo.yres_virtual / nyRes;
 	
+#endif
 	ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo);
 	
+#if defined(__sh__)
+	xResSc=screeninfo.xres;
+	yResSc=screeninfo.yres;
+	stride=xRes*4;
+#else
 	if ((screeninfo.xres!=nxRes) && (screeninfo.yres!=nyRes) && (screeninfo.bits_per_pixel!=nbpp))
 	{
 		eDebug("SetMode failed: wanted: %dx%dx%d, got %dx%dx%d",
@@ -168,15 +199,22 @@
 	}
 	stride=fix.line_length;
 	memset(lfb, 0, stride*yRes);
+#endif
 	blit();
 	return 0;
 }
 
 void fbClass::getMode(int &xres, int &yres, int &bpp)
 {
+#if defined(__sh__)
+	xres = xRes;
+	yres = yRes;
+	bpp = 32;
+#else
 	xres = screeninfo.xres;
 	yres = screeninfo.yres;
 	bpp = screeninfo.bits_per_pixel;
+#endif
 }
 
 int fbClass::setOffset(int off)
@@ -194,10 +232,93 @@
 
 void fbClass::blit()
 {
+#if defined(__sh__)
+	int modefd=open("/proc/stb/video/3d_mode", O_RDWR);
+	char buf[16] = "off";
+	if (modefd > 0)
+	{
+		read(modefd, buf, 15);
+		buf[15]='\0';
+		close(modefd);
+	}
+
+	STMFBIO_BLT_DATA    bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = 1920*1080*4;
+	bltData.srcPitch   = xRes * 4;
+	bltData.dstOffset  = 0;
+	bltData.dstPitch   = xResSc*4;
+	bltData.src_top    = 0;
+	bltData.src_left   = 0;
+	bltData.src_right  = xRes;
+	bltData.src_bottom = yRes;
+	bltData.srcFormat  = SURF_BGRA8888;
+	bltData.dstFormat  = SURF_BGRA8888;
+	bltData.srcMemBase = STMFBGP_FRAMEBUFFER;
+	bltData.dstMemBase = STMFBGP_FRAMEBUFFER;
+
+	if (strncmp(buf,"sbs",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff/2;
+		bltData.dst_right  = xResSc/2 + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = xResSc/2 + leftDiff/2;
+		bltData.dst_right  = xResSc + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else if (strncmp(buf,"tab",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc/2 + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = yResSc/2 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	
+	}
+
+	if (ioctl(fbFd, STMFBIO_SYNC_BLITTER) < 0)
+	{
+		perror("STMFBIO_SYNC_BLITTER");
+	}
+#else
 	if (m_manual_blit == 1) {
 		if (ioctl(fbFd, FBIO_BLIT) < 0)
 			perror("FBIO_BLIT");
 	}
+#endif
 }
 
 fbClass::~fbClass()
@@ -232,6 +353,26 @@
 	}
 	else
 		locked = 1;
+
+#if defined(__sh__)
+	outcfg.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_GET_OUTPUT_CONFIG\n");
+
+	outinfo.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_GET_OUTPUTINFO\n");
+
+	//if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+	//	printf("ERROR\n");
+
+	planemode.layerid = 0;
+	if (ioctl( fbFd, STMFBIO_GET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_GET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_GET_VAR_SCREENINFO_EX\n");
+#endif
 	return fbFd;
 }
 
@@ -242,25 +383,88 @@
 	if (locked == 2)  // re-enable manualBlit
 		enableManualBlit();
 	locked=0;
+
+#if defined(__sh__)
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_SET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_SET_OUTPUTINFO\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_SET_OUTPUT_CONFIG\n");
+
+	memset(lfb, 0, stride*yRes);
+#endif
+
 	SetMode(xRes, yRes, bpp);
 	PutCMAP();
 }
 
 void fbClass::enableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 1;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 1;
+#endif
 }
 
 void fbClass::disableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 0;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 0;
+#endif
+}
+
+#if defined(__sh__)
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+//	memset(lfb, 0x00, xRes * yRes * 4);
+	blit();
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if(ret == 0)
+		return topDiff;
+	else if(ret == 1)
+		return leftDiff;
+	else if(ret == 2)
+		return rightDiff;
+	else if(ret == 3)
+		return bottomDiff;
+	else
+		return -1;
 }
 
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
+#endif
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/fb.h enigma2-nightly.patched/lib/gdi/fb.h
--- enigma2-nightly.org/lib/gdi/fb.h	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/fb.h	2013-08-11 08:18:50.250295904 +0200
@@ -3,11 +3,26 @@
 
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
+#if defined(__sh__)
+	#include <linux/stmfb.h>
+#endif
 
 class fbClass
 {
 	int fbFd;
 	int xRes, yRes, stride, bpp;
+#if defined(__sh__)
+	struct stmfbio_output_configuration outcfg;
+	struct stmfbio_outputinfo outinfo;
+	struct stmfbio_planeinfo planemode;
+	struct stmfbio_var_screeninfo_ex infoex;
+
+	int xResSc, yResSc;
+	int topDiff, leftDiff, rightDiff, bottomDiff;
+#endif
+#ifdef ENABLE_LIBEPLAYER3
+//	unsigned char *lfb_direct;
+#endif
 	int available;
 	struct fb_var_screeninfo screeninfo;
 	fb_cmap cmap;
@@ -49,6 +64,19 @@
 	int PutCMAP();
 #endif
 	static fbClass *getInstance();
+#ifdef ENABLE_LIBEPLAYER3
+//---> "hack" for libeplayer3 fb access
+	int getFD() { return fbFd; }
+	unsigned char * getLFB_Direct() { return lfb; }
+	int getScreenResX() { return xRes; }
+	int getScreenResY() { return yRes; }
+//---<
+#endif
+#if defined(__sh__)
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 
 	int lock();
 	void unlock();
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/gfbdc.cpp enigma2-nightly.patched/lib/gdi/gfbdc.cpp
--- enigma2-nightly.org/lib/gdi/gfbdc.cpp	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/gfbdc.cpp	2013-08-11 08:28:13.822283188 +0200
@@ -177,14 +177,30 @@
 
 void gFBDC::setResolution(int xres, int yres, int bpp)
 {
+#if defined(__sh__)
+	/* if xres and yres are negative call SetMode with the lates xres and yres
+	 * we need that to read the new screen dimesnions after a resolution change
+	 * without changing the frambuffer dimensions
+	 */
+	if (xres<0 && yres<0 ) {
+		fb->SetMode(m_xres, m_yres, bpp);
+		return;
+	}
+#else
 	if (m_pixmap && (surface.x == xres) && (surface.y == yres) && (surface.bpp == bpp))
 		return;
+#endif
 
 	if (gAccel::getInstance())
 		gAccel::getInstance()->releaseAccelMemorySpace();
 
 	fb->SetMode(xres, yres, bpp);
 
+#if defined(__sh__)
+
+	for (int y = 0; y<m_yres; y++) // make whole screen transparent
+		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
+#endif
 	surface.x = xres;
 	surface.y = yres;
 	surface.bpp = bpp;
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/gfbdc.cpp~ enigma2-nightly.patched/lib/gdi/gfbdc.cpp~
--- enigma2-nightly.org/lib/gdi/gfbdc.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/gdi/gfbdc.cpp~	2013-08-11 08:11:19.154306132 +0200
@@ -0,0 +1,244 @@
+#include <lib/gdi/gfbdc.h>
+
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+
+#include <lib/gdi/accel.h>
+
+#include <time.h>
+
+gFBDC::gFBDC()
+{
+	fb=new fbClass;
+
+	if (!fb->Available())
+		eFatal("no framebuffer available");
+
+	int xres;
+	int yres;
+	int bpp;
+	fb->getMode(xres, yres, bpp);
+
+	/* we can only use one of these three modes: */
+	if (!((xres == 720 && yres == 576)
+		|| (xres == 1280 && yres == 720)
+		|| (xres == 1920 && yres == 1080)))
+	{
+		/* fallback to a decent default */
+		xres = 720;
+		yres = 576;
+	}
+
+	surface.clut.data = 0;
+	setResolution(xres, yres); // default res
+
+	reloadSettings();
+}
+
+gFBDC::~gFBDC()
+{
+	delete fb;
+	delete[] surface.clut.data;
+}
+
+void gFBDC::calcRamp()
+{
+#if 0
+	float fgamma=gamma ? gamma : 1;
+	fgamma/=10.0;
+	fgamma=1/log(fgamma);
+	for (int i=0; i<256; i++)
+	{
+		float raw=i/255.0; // IIH, float.
+		float corr=pow(raw, fgamma) * 256.0;
+
+		int d=corr * (float)(256-brightness) / 256 + brightness;
+		if (d < 0)
+			d=0;
+		if (d > 255)
+			d=255;
+		ramp[i]=d;
+
+		rampalpha[i]=i*alpha/256;
+	}
+#endif
+	for (int i=0; i<256; i++)
+	{
+		int d;
+		d=i;
+		d=(d-128)*(gamma+64)/(128+64)+128;
+		d+=brightness-128; // brightness correction
+		if (d<0)
+			d=0;
+		if (d>255)
+			d=255;
+		ramp[i]=d;
+
+		rampalpha[i]=i*alpha/256;
+	}
+
+	rampalpha[255]=255; // transparent BLEIBT bitte so.
+}
+
+void gFBDC::setPalette()
+{
+	if (!surface.clut.data)
+		return;
+
+	for (int i=0; i<256; ++i)
+	{
+		fb->CMAP()->red[i]=ramp[surface.clut.data[i].r]<<8;
+		fb->CMAP()->green[i]=ramp[surface.clut.data[i].g]<<8;
+		fb->CMAP()->blue[i]=ramp[surface.clut.data[i].b]<<8;
+		fb->CMAP()->transp[i]=rampalpha[surface.clut.data[i].a]<<8;
+	}
+	fb->PutCMAP();
+}
+
+void gFBDC::exec(const gOpcode *o)
+{
+	switch (o->opcode)
+	{
+	case gOpcode::setPalette:
+	{
+		gDC::exec(o);
+		setPalette();
+		break;
+	}
+	case gOpcode::flip:
+	{
+		if (surface_back.data_phys)
+		{
+			gUnmanagedSurface s(surface);
+			surface = surface_back;
+			surface_back = s;
+
+			if (surface.data_phys > surface_back.data_phys)
+				fb->setOffset(surface_back.y);
+			else
+				fb->setOffset(0);
+		}
+		break;
+	}
+	case gOpcode::waitVSync:
+	{
+		static timeval l;
+		static int t;
+		timeval now;
+
+		if (t == 1000)
+		{
+			gettimeofday(&now, 0);
+
+			int diff = (now.tv_sec - l.tv_sec) * 1000 + (now.tv_usec - l.tv_usec) / 1000;
+			eDebug("%d ms latency (%d fps)", diff, t * 1000 / (diff ? diff : 1));
+			l = now;
+			t = 0;
+		}
+
+		++t;
+
+		fb->blit();
+		fb->waitVSync();
+		break;
+	}
+	case gOpcode::flush:
+		fb->blit();
+		break;
+	default:
+		gDC::exec(o);
+		break;
+	}
+}
+
+void gFBDC::setAlpha(int a)
+{
+	alpha=a;
+
+	calcRamp();
+	setPalette();
+}
+
+void gFBDC::setBrightness(int b)
+{
+	brightness=b;
+
+	calcRamp();
+	setPalette();
+}
+
+void gFBDC::setGamma(int g)
+{
+	gamma=g;
+
+	calcRamp();
+	setPalette();
+}
+
+void gFBDC::setResolution(int xres, int yres, int bpp)
+{
+	if (m_pixmap && (surface.x == xres) && (surface.y == yres) && (surface.bpp == bpp))
+		return;
+
+	if (gAccel::getInstance())
+		gAccel::getInstance()->releaseAccelMemorySpace();
+
+	fb->SetMode(xres, yres, bpp);
+
+	surface.x = xres;
+	surface.y = yres;
+	surface.bpp = bpp;
+	surface.bypp = bpp / 8;
+	surface.stride = fb->Stride();
+	surface.data = fb->lfb;
+
+	surface.data_phys = fb->getPhysAddr();
+
+	int fb_size = surface.stride * surface.y;
+
+	if (fb->getNumPages() > 1)
+	{
+		surface_back = surface;
+		surface_back.data = fb->lfb + fb_size;
+		surface_back.data_phys = surface.data_phys + fb_size;
+		fb_size *= 2;
+	}
+	else
+	{
+		surface_back.data = 0;
+		surface_back.data_phys = 0;
+	}
+
+	eDebug("%dkB available for acceleration surfaces.", (fb->Available() - fb_size)/1024);
+	eDebug("resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, fb->Stride());
+
+	if (gAccel::getInstance())
+		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size);
+
+	if (!surface.clut.data)
+	{
+		surface.clut.colors = 256;
+		surface.clut.data = new gRGB[surface.clut.colors];
+		memset(surface.clut.data, 0, sizeof(*surface.clut.data)*surface.clut.colors);
+	}
+
+	surface_back.clut = surface.clut;
+
+	m_pixmap = new gPixmap(&surface);
+}
+
+void gFBDC::saveSettings()
+{
+}
+
+void gFBDC::reloadSettings()
+{
+	alpha=255;
+	gamma=128;
+	brightness=128;
+
+	calcRamp();
+	setPalette();
+}
+
+eAutoInitPtr<gFBDC> init_gFBDC(eAutoInitNumbers::graphic-1, "GFBDC");
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/glcddc.cpp enigma2-nightly.patched/lib/gdi/glcddc.cpp
--- enigma2-nightly.org/lib/gdi/glcddc.cpp	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/glcddc.cpp	2013-08-11 08:18:50.250295904 +0200
@@ -5,6 +5,21 @@
 
 gLCDDC *gLCDDC::instance;
 
+#ifdef HAVE_GRAPHLCD
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 gLCDDC::gLCDDC()
 {
 	lcd = new eDBoxLCD();
@@ -23,11 +38,18 @@
 	eDebug("LCD resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, surface.stride);
 
 	m_pixmap = new gPixmap(&surface);
+#ifdef HAVE_GRAPHLCD
+	clock_gettime(CLOCK_MONOTONIC, &last_update);
+#endif
 }
 
 gLCDDC::~gLCDDC()
 {
+#ifndef HAVE_GRAPHLCD
+//konfetti: not sure why, but calling the destructor if external lcd (pearl) is selected
+//e2 crashes. this is also true if the destructor does not contain any code !!!
 	delete lcd;
+#endif
 	instance = 0;
 }
 
@@ -46,8 +68,16 @@
 		break;
 #endif
 	case gOpcode::flush:
+#ifdef HAVE_GRAPHLCD
+		if (update)
+		{
+			lcd->update();
+			clock_gettime(CLOCK_MONOTONIC, &last_update);
+		}
+#else
 //		if (update)
 			lcd->update();
+#endif
 	default:
 		gDC::exec(o);
 		break;
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/glcddc.h enigma2-nightly.patched/lib/gdi/glcddc.h
--- enigma2-nightly.org/lib/gdi/glcddc.h	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/glcddc.h	2013-08-11 08:30:12.338280507 +0200
@@ -11,6 +11,9 @@
 	int update;
 	void exec(const gOpcode *opcode);
 	gUnmanagedSurface surface;
+#ifdef HAVE_GRAPHLCD
+	struct timespec last_update;
+#endif
 public:
 	gLCDDC();
 	~gLCDDC();
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/glcddc.h~ enigma2-nightly.patched/lib/gdi/glcddc.h~
--- enigma2-nightly.org/lib/gdi/glcddc.h~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/gdi/glcddc.h~	2013-08-11 08:11:19.154306132 +0200
@@ -0,0 +1,22 @@
+#ifndef __glcddc_h
+#define __glcddc_h
+
+#include "grc.h"
+#include <lib/gdi/lcd.h>
+
+class gLCDDC: public gDC
+{
+	eLCD *lcd;
+	static gLCDDC *instance;
+	int update;
+	void exec(const gOpcode *opcode);
+	gUnmanagedSurface surface;
+public:
+	gLCDDC();
+	~gLCDDC();
+	void setUpdate(int update);
+	static int getInstance(ePtr<gLCDDC> &ptr) { if (!instance) return -1; ptr = instance; return 0; }
+	int islocked() { return lcd->islocked(); }
+};
+
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/gpixmap.cpp enigma2-nightly.patched/lib/gdi/gpixmap.cpp
--- enigma2-nightly.org/lib/gdi/gpixmap.cpp	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/gpixmap.cpp	2013-08-11 08:45:26.158259845 +0200
@@ -202,6 +202,9 @@
 			else
 				col = 0x10101 * color;
 			
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 			
 			if (surface->data_phys)
@@ -234,6 +237,9 @@
 			__u32 col;
 
 			col = color.argb();
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 #ifdef GPIXMAP_DEBUG
@@ -698,6 +704,9 @@
 #else
 				pal[i] = ((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19;
 #endif
+#if defined(__sh__)
+if ((pal[i]&0xFF000000) >= 0xE0000000) pal[i] = 0xFF000000;
+#endif
 				pal[i]^=0xFF000000;
 			}
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/gpixmap.cpp~ enigma2-nightly.patched/lib/gdi/gpixmap.cpp~
--- enigma2-nightly.org/lib/gdi/gpixmap.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/gdi/gpixmap.cpp~	2013-08-11 08:18:50.250295904 +0200
@@ -0,0 +1,1035 @@
+#include <cstdlib>
+#include <cstring>
+#include <lib/gdi/gpixmap.h>
+#include <lib/gdi/region.h>
+#include <lib/gdi/accel.h>
+#include <byteswap.h>
+
+#ifndef BYTE_ORDER
+#error "no BYTE_ORDER defined!"
+#endif
+
+// #define GPIXMAP_DEBUG
+
+#ifdef GPIXMAP_DEBUG
+#	include "../base/benchmark.h"
+#endif
+
+gLookup::gLookup()
+	:size(0), lookup(0)
+{
+}
+
+gLookup::gLookup(int size, const gPalette &pal, const gRGB &start, const gRGB &end)
+	:size(0), lookup(0)
+{
+	build(size, pal, start, end);
+}
+
+void gLookup::build(int _size, const gPalette &pal, const gRGB &start, const gRGB &end)
+{
+	if (lookup)
+	{
+		delete [] lookup;
+		lookup=0;
+		size=0;
+	}
+	size=_size;
+	if (!size)
+		return;
+	lookup=new gColor[size];
+	
+	lookup[0] = pal.findColor(start);
+	
+	const int rsize = end.r - start.r;
+	const int gsize = end.g - start.g;
+	const int bsize = end.b - start.b;
+	const int asize = end.a - start.a;
+	const int size_1 = size - 1;
+
+	for (int i=1; i<size; i++)
+	{
+		gRGB col;
+		int rdiff = (rsize * i) / size_1;
+		int gdiff = (gsize * i) / size_1;
+		int bdiff = (bsize * i) / size_1;
+		int adiff = (asize * i) / size_1;
+		col.r = start.r + rdiff;
+		col.g = start.g + gdiff;
+		col.b = start.b + bdiff;
+		col.a = start.a + adiff;
+		lookup[i] = pal.findColor(col);
+	}
+}
+
+gUnmanagedSurface::gUnmanagedSurface():
+	x(0), y(0), bpp(0), bypp(0), stride(0),
+	data(0),
+	data_phys(0)
+{
+}
+
+gUnmanagedSurface::gUnmanagedSurface(int width, int height, int _bpp):
+	x(width),
+	y(height),
+	bpp(_bpp),
+	data(0),
+	data_phys(0)
+{
+	switch (_bpp)
+	{
+	case 8:
+		bypp = 1;
+		break;
+	case 15:
+	case 16:
+		bypp = 2;
+		break;
+	case 24:		// never use 24bit mode
+	case 32:
+		bypp = 4;
+		break;
+	default:
+		bypp = (bpp+7)/8;
+	}
+	stride = x*bypp;
+}
+
+#ifdef GPIXMAP_DEBUG
+unsigned int pixmap_total_size = 0;
+unsigned int pixmap_total_count = 0;
+static void added_pixmap(int size)
+{
+	++pixmap_total_count;
+	pixmap_total_size += size;
+	eDebug("[gSurface] Added %dk, total %u pixmaps, %uk", size>>10, pixmap_total_count, pixmap_total_size>>10);
+}
+static void removed_pixmap(int size)
+{
+	--pixmap_total_count;
+	pixmap_total_size -= size;
+	eDebug("[gSurface] Removed %dk, total %u pixmaps, %uk", size>>10, pixmap_total_count, pixmap_total_size>>10);
+}
+#else
+static inline void added_pixmap(int size) {}
+static inline void removed_pixmap(int size) {}
+#endif
+
+static bool is_a_candidate_for_accel(const gUnmanagedSurface* surface)
+{
+	if (surface->stride < 48)
+		return false;
+	switch (surface->bpp)
+	{
+		case 8:
+			return (surface->y * surface->stride) > 12000;
+		case 32:
+			return (surface->y * surface->stride) > 48000;
+		default:
+			return false;
+	}
+}
+
+gSurface::gSurface(int width, int height, int _bpp, int accel):
+	gUnmanagedSurface(width, height, _bpp)
+{
+	if ((accel > gPixmap::accelAuto) ||
+		((accel == gPixmap::accelAuto) && (is_a_candidate_for_accel(this))))
+	{
+		if (gAccel::getInstance()->accelAlloc(this) != 0)
+				eDebug("ERROR: accelAlloc failed");
+	}
+	if (!data)
+	{
+		data = new unsigned char [y * stride];
+		added_pixmap(y * stride);
+	}
+}
+
+gSurface::~gSurface()
+{
+	gAccel::getInstance()->accelFree(this);
+	if (data)
+	{
+		delete [] (unsigned char*)data;
+		removed_pixmap(y * stride);
+	}
+	if (clut.data)
+	{
+		delete [] clut.data;
+	}
+}
+
+void gPixmap::fill(const gRegion &region, const gColor &color)
+{
+	unsigned int i;
+	for (i=0; i<region.rects.size(); ++i)
+	{
+		const eRect &area = region.rects[i];
+		if (area.empty())
+			continue;
+
+		if (surface->bpp == 8)
+		{
+			for (int y=area.top(); y<area.bottom(); y++)
+		 		memset(((__u8*)surface->data)+y*surface->stride+area.left(), color.color, area.width());
+		} else if (surface->bpp == 16)
+		{
+			__u32 icol;
+
+			if (surface->clut.data && color < surface->clut.colors)
+				icol=surface->clut.data[color].argb();
+			else
+				icol=0x10101*color;
+#if BYTE_ORDER == LITTLE_ENDIAN
+			__u16 col = bswap_16(((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19);
+#else
+			__u16 col = ((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19;
+#endif
+			for (int y=area.top(); y<area.bottom(); y++)
+			{
+				__u16 *dst=(__u16*)(((__u8*)surface->data)+y*surface->stride+area.left()*surface->bypp);
+				int x=area.width();
+				while (x--)
+					*dst++=col;
+			}
+		} else if (surface->bpp == 32)
+		{
+			__u32 col;
+
+			if (surface->clut.data && color < surface->clut.colors)
+				col = surface->clut.data[color].argb();
+			else
+				col = 0x10101 * color;
+			
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
+			col^=0xFF000000;
+			
+			if (surface->data_phys)
+				if (!gAccel::getInstance()->fill(surface,  area, col))
+					continue;
+
+			for (int y=area.top(); y<area.bottom(); y++)
+			{
+				__u32 *dst=(__u32*)(((__u8*)surface->data)+y*surface->stride+area.left()*surface->bypp);
+				int x=area.width();
+				while (x--)
+					*dst++=col;
+			}
+		}	else
+			eWarning("couldn't fill %d bpp", surface->bpp);
+	}
+}
+
+void gPixmap::fill(const gRegion &region, const gRGB &color)
+{
+	unsigned int i;
+	for (i=0; i<region.rects.size(); ++i)
+	{
+		const eRect &area = region.rects[i];
+		if (area.empty())
+			continue;
+
+		if (surface->bpp == 32)
+		{
+			__u32 col;
+
+			col = color.argb();
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
+			col^=0xFF000000;
+
+#ifdef GPIXMAP_DEBUG
+			Stopwatch s;
+#endif
+			if (surface->data_phys && (area.surface() > 20000))
+				if (!gAccel::getInstance()->fill(surface,  area, col)) {
+#ifdef GPIXMAP_DEBUG
+					s.stop();
+					eDebug("[BLITBENCH] accel fill %dx%d took %u us", area.width(), area.height(), s.elapsed_us());
+#endif
+					continue;
+				}
+
+			for (int y=area.top(); y<area.bottom(); y++)
+			{
+				__u32 *dst=(__u32*)(((__u8*)surface->data)+y*surface->stride+area.left()*surface->bypp);
+				int x=area.width();
+				while (x--)
+					*dst++=col;
+			}
+#ifdef GPIXMAP_DEBUG
+			s.stop();
+			eDebug("[BLITBENCH] cpu fill %dx%d took %u us", area.width(), area.height(), s.elapsed_us());
+#endif
+		} else if (surface->bpp == 16)
+		{
+			__u32 icol = color.argb();
+#if BYTE_ORDER == LITTLE_ENDIAN
+			__u16 col = bswap_16(((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19);
+#else
+			__u16 col = ((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19;
+#endif
+			for (int y=area.top(); y<area.bottom(); y++)
+			{
+				__u16 *dst=(__u16*)(((__u8*)surface->data)+y*surface->stride+area.left()*surface->bypp);
+				int x=area.width();
+				while (x--)
+					*dst++=col;
+			}
+		}	else
+			eWarning("couldn't rgbfill %d bpp", surface->bpp);
+	}
+}
+
+static inline void blit_8i_to_32(__u32 *dst, const __u8 *src, const __u32 *pal, int width)
+{
+	while (width--)
+		*dst++=pal[*src++];
+}
+
+static inline void blit_8i_to_32_at(__u32 *dst, const __u8 *src, const __u32 *pal, int width)
+{
+	while (width--)
+	{
+		if (!(pal[*src]&0x80000000))
+		{
+			src++;
+			dst++;
+		} else
+			*dst++=pal[*src++];
+	}
+}
+
+static inline void blit_8i_to_16(__u16 *dst, const __u8 *src, const __u32 *pal, int width)
+{
+	while (width--)
+		*dst++=pal[*src++] & 0xFFFF;
+}
+
+static inline void blit_8i_to_16_at(__u16 *dst, const __u8 *src, const __u32 *pal, int width)
+{
+	while (width--)
+	{
+		if (!(pal[*src]&0x80000000))
+		{
+			src++;
+			dst++;
+		} else
+			*dst++=pal[*src++] & 0xFFFF;
+	}
+}
+
+static void blit_8i_to_32_ab(gRGB *dst, const __u8 *src, const gRGB *pal, int width)
+{
+	while (width--)
+	{
+		dst->alpha_blend(pal[*src++]);
+		++dst;
+	}
+}
+
+static void convert_palette(__u32* pal, const gPalette& clut)
+{
+	int i = 0;
+	if (clut.data)
+	{
+		while (i < clut.colors)
+		{
+			pal[i] = clut.data[i].argb() ^ 0xFF000000;
+			++i;
+		}
+	}
+	for(; i != 256; ++i)
+	{
+		pal[i] = (0x010101*i) | 0xFF000000;
+	}
+}
+
+#define FIX 0x10000
+
+void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, int flag)
+{
+	bool accel = (surface->data_phys && src.surface->data_phys);
+//	eDebug("blit: -> %d,%d+%d,%d -> %d,%d+%d,%d, flags=0x%x, accel=%d",
+//		_pos.x(), _pos.y(), _pos.width(), _pos.height(),
+//		clip.extends.x(), clip.extends.y(), clip.extends.width(), clip.extends.height(),
+//		flag, accel);
+	eRect pos = _pos;
+	
+//	eDebug("source size: %d %d", src.size().width(), src.size().height());
+	
+	if (!(flag & blitScale)) /* pos' size is valid only when scaling */
+		pos = eRect(pos.topLeft(), src.size());
+	else if (pos.size() == src.size()) /* no scaling required */
+		flag &= ~blitScale;
+
+	int scale_x = FIX, scale_y = FIX;
+	
+	if (flag & blitScale)
+	{
+		ASSERT(src.size().width());
+		ASSERT(src.size().height());
+		scale_x = pos.size().width() * FIX / src.size().width();
+		scale_y = pos.size().height() * FIX / src.size().height();
+		if (flag & blitKeepAspectRatio)
+		{
+			if (scale_x > scale_y)
+			{
+				pos = eRect(ePoint(pos.x() + (scale_x - scale_y) * pos.width() / (2 * FIX), pos.y()),
+					eSize(src.size().width() * pos.height() / src.size().height(), pos.height()));
+				scale_x = scale_y;
+
+			}
+			else
+			{
+				pos = eRect(ePoint(pos.x(), pos.y()  + (scale_y - scale_x) * pos.height() / (2 * FIX)),
+					eSize(pos.width(), src.size().height() * pos.width() / src.size().width()));
+				scale_y = scale_x;
+			}
+		}
+	}
+	
+//	eDebug("SCALE %x %x", scale_x, scale_y);
+
+	for (unsigned int i=0; i<clip.rects.size(); ++i)
+	{
+//		eDebug("clip rect: %d %d %d %d", clip.rects[i].x(), clip.rects[i].y(), clip.rects[i].width(), clip.rects[i].height());
+		eRect area = pos; /* pos is the virtual (pre-clipping) area on the dest, which can be larger/smaller than src if scaling is enabled */
+		area&=clip.rects[i];
+		area&=eRect(ePoint(0, 0), size());
+
+		if (area.empty())
+			continue;
+
+		eRect srcarea = area;
+		srcarea.moveBy(-pos.x(), -pos.y());
+
+//		eDebug("srcarea before scale: %d %d %d %d",
+//			srcarea.x(), srcarea.y(), srcarea.width(), srcarea.height());
+		
+		if (flag & blitScale)
+			srcarea = eRect(srcarea.x() * FIX / scale_x, srcarea.y() * FIX / scale_y, srcarea.width() * FIX / scale_x, srcarea.height() * FIX / scale_y);
+
+//		eDebug("srcarea after scale: %d %d %d %d",
+//			srcarea.x(), srcarea.y(), srcarea.width(), srcarea.height());
+
+		if (accel)
+		{
+			/* we have hardware acceleration for this blit operation */
+			if (flag & (blitAlphaTest | blitAlphaBlend))
+			{
+				/* alpha blending is requested */
+				if (gAccel::getInstance()->hasAlphaBlendingSupport())
+				{
+					/* Hardware alpha blending is broken on the few
+					 * boxes that support it, so only use it
+					 * when scaling */
+					if (flag & blitScale)
+						accel = true;
+					else if (flag & blitAlphaTest) /* Alpha test only on 8-bit */
+						accel = (src.surface->bpp == 8);
+					else
+						accel = false;
+				}
+				else
+				{
+					/* our hardware does not support alphablending */
+					accel = false;
+				}
+			}
+		}
+
+#ifdef GPIXMAP_DEBUG
+		Stopwatch s;
+#endif
+		if (accel) {
+			if (!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag)) {
+#ifdef GPIXMAP_DEBUG
+				s.stop();
+				eDebug("[BLITBENCH] accel blit took %u us", s.elapsed_us());
+#endif
+				continue;
+			}
+		}
+
+		if (flag & blitScale)
+		{
+			if ((surface->bpp == 32) && (src.surface->bpp==8))
+			{	
+				const __u8 *srcptr = (__u8*)src.surface->data;
+				__u8 *dstptr=(__u8*)surface->data; // !!
+				__u32 pal[256];
+				convert_palette(pal, src.surface->clut);
+
+				const int src_stride = src.surface->stride;
+				srcptr += srcarea.left()*src.surface->bypp + srcarea.top()*src_stride;
+				dstptr += area.left()*surface->bypp + area.top()*surface->stride;
+				const int width = area.width();
+				const int height = area.height();
+				const int src_height = srcarea.height();
+				const int src_width = srcarea.width();
+				if (flag & blitAlphaTest)
+				{
+					for (int y = 0; y < height; ++y)
+					{
+						const __u8 *src_row_ptr = srcptr + (((y * src_height) / height) * src_stride);
+						__u32 *dst = (__u32*)dstptr;
+						for (int x = 0; x < width; ++x)
+						{
+							__u32 pixel = pal[src_row_ptr[(x *src_width) / width]];
+							if (pixel & 0x80000000)
+								*dst = pixel;
+							++dst;
+						}
+						dstptr += surface->stride;
+					}
+				}
+				else if (flag & blitAlphaBlend)
+				{
+					for (int y = 0; y < height; ++y)
+					{
+						const __u8 *src_row_ptr = srcptr + (((y * src_height) / height) * src_stride);
+						gRGB *dst = (gRGB*)dstptr;
+						for (int x = 0; x < width; ++x)
+						{
+							dst->alpha_blend(pal[src_row_ptr[(x * src_width) / width]]);
+							++dst;
+						}
+						dstptr += surface->stride;
+					}
+				}
+				else
+				{
+					for (int y = 0; y < height; ++y)
+					{
+						const __u8 *src_row_ptr = srcptr + (((y * src_height) / height) * src_stride);
+						__u32 *dst = (__u32*)dstptr;
+						for (int x = 0; x < width; ++x)
+						{
+							*dst = pal[src_row_ptr[(x * src_width) / width]];
+							++dst;
+						}
+						dstptr += surface->stride;
+					}
+				}
+			}
+			else if ((surface->bpp == 32) && (src.surface->bpp == 32))
+			{
+				const int src_stride = src.surface->stride;
+				const __u8* srcptr = (const __u8*)src.surface->data + srcarea.left()*src.surface->bypp + srcarea.top()*src_stride;
+				__u8* dstptr = (__u8*)surface->data + area.left()*surface->bypp + area.top()*surface->stride;
+				const int width = area.width();
+				const int height = area.height();
+				const int src_height = srcarea.height();
+				const int src_width = srcarea.width();
+				if (flag & blitAlphaTest)
+				{
+					for (int y = 0; y < height; ++y)
+					{
+						const __u32 *src_row_ptr = (__u32*)(srcptr + (((y * src_height) / height) * src_stride));
+						__u32 *dst = (__u32*)dstptr;
+						for (int x = 0; x < width; ++x)
+						{
+							__u32 pixel = src_row_ptr[(x *src_width) / width];
+							if (pixel & 0x80000000)
+								*dst = pixel;
+							++dst;
+						}
+						dstptr += surface->stride;
+					}
+				}
+				else if (flag & blitAlphaBlend)
+				{
+					for (int y = 0; y < height; ++y)
+					{
+						const gRGB *src_row_ptr = (gRGB *)(srcptr + (((y * src_height) / height) * src_stride));
+						gRGB *dst = (gRGB*)dstptr;
+						for (int x = 0; x < width; ++x)
+						{
+							dst->alpha_blend(src_row_ptr[(x * src_width) / width]);
+							++dst;
+						}
+						dstptr += surface->stride;
+					}
+				}
+				else
+				{
+					for (int y = 0; y < height; ++y)
+					{
+						const __u32 *src_row_ptr = (__u32*)(srcptr + (((y * src_height) / height) * src_stride));
+						__u32 *dst = (__u32*)dstptr;
+						for (int x = 0; x < width; ++x)
+						{
+							*dst = src_row_ptr[(x * src_width) / width];
+							++dst;
+						}
+						dstptr += surface->stride;
+					}
+				}
+			}
+			else
+			{
+				eWarning("unimplemented: scale on non-accel surface %d->%d bpp", src.surface->bpp, surface->bpp);
+			}
+#ifdef GPIXMAP_DEBUG
+			s.stop();
+			eDebug("[BLITBENCH] CPU scale blit took %u us", s.elapsed_us());
+#endif
+			continue;
+		}
+
+		if ((surface->bpp == 8) && (src.surface->bpp == 8))
+		{
+			__u8 *srcptr=(__u8*)src.surface->data;
+			__u8 *dstptr=(__u8*)surface->data;
+
+			srcptr+=srcarea.left()*src.surface->bypp+srcarea.top()*src.surface->stride;
+			dstptr+=area.left()*surface->bypp+area.top()*surface->stride;
+			if (flag & (blitAlphaTest|blitAlphaBlend))
+			{
+				for (int y = area.height(); y != 0; --y)
+				{
+					// no real alphatest yet
+					int width=area.width();
+					unsigned char *s = (unsigned char*)srcptr;
+					unsigned char *d = (unsigned char*)dstptr;
+					// use duff's device here!
+					while (width--)
+					{
+						if (!*s)
+						{
+							s++;
+							d++;
+						} 
+						else
+						{
+							*d++ = *s++;
+						}
+					}
+					srcptr += src.surface->stride;
+					dstptr += surface->stride;
+				}
+			}
+			else
+			{
+				int linesize = area.width()*surface->bypp;
+				for (int y = area.height(); y != 0; --y)
+				{
+					memcpy(dstptr, srcptr, linesize);
+					srcptr += src.surface->stride;
+					dstptr += surface->stride;
+				}
+			}
+		}
+		else if ((surface->bpp == 32) && (src.surface->bpp==32))
+		{
+			__u32 *srcptr=(__u32*)src.surface->data;
+			__u32 *dstptr=(__u32*)surface->data;
+
+			srcptr+=srcarea.left()+srcarea.top()*src.surface->stride/4;
+			dstptr+=area.left()+area.top()*surface->stride/4;
+			for (int y = area.height(); y != 0; --y)
+			{
+				if (flag & blitAlphaTest)
+				{
+					int width=area.width();
+					unsigned long *src=(unsigned long*)srcptr;
+					unsigned long *dst=(unsigned long*)dstptr;
+					while (width--)
+					{
+						if (!((*src)&0xFF000000))
+						{
+							src++;
+							dst++;
+						} else
+							*dst++=*src++;
+					}
+				} else if (flag & blitAlphaBlend)
+				{
+					int width = area.width();
+					gRGB *src = (gRGB*)srcptr;
+					gRGB *dst = (gRGB*)dstptr;
+					while (width--)
+					{
+						dst->alpha_blend(*src++);
+						++dst;
+					}
+				} else
+					memcpy(dstptr, srcptr, area.width()*surface->bypp);
+				srcptr = (__u32*)((__u8*)srcptr + src.surface->stride);
+				dstptr = (__u32*)((__u8*)dstptr + surface->stride);
+			}
+		}
+		else if ((surface->bpp == 32) && (src.surface->bpp==8))
+		{	
+			const __u8 *srcptr = (__u8*)src.surface->data;
+			__u8 *dstptr=(__u8*)surface->data; // !!
+			__u32 pal[256];
+			convert_palette(pal, src.surface->clut);
+
+			srcptr+=srcarea.left()*src.surface->bypp+srcarea.top()*src.surface->stride;
+			dstptr+=area.left()*surface->bypp+area.top()*surface->stride;
+			const int width=area.width();
+			for (int y = area.height(); y != 0; --y)
+			{
+				if (flag & blitAlphaTest)
+					blit_8i_to_32_at((__u32*)dstptr, srcptr, pal, width);
+				else if (flag & blitAlphaBlend)
+					blit_8i_to_32_ab((gRGB*)dstptr, srcptr, (const gRGB*)pal, width);
+				else
+					blit_8i_to_32((__u32*)dstptr, srcptr, pal, width);
+				srcptr += src.surface->stride;
+				dstptr += surface->stride;
+			}
+		}
+		else if ((surface->bpp == 16) && (src.surface->bpp==8))
+		{
+			__u8 *srcptr=(__u8*)src.surface->data;
+			__u8 *dstptr=(__u8*)surface->data; // !!
+			__u32 pal[256];
+
+			for (int i=0; i != 256; ++i)
+			{
+				__u32 icol;
+				if (src.surface->clut.data && (i<src.surface->clut.colors))
+					icol = src.surface->clut.data[i].argb();
+				else
+					icol=0x010101*i;
+#if BYTE_ORDER == LITTLE_ENDIAN
+				pal[i] = bswap_16(((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19);
+#else
+				pal[i] = ((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19;
+#endif
+				pal[i]^=0xFF000000;
+			}
+
+			srcptr+=srcarea.left()*src.surface->bypp+srcarea.top()*src.surface->stride;
+			dstptr+=area.left()*surface->bypp+area.top()*surface->stride;
+
+			if (flag & blitAlphaBlend)
+				eWarning("ignore unsupported 8bpp -> 16bpp alphablend!");
+
+			for (int y=0; y<area.height(); y++)
+			{
+				int width=area.width();
+				unsigned char *psrc=(unsigned char*)srcptr;
+				__u16 *dst=(__u16*)dstptr;
+				if (flag & blitAlphaTest)
+					blit_8i_to_16_at(dst, psrc, pal, width);
+				else
+					blit_8i_to_16(dst, psrc, pal, width);
+				srcptr+=src.surface->stride;
+				dstptr+=surface->stride;
+			}
+		}
+		else if ((surface->bpp == 16) && (src.surface->bpp==32))
+		{
+			__u8 *srcptr=(__u8*)src.surface->data;
+			__u8 *dstptr=(__u8*)surface->data;
+
+			srcptr+=srcarea.left()+srcarea.top()*src.surface->stride;
+			dstptr+=area.left()+area.top()*surface->stride;
+
+			if (flag & blitAlphaBlend)
+				eWarning("ignore unsupported 32bpp -> 16bpp alphablend!");
+
+			for (int y=0; y<area.height(); y++)
+			{
+				int width=area.width();
+				__u32 *srcp=(__u32*)srcptr;
+				__u16 *dstp=(__u16*)dstptr;
+
+				if (flag & blitAlphaTest)
+				{
+					while (width--)
+					{
+						if (!((*srcp)&0xFF000000))
+						{
+							srcp++;
+							dstp++;
+						} else
+						{
+							__u32 icol = *srcp++;
+#if BYTE_ORDER == LITTLE_ENDIAN
+							*dstp++ = bswap_16(((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19);
+#else
+							*dstp++ = ((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19;
+#endif
+						}
+					}
+				} else
+				{
+					while (width--)
+					{
+						__u32 icol = *srcp++;
+#if BYTE_ORDER == LITTLE_ENDIAN
+						*dstp++ = bswap_16(((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19);
+#else
+						*dstp++ = ((icol & 0xFF) >> 3) << 11 | ((icol & 0xFF00) >> 10) << 5 | (icol & 0xFF0000) >> 19;
+#endif
+					}
+				}
+				srcptr+=src.surface->stride;
+				dstptr+=surface->stride;
+			}
+		}
+		else
+			eWarning("cannot blit %dbpp from %dbpp", surface->bpp, src.surface->bpp);
+#ifdef GPIXMAP_DEBUG
+		s.stop();
+		eDebug("[BLITBENCH] cpu blit took %u us", s.elapsed_us());
+#endif
+	}
+}
+
+#undef FIX
+
+void gPixmap::mergePalette(const gPixmap &target)
+{
+	if ((!surface->clut.colors) || (!target.surface->clut.colors))
+		return;
+
+	gColor *lookup=new gColor[surface->clut.colors];
+
+	for (int i=0; i<surface->clut.colors; i++)
+		lookup[i].color=target.surface->clut.findColor(surface->clut.data[i]);
+	
+	delete [] surface->clut.data;
+	surface->clut.colors=target.surface->clut.colors;
+	surface->clut.data=new gRGB[surface->clut.colors];
+	memcpy(surface->clut.data, target.surface->clut.data, sizeof(gRGB)*surface->clut.colors);
+
+	__u8 *dstptr=(__u8*)surface->data;
+
+	for (int ay=0; ay<surface->y; ay++)
+	{
+		for (int ax=0; ax<surface->x; ax++)
+			dstptr[ax]=lookup[dstptr[ax]];
+		dstptr+=surface->stride;
+	}
+	
+	delete [] lookup;
+}
+
+static inline int sgn(int a)
+{
+	if (a < 0)
+		return -1;
+	else if (!a)
+		return 0;
+	else
+		return 1;
+}
+
+void gPixmap::line(const gRegion &clip, ePoint start, ePoint dst, gColor color)
+{
+	__u32 col = color;
+	if (surface->bpp != 8)
+	{
+		if (surface->clut.data && color < surface->clut.colors)
+			col = surface->clut.data[color].argb();
+		else
+			col = 0x10101*color;
+		col^=0xFF000000;
+	}
+
+	if (surface->bpp == 16)
+	{
+#if BYTE_ORDER == LITTLE_ENDIAN
+		col = bswap_16(((col & 0xFF) >> 3) << 11 | ((col & 0xFF00) >> 10) << 5 | (col & 0xFF0000) >> 19);
+#else
+		col = ((col & 0xFF) >> 3) << 11 | ((col & 0xFF00) >> 10) << 5 | (col & 0xFF0000) >> 19;
+#endif
+	}
+	line(clip, start, dst, col);
+}
+
+void gPixmap::line(const gRegion &clip, ePoint start, ePoint dst, gRGB color)
+{
+	__u32 col;
+	col = color.argb();
+	col^=0xFF000000;
+	line(clip, start, dst, col);
+}
+
+void gPixmap::line(const gRegion &clip, ePoint start, ePoint dst, unsigned int color)
+{
+	if (clip.rects.empty())
+		return;
+
+	__u8 *srf8 = 0;
+	__u16 *srf16 = 0;
+	__u32 *srf32 = 0;
+	int stride = surface->stride;
+
+	switch (surface->bpp)
+	{
+		case 8:
+			srf8 = (__u8*)surface->data;
+			break;
+		case 16:
+			srf16 = (__u16*)surface->data;
+			stride /= 2;
+			break;
+		case 32:
+			srf32 = (__u32*)surface->data;
+			stride /= 4;
+			break;
+	}
+	
+	int xa = start.x(), ya = start.y(), xb = dst.x(), yb = dst.y();
+	int dx, dy, x, y, s1, s2, e, temp, swap, i;
+	dy=abs(yb-ya);
+	dx=abs(xb-xa);
+	s1=sgn(xb-xa);
+	s2=sgn(yb-ya);
+	x=xa;
+	y=ya;
+	if (dy>dx)
+	{
+		temp=dx;
+		dx=dy;
+		dy=temp;
+		swap=1;
+	} else
+		swap=0;
+	e = 2*dy-dx;
+
+	int lasthit = 0;
+	for(i=1; i<=dx; i++)
+	{
+				/* i don't like this clipping loop, but the only */
+				/* other choice i see is to calculate the intersections */
+				/* before iterating through the pixels. */
+				
+				/* one could optimize this because of the ordering */
+				/* of the bands. */
+				
+		lasthit = 0;
+		int a = lasthit;
+		
+			/* if last pixel was invisble, first check bounding box */
+		if (a == -1)
+		{
+				/* check if we just got into the bbox again */
+			if (clip.extends.contains(x, y))
+				lasthit = a = 0;
+			else
+				goto fail;
+		} else if (!clip.rects[a].contains(x, y))
+		{
+			do
+			{
+				++a;
+				if ((unsigned int)a == clip.rects.size())
+					a = 0;
+				if (a == lasthit)
+				{
+					goto fail;
+					lasthit = -1;
+				}
+			} while (!clip.rects[a].contains(x, y));
+			lasthit = a;
+		}
+
+		if (srf8)
+			srf8[y * stride + x] = color;
+		else if (srf16)
+			srf16[y * stride + x] = color;
+		else
+			srf32[y * stride + x] = color;
+fail:
+		while (e>=0)
+		{
+			if (swap==1)
+				x+=s1;
+			else
+				y+=s2;
+			e-=2*dx;
+		}
+
+		if (swap==1)
+			y+=s2;
+		else
+			x+=s1;
+		e+=2*dy;
+	}
+}
+
+gColor gPalette::findColor(const gRGB rgb) const
+{
+		/* grayscale? */
+	if (!data)
+		return (rgb.r + rgb.g + rgb.b) / 3;
+	
+	if (rgb.a == 255) /* Fully transparent, then RGB does not matter */
+	{
+		for (int t=0; t<colors; t++)
+			if (data[t].a == 255)
+				return t;
+	}
+	
+	int difference=1<<30, best_choice=0;
+	for (int t=0; t<colors; t++)
+	{
+		int ttd;
+		int td=(signed)(rgb.r-data[t].r); td*=td; td*=(255-data[t].a);
+		ttd=td;
+		if (ttd>=difference)
+			continue;
+		td=(signed)(rgb.g-data[t].g); td*=td; td*=(255-data[t].a);
+		ttd+=td;
+		if (ttd>=difference)
+			continue;
+		td=(signed)(rgb.b-data[t].b); td*=td; td*=(255-data[t].a);
+		ttd+=td;
+		if (ttd>=difference)
+			continue;
+		td=(signed)(rgb.a-data[t].a); td*=td; td*=255;
+		ttd+=td;
+		if (ttd>=difference)
+			continue;
+		if (!ttd)
+			return t;
+		difference=ttd;
+		best_choice=t;
+	}
+	return best_choice;
+}
+
+DEFINE_REF(gPixmap);
+
+gPixmap::~gPixmap()
+{
+	if (on_dispose)
+		on_dispose(this);
+	if (surface)
+		delete (gSurface*)surface;
+}
+
+static void donot_delete_surface(gPixmap *pixmap)
+{
+	pixmap->surface = NULL;
+}
+
+gPixmap::gPixmap(gUnmanagedSurface *surface):
+	surface(surface),
+	on_dispose(donot_delete_surface)
+{
+}
+
+gPixmap::gPixmap(eSize size, int bpp, int accel):
+	surface(new gSurface(size.width(), size.height(), bpp, accel)),
+	on_dispose(NULL)
+{
+}
+
+gPixmap::gPixmap(int width, int height, int bpp, gPixmapDisposeCallback call_on_dispose, int accel):
+	surface(new gSurface(width, height, bpp, accel)),
+	on_dispose(call_on_dispose)
+{
+}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/lcd.cpp enigma2-nightly.patched/lib/gdi/lcd.cpp
--- enigma2-nightly.org/lib/gdi/lcd.cpp	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/lcd.cpp	2013-08-11 08:18:50.254295882 +0200
@@ -60,6 +60,7 @@
 }
 #endif
 
+#ifndef HAVE_GRAPHLCD
 eDBoxLCD::eDBoxLCD()
 {
 	int xres=132, yres=64, bpp=8;
@@ -301,3 +302,141 @@
 	}
 #endif
 }
+
+#else
+
+void eDBoxLCD::setFlipped(bool onoff)
+{
+	flipped = onoff;
+	update();
+}
+
+/* **************************************************************** */
+/* Pearl LCD */
+
+eDBoxLCD::eDBoxLCD()
+{
+	eDebug("eDBoxLCD::eDBoxLCD >");
+
+	displayNumber = 0;
+	is_oled = 1;
+
+	instance=this;
+
+	if (GLCD::Config.Load("/etc/graphlcd.conf") == false)
+	{
+		eDebug("Error loading config file!\n");
+		return;
+	}
+	if (GLCD::Config.driverConfigs.size() <= 0)
+	{
+		eDebug("ERROR: No displays specified in config file!\n");
+	}
+
+	GLCD::Config.driverConfigs[displayNumber].upsideDown ^= 0;
+	GLCD::Config.driverConfigs[displayNumber].invert ^= 0;
+
+	lcd = GLCD::CreateDriver(GLCD::Config.driverConfigs[displayNumber].id, &GLCD::Config.driverConfigs[displayNumber]);
+
+	if (!lcd)
+	{
+		eDebug("ERROR: Failed creating display object\n");
+		return;
+	}
+	if (lcd->Init() != 0)
+	{
+#if 0
+	// Returning an error here will break the code at various other places
+		eDebug("ERROR: Failed initializing display\n");
+		delete lcd;
+		lcd = NULL;
+		return;
+#endif
+	}
+	lcd->SetBrightness(GLCD::Config.driverConfigs[displayNumber].brightness);
+
+	lcd->GetFeature((std::string) "depth", depth);
+	width = GLCD::Config.driverConfigs[displayNumber].width;
+	height = GLCD::Config.driverConfigs[displayNumber].height;
+
+	eDebug("config -> (w %d, h %d)", width, height);
+
+	bitmap = new GLCD::cBitmap(width, height);
+	bitmap->Clear();
+
+	lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+	lcd->Refresh(true);
+
+	lcdfd = 1; //needed for detected()
+	setSize(width, height, depth);
+
+	eDebug("eDBoxLCD::eDBoxLCD (w %d, h %d, depth %d)<", width, height, depth);
+}
+
+void eDBoxLCD::setInverted(unsigned char inv)
+{
+	eDebug("eDBoxLCD::setInverted");
+	inverted = inv;
+	update();
+}
+
+int eDBoxLCD::setLCDContrast(int contrast)
+{
+	eDebug("[LCD] setLCDContrast not supported");
+	return(0);
+}
+
+int eDBoxLCD::setLCDBrightness(int brightness)
+{
+	eDebug("eDBoxLCD::setLCDBrightness");
+/* fixme range check */
+	lcd->SetBrightness(brightness);
+	return(0);
+}
+
+eDBoxLCD::~eDBoxLCD()
+{
+	eDebug("eDBoxLCD::~eDBoxLCD");
+}
+
+eDBoxLCD *eDBoxLCD::getInstance()
+{
+	eDebug("eDBoxLCD::getInstance");
+	return instance;
+}
+
+void eDBoxLCD::update()
+{
+	if (lcdfd == 1)
+	{
+		bitmap->Clear();
+		for (int x = 0; x < width; x++)
+			for (int y = 0; y < height; y++)
+			{
+				__u16 *buf16  = (__u16*) _buffer;
+#if BYTE_ORDER == LITTLE_ENDIAN
+				__u16 col16 = bswap_16(*((__u16*)(((__u16*)buf16) + y * width + x)));
+#else
+				__u16 col16 = *((__u16*)(((__u16*)buf16) + y * width + x));
+#endif
+				__u8 red, green, blue, alpha; 
+				__u32 color32;
+
+				/* BBBBB GGGGGG RRRRR */
+				blue  = ((col16 & 0xF800) >> 11) * ( 255 / 31);
+				green = ((col16 & 0x7E0) >> 5) * (255 / 63);
+				red   = (col16 & 0x1f) * (255 / 31);
+				alpha = 255;
+
+				color32 = alpha << 24 | red << 16 | green << 8 | blue;
+
+				if (inverted)
+					color32 = 0xFFFFFF - color32;
+
+				bitmap->DrawPixel(x, y, color32);
+			}
+		lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+		lcd->Refresh(false); /* partial update */
+	}
+}
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/lcd.h enigma2-nightly.patched/lib/gdi/lcd.h
--- enigma2-nightly.org/lib/gdi/lcd.h	2013-08-11 08:11:19.154306132 +0200
+++ enigma2-nightly.patched/lib/gdi/lcd.h	2013-08-11 08:18:50.254295882 +0200
@@ -5,6 +5,17 @@
 #include <lib/gdi/esize.h>
 #include <lib/gdi/erect.h>
 
+#ifdef HAVE_GRAPHLCD
+#include <glcdgraphics/bitmap.h>
+#include <glcdgraphics/glcd.h>
+#include <glcdgraphics/image.h>
+#include <glcddrivers/config.h>
+#include <glcddrivers/driver.h>
+#include <glcddrivers/drivers.h>
+#include <glcdgraphics/extformats.h>
+#include <byteswap.h>
+#endif
+
 #define LCD_CONTRAST_MIN 0
 #define LCD_CONTRAST_MAX 63
 #define LCD_BRIGHTNESS_MIN 0
@@ -48,6 +59,13 @@
 	unsigned char inverted;
 	bool flipped;
 	int is_oled;
+#ifdef HAVE_GRAPHLCD
+	GLCD::cDriver * lcd;
+	GLCD::cBitmap * bitmap;
+	int displayNumber;
+	int depth;
+	int width, height;
+#endif
 #ifdef SWIG
 	eDBoxLCD();
 	~eDBoxLCD();
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/Makefile.inc enigma2-nightly.patched/lib/gdi/Makefile.inc
--- enigma2-nightly.org/lib/gdi/Makefile.inc	2013-08-11 08:11:19.150306132 +0200
+++ enigma2-nightly.patched/lib/gdi/Makefile.inc	2013-08-11 08:18:50.254295882 +0200
@@ -19,7 +19,8 @@
 	gdi/lcd.cpp \
 	gdi/picexif.cpp \
 	gdi/picload.cpp \
-	gdi/region.cpp
+	gdi/region.cpp \
+	gdi/stmfb.cpp
 
 gdiincludedir = $(pkgincludedir)/lib/gdi
 gdiinclude_HEADERS = \
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/picload.cpp enigma2-nightly.patched/lib/gdi/picload.cpp
--- enigma2-nightly.org/lib/gdi/picload.cpp	2013-08-11 08:11:19.158306132 +0200
+++ enigma2-nightly.patched/lib/gdi/picload.cpp	2013-08-11 08:18:50.254295882 +0200
@@ -4,6 +4,7 @@
 
 #include <lib/gdi/picload.h>
 #include <lib/gdi/picexif.h>
+#include "../../../misc/tools/libmmeimage/libmmeimage.h"
 
 extern "C" {
 #include <jpeglib.h>
@@ -663,7 +664,45 @@
 
 void ePicLoad::decodePic()
 {
-	eDebug("[Picload] decode picture... %s",m_filepara->file);
+	if (m_filepara->id == F_JPEG)
+	{
+		eDebug("[Picload] hardware decode picture... %s",m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
+
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+		
+		if (get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			int imx, imy;
+
+			if ((m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox) <= m_filepara->max_y)
+			{
+				imx = m_filepara->max_x;
+				imy = (int)(m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox);
+			}
+			else
+			{
+				imx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->ox * m_filepara->max_y / m_filepara->oy);
+				imy = m_filepara->max_y;
+			}
+			
+			if (decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				return;
+			}
+		}
+		
+		eDebug("hardware decode error");
+		
+		fclose(fp);
+	}
+
+	eDebug("[Picload] software decode picture... %s",m_filepara->file);
 
 	switch(m_filepara->id)
 	{
@@ -748,12 +787,56 @@
 		}
 	}
 
-	switch(m_filepara->id)
+	int hw_decoded = 0;
+	if (m_filepara->id == F_JPEG)
 	{
-		case F_PNG:	png_load(m_filepara, m_conf.background); break;
-		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);	break;
-		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
-		case F_GIF:	gif_load(m_filepara); break;
+		eDebug("[Picload] hardware decode picture... %s",m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
+
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+		
+		if (get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			int imx, imy;
+			if (m_filepara->ox <= m_filepara->oy)
+			{
+				imy = m_conf.thumbnailsize;
+				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
+			}
+			else
+			{
+				imx = m_conf.thumbnailsize;
+				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
+			}
+			
+			if (decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				hw_decoded = 1;
+			}
+		}
+
+		if (!hw_decoded)
+		{
+			eDebug("hardware decode error");
+		
+			fclose(fp);
+		}
+	}
+
+	if (!hw_decoded)
+	{
+		switch(m_filepara->id)
+		{
+			case F_PNG: png_load(m_filepara, m_conf.background); break;
+			case F_JPEG: m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y); break;
+			case F_BMP: m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy); break;
+			case F_GIF: gif_load(m_filepara); break;
+		}
 	}
 
 	if(exif_thumbnail)
@@ -768,21 +851,25 @@
 				::mkdir(cachedir.c_str(), 0755);
 
 			//resize for Thumbnail
-			int imx, imy;
-			if (m_filepara->ox <= m_filepara->oy)
-			{
-				imy = m_conf.thumbnailsize;
-				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
-			}
-			else
+			if(!hw_decoded)
 			{
-				imx = m_conf.thumbnailsize;
-				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
-			}
+			
+				int imx, imy;
+				if (m_filepara->ox <= m_filepara->oy)
+				{
+					imy = m_conf.thumbnailsize;
+					imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
+				}
+				else
+				{
+					imx = m_conf.thumbnailsize;
+					imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
+				}
 
-			m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
-			m_filepara->ox = imx;
-			m_filepara->oy = imy;
+				m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+			}
 
 			if(jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
 				eDebug("[Picload] error saving cachefile");
@@ -1225,3 +1312,65 @@
 
 	return 0;
 }
+
+#if defined(__sh__)
+//---------------------------------------------------------------------------------------------
+
+PyObject *getExif(const char *filename)
+{
+	ePyObject list;
+	Cexif exif;
+	if(exif.DecodeExif(filename))
+	{
+		if(exif.m_exifinfo->IsExif)
+		{
+			int pos=0;
+			char tmp[256];
+			list = PyList_New(22);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Version));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraMake));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraModel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->DateTime));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Comments));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", exif.m_exifinfo->Width, exif.m_exifinfo->Height));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Orientation));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->MeteringMode));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ExposureProgram));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->LightSource));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->FlashUsed));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->CompressionLevel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->ISOequivalent));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Xresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Yresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ResolutionUnit));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Brightness);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f sec.", exif.m_exifinfo->ExposureTime);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->ExposureBias);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->Distance);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->CCDWidth);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->ApertureFNumber);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+		}
+		else
+		{
+			list = PyList_New(1);
+			PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+		}
+		exif.ClearExif();
+	}
+	else
+	{
+		list = PyList_New(1);
+		PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+	}
+
+	return list ? (PyObject*)list : (PyObject*)PyList_New(0);
+}
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/stmfb.cpp enigma2-nightly.patched/lib/gdi/stmfb.cpp
--- enigma2-nightly.org/lib/gdi/stmfb.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/gdi/stmfb.cpp	2013-08-11 08:18:50.254295882 +0200
@@ -0,0 +1,75 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+	bltData.srcFormat  = SURF_BGRA8888;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+	bltData.dstFormat  = SURF_BGRA8888;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/Makefile.am enigma2-nightly.patched/lib/Makefile.am
--- enigma2-nightly.org/lib/Makefile.am	2013-08-11 08:11:19.050306134 +0200
+++ enigma2-nightly.patched/lib/Makefile.am	2013-08-11 08:18:50.254295882 +0200
@@ -7,6 +7,11 @@
 	-include Python.h \
 	-include $(top_builddir)/enigma2_config.h
 
+if ENABLE_LIBEPLAYER3
+AM_CPPFLAGS += \
+	-I$(top_srcdir)/../misc/tools/libeplayer3/include
+endif
+
 # initialize these, to be filled with targets in the included files
 noinst_LIBRARIES=
 BUILT_SOURCES=
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/Converter/RemainingToText.py enigma2-nightly.patched/lib/python/Components/Converter/RemainingToText.py
--- enigma2-nightly.org/lib/python/Components/Converter/RemainingToText.py	2013-08-11 08:11:19.170306132 +0200
+++ enigma2-nightly.patched/lib/python/Components/Converter/RemainingToText.py	2013-08-11 08:18:50.258295916 +0200
@@ -8,6 +8,9 @@
 	IN_SECONDS = 3
 	PROGRESS = 4
 	WITH_SECONDSPROGRESS = 5
+#+++>
+	FOLLOW = 6
+#+++<
 
 	def __init__(self, type):
 		Converter.__init__(self, type)
@@ -21,6 +24,10 @@
 			self.type = self.PROGRESS
 		elif type == "WithSecondsProgress":
 			self.type = self.WITH_SECONDSPROGRESS
+#+++>
+		elif type == "FOLLOW":
+			self.type = self.FOLLOW
+#+++<
 		else:
 			self.type = self.DEFAULT
 
@@ -58,6 +65,13 @@
 			return "%s%d:%02d" % (prefix, hours, minutes)
 		elif self.type == self.IN_SECONDS:
 			return prefix+str(tsecs)
+#+++>
+		elif self.type == self.FOLLOW:
+			if remaining is not None:
+				return "in %d min" % (remaining / 60)
+			else:
+				return "%d min" % (duration / 60)
+#+++<
 		elif self.type == self.DEFAULT:
 			if remaining <= duration:
 				prefix = "+"
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/Harddisk.py enigma2-nightly.patched/lib/python/Components/Harddisk.py
--- enigma2-nightly.org/lib/python/Components/Harddisk.py	2013-08-11 08:11:19.170306132 +0200
+++ enigma2-nightly.patched/lib/python/Components/Harddisk.py	2013-08-11 08:18:50.266295941 +0200
@@ -71,21 +71,11 @@
 			self.dev_path = '/dev/' + self.device
 			self.disk_path = self.dev_path
 
+#+++>
 		elif self.type == DEVTYPE_DEVFS:
-			tmp = readFile(self.sysfsPath('dev')).split(':')
-			s_major = int(tmp[0])
-			s_minor = int(tmp[1])
-			for disc in os.listdir("/dev/discs"):
-				dev_path = os.path.realpath('/dev/discs/' + disc)
-				disk_path = dev_path + '/disc'
-				try:
-					rdev = os.stat(disk_path).st_rdev
-				except OSError:
-					continue
-				if s_major == os.major(rdev) and s_minor == os.minor(rdev):
-					self.dev_path = dev_path
-					self.disk_path = disk_path
-					break
+			self.dev_path = '/dev/' + self.device
+			self.disk_path = self.dev_path
+#+++<
 
 		print "new Harddisk", self.device, '->', self.dev_path, '->', self.disk_path
 		if not removable:
@@ -679,6 +669,12 @@
 		for item in getProcMounts():
 			if item[0] == dev:
 				return item[1]
+#+++>
+		#Check if has autofs mountpoint
+		mount = self.getAutofsMountpoint(device)
+		if mount:
+			return mount
+#+++<
 		return None
 
 	def addHotplugPartition(self, device, physdev = None):
@@ -694,6 +690,10 @@
 		error, blacklisted, removable, is_cdrom, partitions, medium_found = self.getBlockDevInfo(device)
 		if not blacklisted and medium_found:
 			description = self.getUserfriendlyDeviceName(device, physdev)
+#+++>
+			if description.startswith("External Storage"):
+				return False, False, False, False, [], False
+#+++<
 			p = Partition(mountpoint = self.getMountpoint(device), description = description, force_mounted = True, device = device)
 			self.partitions.append(p)
 			if p.mountpoint: # Plugins won't expect unmounted devices
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/NimManager.py enigma2-nightly.patched/lib/python/Components/NimManager.py
--- enigma2-nightly.org/lib/python/Components/NimManager.py	2013-08-11 08:11:19.174306131 +0200
+++ enigma2-nightly.patched/lib/python/Components/NimManager.py	2013-08-11 08:18:50.266295941 +0200
@@ -20,6 +20,10 @@
 import xml.etree.cElementTree
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/Renderer/Makefile.am enigma2-nightly.patched/lib/python/Components/Renderer/Makefile.am
--- enigma2-nightly.org/lib/python/Components/Renderer/Makefile.am	2013-08-11 08:11:19.182306131 +0200
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Makefile.am	2013-08-11 08:18:50.266295941 +0200
@@ -3,4 +3,5 @@
 install_PYTHON = \
 	__init__.py Label.py Progress.py Listbox.py Renderer.py Pixmap.py \
 	FixedLabel.py PositionGauge.py Canvas.py Picon.py Pig.py \
-	FrontpanelLed.py ChannelNumber.py VideoSize.py NextEpgInfo.py
+	FrontpanelLed.py ChannelNumber.py VideoSize.py NextEpgInfo.py \
+	SingleEpgList.py
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/Renderer/Progress.py enigma2-nightly.patched/lib/python/Components/Renderer/Progress.py
--- enigma2-nightly.org/lib/python/Components/Renderer/Progress.py	2013-08-11 08:11:19.182306131 +0200
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Progress.py	2013-08-11 08:18:50.266295941 +0200
@@ -13,25 +13,40 @@
 	GUI_WIDGET = eSlider
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
-
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
+
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
 
 	GUI_WIDGET = eSlider
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def getRange(self):
 		return (self.__start, self.__end)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/Renderer/SingleEpgList.py enigma2-nightly.patched/lib/python/Components/Renderer/SingleEpgList.py
--- enigma2-nightly.org/lib/python/Components/Renderer/SingleEpgList.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Components/Renderer/SingleEpgList.py	2013-08-11 08:18:50.266295941 +0200
@@ -0,0 +1,39 @@
+from Components.VariableText import VariableText
+from enigma import eLabel, eEPGCache
+from Renderer import Renderer
+from time import localtime
+
+class SingleEpgList(Renderer, VariableText):
+	def __init__(self):
+		Renderer.__init__(self)
+		VariableText.__init__(self)
+		self.epgcache = eEPGCache.getInstance()
+
+	GUI_WIDGET = eLabel
+
+	def changed(self, what):
+		event = self.source.event
+
+		if event is None:
+			self.text = ""
+			return
+		service = self.source.service
+		text = ""
+		evt = None
+
+		if self.epgcache is not None:
+			evt = self.epgcache.lookupEvent(['IBDCT', (service.toString(), 0, -1, -1)])
+
+		if evt:
+			maxx = 0
+			for x in evt:
+				if maxx > 0:
+					if x[4]:
+						t = localtime(x[1])
+						text = text + "%02d:%02d %s\n" % (t[3], t[4], x[4])
+					else:
+						text = text + "n/a\n"
+				maxx += 1
+				if maxx > 4:
+					break
+		self.text = text
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/UsageConfig.py enigma2-nightly.patched/lib/python/Components/UsageConfig.py
--- enigma2-nightly.org/lib/python/Components/UsageConfig.py	2013-08-11 08:11:19.186306131 +0200
+++ enigma2-nightly.patched/lib/python/Components/UsageConfig.py	2013-08-11 08:18:50.270295936 +0200
@@ -174,7 +174,7 @@
 	config.usage.frontend_priority = ConfigSelection(default = "-1", choices = nims)
 	config.misc.disable_background_scan = ConfigYesNo(default = False)
 
-	config.usage.show_event_progress_in_servicelist = ConfigSelection(default = 'barright', choices = [
+	config.usage.show_event_progress_in_servicelist = ConfigSelection(default = 'barleft', choices = [
 		('barleft', _("Progress bar left")),
 		('barright', _("Progress bar right")),
 		('percleft', _("Percentage left")),
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/VolumeControl.py enigma2-nightly.patched/lib/python/Components/VolumeControl.py
--- enigma2-nightly.org/lib/python/Components/VolumeControl.py	2013-08-11 08:11:19.186306131 +0200
+++ enigma2-nightly.patched/lib/python/Components/VolumeControl.py	2013-08-11 08:52:53.502249728 +0200
@@ -72,12 +72,24 @@
 
 	def volMute(self, showMuteSymbol=True, force=False):
 		vol = self.volctrl.getVolume()
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
 		if vol or force:
 			self.volctrl.volumeToggleMute()
 			if self.volctrl.isMuted():
 				if showMuteSymbol:
 					self.muteDialog.show()
 				self.volumeDialog.setValue(0)
+#+++>
+				self.volctrl.setVolume(0,0)
+#+++<
 			else:
 				self.muteDialog.hide()
 				self.volumeDialog.setValue(vol)
+#+++>
+				self.volctrl.setVolume(vol, vol)
+#+++<
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/VolumeControl.py~ enigma2-nightly.patched/lib/python/Components/VolumeControl.py~
--- enigma2-nightly.org/lib/python/Components/VolumeControl.py~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Components/VolumeControl.py~	2013-08-11 08:51:37.938251437 +0200
@@ -0,0 +1,89 @@
+from enigma import eDVBVolumecontrol, eTimer
+from Tools.Profile import profile
+from Screens.Volume import Volume
+from Screens.Mute import Mute
+from GlobalActions import globalActionMap
+from config import config, ConfigSubsection, ConfigInteger
+
+profile("VolumeControl")
+#TODO .. move this to a own .py file
+class VolumeControl:
+	instance = None
+	"""Volume control, handles volUp, volDown, volMute actions and display
+	a corresponding dialog"""
+	def __init__(self, session):
+		global globalActionMap
+		globalActionMap.actions["volumeUp"]=self.volUp
+		globalActionMap.actions["volumeDown"]=self.volDown
+		globalActionMap.actions["volumeMute"]=self.volMute
+
+		assert not VolumeControl.instance, "only one VolumeControl instance is allowed!"
+		VolumeControl.instance = self
+
+		config.audio = ConfigSubsection()
+		config.audio.volume = ConfigInteger(default = 50, limits = (0, 100))
+
+		self.volumeDialog = session.instantiateDialog(Volume)
+		self.muteDialog = session.instantiateDialog(Mute)
+
+		self.hideVolTimer = eTimer()
+		self.hideVolTimer.callback.append(self.volHide)
+
+		vol = config.audio.volume.value
+		self.volumeDialog.setValue(vol)
+		self.volctrl = eDVBVolumecontrol.getInstance()
+		self.volctrl.setVolume(vol, vol)
+
+	def volSave(self):
+		if self.volctrl.isMuted():
+			config.audio.volume.value = 0
+		else:
+			config.audio.volume.value = self.volctrl.getVolume()
+		config.audio.volume.save()
+
+	def volUp(self):
+		self.setVolume(+1)
+
+	def volDown(self):
+		self.setVolume(-1)
+
+	def setVolume(self, direction):
+		oldvol = self.volctrl.getVolume()
+		if direction > 0:
+			self.volctrl.volumeUp()
+		else:
+			self.volctrl.volumeDown()
+		is_muted = self.volctrl.isMuted()
+		vol = self.volctrl.getVolume()
+		self.volumeDialog.show()
+		if is_muted:
+			self.volMute() # unmute
+		elif not vol:
+			self.volMute(False, True) # mute but dont show mute symbol
+		if self.volctrl.isMuted():
+			self.volumeDialog.setValue(0)
+		else:
+			self.volumeDialog.setValue(self.volctrl.getVolume())
+		self.volSave()
+		self.hideVolTimer.start(3000, True)
+
+	def volHide(self):
+		self.volumeDialog.hide()
+
+	def volMute(self, showMuteSymbol=True, force=False):
+		vol = self.volctrl.getVolume()
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
+		if vol or force:
+			self.volctrl.volumeToggleMute()
+			if self.volctrl.isMuted():
+				if showMuteSymbol:
+					self.muteDialog.show()
+				self.volumeDialog.setValue(0)
+			else:
+				self.muteDialog.hide()
+				self.volumeDialog.setValue(vol)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/enigma_python.i enigma2-nightly.patched/lib/python/enigma_python.i
--- enigma2-nightly.org/lib/python/enigma_python.i	2013-08-11 08:11:19.334306128 +0200
+++ enigma2-nightly.patched/lib/python/enigma_python.i	2013-08-11 08:18:50.274295933 +0200
@@ -108,6 +108,7 @@
 #include <lib/python/python.h>
 #include <lib/python/python_helpers.h>
 #include <lib/gdi/picload.h>
+#include <lib/driver/vfd.h> 
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -250,6 +251,7 @@
 %include <lib/python/python.h>
 %include <lib/python/pythonconfig.h>
 %include <lib/gdi/picload.h>
+%include <lib/driver/vfd.h>
 /**************  eptr  **************/
 
 /**************  signals  **************/
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Makefile.inc enigma2-nightly.patched/lib/python/Makefile.inc
--- enigma2-nightly.org/lib/python/Makefile.inc	2013-08-11 08:11:19.190306131 +0200
+++ enigma2-nightly.patched/lib/python/Makefile.inc	2013-08-11 08:18:50.274295933 +0200
@@ -32,7 +32,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python/enigma_python.Pcpp@am__quote@
 
 .i.cpp:
-	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -O -nortti -nothreads -o $@ $<
+	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -D__sh__ -O -nortti -nothreads -o $@ $<
 	$(AM_V_at)mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Pcpp
 	$(AM_V_at)$(PYTHON) $(srcdir)/python/enigma_py_patcher.py python/enigma.py
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	2013-08-11 08:18:50.274295933 +0200
@@ -0,0 +1,2 @@
+
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	2013-08-11 08:18:50.274295933 +0200
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/CuberevoVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	2013-08-11 08:18:50.274295933 +0200
@@ -0,0 +1,317 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, configfile, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import *
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from re import compile as re_compile, search as re_search
+
+import os
+
+my_global_session = None
+
+config.plugins.CuberevoVFD = ConfigSubsection()
+config.plugins.CuberevoVFD.scroll = ConfigSelection(default = "once", choices = [("never"), ("once"), ("always")])
+config.plugins.CuberevoVFD.brightness = ConfigSelection(default = "bright", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.CuberevoVFD.showClock = ConfigEnableDisable(default = True)
+#config.plugins.CuberevoVFD.setDaylight = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.timeMode = ConfigSelection(default = "24h", choices = [("12h"),("24h")])
+config.plugins.CuberevoVFD.setLed = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.setFan = ConfigEnableDisable(default = True)
+
+class CuberevoVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="CuberevoVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.CuberevoVFD.showClock))
+		self.list.append(getConfigListEntry(_("Time mode"), config.plugins.CuberevoVFD.timeMode))
+		self.list.append(getConfigListEntry(_("Set led"), config.plugins.CuberevoVFD.setLed))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.CuberevoVFD.brightness))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.CuberevoVFD.scroll))
+		self.list.append(getConfigListEntry(_("Set fan"), config.plugins.CuberevoVFD.setFan))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+
+		if config.plugins.CuberevoVFD.showClock.getValue():
+			cubeVfd.enableClock()
+		else:
+			cubeVfd.disableClock()
+
+#		if config.plugins.CuberevoVFD.setDaylight.getValue():
+#			cubeVfd.enableDaylight()
+#		else:
+#			cubeVfd.disableDaylight()
+
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			cubeVfd.enableTimeMode()
+		else:
+			cubeVfd.disableTimeMode()
+
+		# enable/disable fan activity
+		if config.plugins.CuberevoVFD.setFan.getValue():
+			cubeVfd.enableFan()
+		else:
+			cubeVfd.disableFan()
+
+		# enable/disable led activity
+		if config.plugins.CuberevoVFD.setLed.getValue():
+			cubeVfd.enableLed()
+		else:
+			cubeVfd.disableLed()
+
+	# set the brightness
+		brightness = 3
+		if config.plugins.CuberevoVFD.brightness.getValue() == "dark":
+			brightness = 1
+		elif config.plugins.CuberevoVFD.brightness.getValue() == "bright":
+			brightness = 7
+		evfd.getInstance().vfd_set_brightness(brightness)
+
+		configfile.save()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class CuberevoVFD:
+	def __init__(self, session):
+		#print "CuberevoVFD initializing"
+		global showmenuorpanel
+		showmenuorpanel = False
+		self.showtimer = eTimer()
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		self.Console = Console()
+		self.tsEnabled = False
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.fanEnabled = config.plugins.CuberevoVFD.setFan.getValue()
+		self.ledEnabled = config.plugins.CuberevoVFD.setLed.getValue()
+		self.clockEnabled = config.plugins.CuberevoVFD.showClock.getValue()
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			self.timeModeEnabled = 1
+		else:
+			self.timeModeEnabled = 0
+		if self.fanEnabled == False:
+			self.disableFan()
+		else:
+			self.enableFan()
+		if self.ledEnabled == False:
+			self.disableLed()
+		else:
+			self.enableLed()
+
+	def handleTimer(self):
+		global showmenuorpanel
+		try:
+			from Plugins.Extensions.Aafpanel.plugin import inAAFPanel
+			showPanel = inAAFPanel
+		except:
+			#print '[CuberevoVFD] Error showPanel'
+			showPanel = None
+		try:
+			from Screens.Menu import inMenu
+			showMenu = inMenu
+		except:
+			#print '[CuberevoVFD] Error showMenu'
+			showMenu = None
+		if showMenu or showPanel:
+			self.showtimer.start(4000, True)
+		self.showtimer.callback.append(self.setshowmenuorpanel)
+		if not showMenu and not showPanel and showmenuorpanel is True:
+			showmenuorpanel = False
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename =subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+				evfd.getInstance().vfd_write_string(servicename[0:17])
+
+	def setshowmenuorpanel(self):
+		global showmenuorpanel
+		showmenuorpanel = True
+		self.showtimer.stop()
+
+	def enableClock(self):
+		self.clockEnabled = True
+		try:
+			os.popen("/bin/fp_control -dt 1")
+		except OSError:
+			print "no memory"
+
+	def disableClock(self):
+		self.clockEnabled = False
+		try:
+			os.popen("/bin/fp_control -dt 0")
+		except OSError:
+			print "no memory"
+
+	def enableTimeMode(self):
+		self.timeModeEnabled = 1
+		try:
+			os.popen("/bin/fp_control -tm 1")
+		except OSError:
+			print "no memory"
+
+	def disableTimeMode(self):
+		self.timeModeEnabled = 0
+		try:
+			os.popen("/bin/fp_control -tm 0")
+		except OSError:
+			print "no memory"
+
+	def enableLed(self):
+		self.ledEnabled = True
+		try:
+			os.popen("/bin/fp_control -l 0 1")
+		except OSError:
+			print "no memory"
+
+	def disableLed(self):
+		self.ledEnabled = False
+		try:
+			os.popen("/bin/fp_control -l 0 0")
+		except OSError:
+			print "no memory"
+
+	def enableFan(self):
+		self.fanEnabled = True
+		try:
+			os.popen("/bin/fp_control -sf 1")
+		except OSError:
+			print "no memory"
+
+	def disableFan(self):
+		self.fanEnabled = False
+		try:
+			os.popen("/bin/fp_control -sf 0")
+		except OSError:
+			print "no memory"
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		if tmp:
+			print "[Timeshift enabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,True)
+		else:
+			print "[Timeshift disabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,False)
+		self.tsEnabled = tmp
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "CuberevoVFD aborting"
+
+def main(session, **kwargs):
+	session.open(CuberevoVFDSetup)
+
+cubeVfd = None
+gReason = -1
+mySession = None
+
+def controlcubeVfd():
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and cubeVfd == None:
+		print "Starting CuberevoVFD"
+		cubeVfd = CuberevoVFD(mySession)
+	elif gReason == 1 and cubeVfd != None:
+		print "Stopping CuberevoVFD"
+		cubeVfd = None
+
+def autostart(reason, **kwargs):
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlcubeVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="CuberevoVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am enigma2-nightly.patched/lib/python/Plugins/Extensions/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am	2013-08-11 08:11:19.234306130 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/Makefile.am	2013-08-11 08:18:50.274295933 +0200
@@ -1,6 +1,14 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn Modem
+SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn
+
+if ENABLE_TF7700
+SUBDIRS += TopfieldVFD
+endif
+
+if ENABLE_CUBEREVO
+SUBDIRS += CuberevoVFD
+endif
 
 if HAVE_LIBDDVD
 SUBDIRS += DVDPlayer
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	2013-08-11 08:18:50.274295933 +0200
@@ -0,0 +1,2 @@
+
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	2013-08-11 08:18:50.274295933 +0200
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/TopfieldVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	2013-08-11 08:18:50.278295930 +0200
@@ -0,0 +1,458 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, ConfigSubsection, ConfigEnableDisable, \
+	getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time, fcntl, struct
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from enigma import eTimer
+from re import compile as re_compile, search as re_search
+from time import time, localtime, strftime
+from Components.UsageConfig import defaultMoviePath
+from os import statvfs
+import array
+
+my_global_session = None
+debug = False
+
+config.plugins.TopfieldVFD = ConfigSubsection()
+config.plugins.TopfieldVFD.allCaps = ConfigEnableDisable(default = False)
+config.plugins.TopfieldVFD.scroll = ConfigSelection(choices = [("never"), ("once"), ("always")])
+config.plugins.TopfieldVFD.brightness = ConfigSelection(default = "medium", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.TopfieldVFD.scrollPause = ConfigInteger(default = 100, limits = (1, 255))
+config.plugins.TopfieldVFD.scrollDelay = ConfigInteger(default = 10, limits = (1, 255))
+config.plugins.TopfieldVFD.typematicDelay = ConfigInteger(default = 3, limits = (0, 255))
+config.plugins.TopfieldVFD.typematicRate = ConfigInteger(default = 10, limits = (0, 255))
+config.plugins.TopfieldVFD.rcCommandSet = ConfigSelection(default = "TF7700 & Masterpiece", choices = [("TF7700"), ("Masterpiece"), ("TF7700 & Masterpiece")])
+config.plugins.TopfieldVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.TopfieldVFD.showEthernet = ConfigEnableDisable(default = True)
+
+# ioctl definitions for the VFD
+ioBootReason = 0x40003a0b
+ioOffFlush = struct.pack('LLB', 0x2, 0x0, 0x6)
+ioRec1Flush = struct.pack('LLB', 0x1000, 0x0, 0x6)
+ioRec2Flush = struct.pack('LLB', 0x2000, 0x0, 0x6)
+ioRecBothFlush = struct.pack('LLB', 0x3000, 0x0, 0x6)
+ioClockFlush = struct.pack('LLB', 0x20, 0x0, 0x6)
+ioClockOff = struct.pack('LLB', 0x20, 0x0, 0x0)
+ioHddClear =    struct.pack('LLB', 0x0, 0xff8000,0x0)
+ioHddUsage = (  struct.pack('LLB', 0x0, 0x006000,0xf),  # HDD empty
+                struct.pack('LLB', 0x0, 0x00e000,0xf),
+                struct.pack('LLB', 0x0, 0x01e000,0xf),
+                struct.pack('LLB', 0x0, 0x03e000,0xf),
+                struct.pack('LLB', 0x0, 0x07e000,0xf),
+                struct.pack('LLB', 0x0, 0x0fe000,0xf),
+                struct.pack('LLB', 0x0, 0x1fe000,0xf),
+                struct.pack('LLB', 0x0, 0x3fe000,0xf),
+                struct.pack('LLB', 0x0, 0x7fe000,0xf))  # HDD full
+ioHddFull = struct.pack('LLB', 0x0, 0x800000,0x6)       # "HDD full" flashing
+hddCheckPeriod = 60 # check every 60 seconds
+ioIconCmd = 0x400b3a20
+ioTimeshiftOn = struct.pack('LLB', 0x80, 0x0, 0xf)
+ioTimeshiftOff = struct.pack('LLB', 0x80, 0x0, 0x0)
+ioRec1On = struct.pack('LLB', 0x1000, 0x0, 0xf)
+ioRec1Off = struct.pack('LLB', 0x1000, 0x0, 0x0)
+ioRec2On = struct.pack('LLB', 0x2000, 0x0, 0xf)
+ioRec2Off = struct.pack('LLB', 0x2000, 0x0, 0x0)
+ioRecBothOn = struct.pack('LLB', 0x3000, 0x0, 0xf)
+ioRecBothOff = struct.pack('LLB', 0x3000, 0x0, 0x0)
+ioEthBothOff = struct.pack('LLB', 0x0c000000, 0x0, 0x0)
+ioEthLeftOn = struct.pack('LLB', 0x08000000, 0x0, 0xe)
+ioEthRightOn = struct.pack('LLB', 0x04000000, 0x0,0xb)
+
+ioColonOn = struct.pack('LLB', 0x4, 0x0,0x3)
+ioColonOff = struct.pack('LLB', 0x4, 0x0,0x0)
+ioBrightnessCmd = 0x40013a05
+ioIrFilter1Cmd = 0x40003a06
+ioIrFilter4Cmd = 0x40003a09
+ioTypematicDelayCmd = 0x40013a0d
+ioTypematicRateCmd = 0x40013a0e
+ioScrollModeCmd = 0x40033a15
+ioAllcapsCmd = 0x40013a14
+
+class TopfieldVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="TopfieldVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.TopfieldVFD.showClock))
+		self.list.append(getConfigListEntry(_("Show Ethernet activity"), config.plugins.TopfieldVFD.showEthernet))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.TopfieldVFD.brightness))
+		self.list.append(getConfigListEntry(_("All caps"), config.plugins.TopfieldVFD.allCaps))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.TopfieldVFD.scroll))
+		self.list.append(getConfigListEntry(_("Scroll pause"), config.plugins.TopfieldVFD.scrollPause))
+		self.list.append(getConfigListEntry(_("Scroll delay"), config.plugins.TopfieldVFD.scrollDelay))
+		self.list.append(getConfigListEntry(_("Typematic delay"), config.plugins.TopfieldVFD.typematicDelay))
+		self.list.append(getConfigListEntry(_("Typematic rate"), config.plugins.TopfieldVFD.typematicRate))
+		self.list.append(getConfigListEntry(_("RC command set"), config.plugins.TopfieldVFD.rcCommandSet))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+			}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+		tfVfd.setValues()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class TopfieldVFD:
+	def __init__(self, session):
+		#print "TopfieldVFD initializing"
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+		{
+			iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+			iPlayableService.evStart: self.__evStart,
+		})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.Console = Console()
+		self.tsEnabled = False
+		self.recNum = 0
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.txCount = 0
+		self.clock = 0
+		self.valuesSet = 0
+		self.hddUsed = 10 # initialize with an invalid value
+		self.hddCheckCounter = hddCheckPeriod
+		self.ethEnabled = config.plugins.TopfieldVFD.showEthernet.getValue()
+		self.clockEnabled = config.plugins.TopfieldVFD.showClock.getValue()
+		self.setValues()
+
+	def setValues(self):
+		#print "\nTopfiledVFD.setValues()\n"
+		if config.plugins.TopfieldVFD.showClock.value:
+			self.enableClock()
+		else:
+			self.disableClock()
+
+		# enable/disable displaying Ethernet activity
+		if config.plugins.TopfieldVFD.showEthernet.getValue():
+			self.enableEthernet()
+		else:
+			self.disableEthernet()
+
+		try:
+			fd = open("/dev/fpc")
+
+			# set the brightness
+			brightness = 3
+			if config.plugins.TopfieldVFD.brightness.getValue() == "dark":
+				brightness = 1
+			elif config.plugins.TopfieldVFD.brightness.getValue() == "bright":
+				brightness = 5
+			fcntl.ioctl(fd.fileno(), ioBrightnessCmd, struct.pack('B', brightness))
+
+			# set the the scroll mode
+			if config.plugins.TopfieldVFD.scroll.value == "once":
+				scrollMode = 1
+			elif config.plugins.TopfieldVFD.scroll.value == "always":
+				scrollMode = 2
+			else: # set to never by default
+				scrollMode = 0
+			scrollOpts = struct.pack('BBB', scrollMode,
+						int(config.plugins.TopfieldVFD.scrollPause.value),
+						int(config.plugins.TopfieldVFD.scrollDelay.value))
+			fcntl.ioctl(fd.fileno(), ioScrollModeCmd, scrollOpts)
+
+			# set the typematic values
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicRate.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicRateCmd, tmp)
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicDelay.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicDelayCmd, tmp)
+
+			# set the IR filters
+			if config.plugins.TopfieldVFD.rcCommandSet.getValue() == "Masterpiece":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 0))
+			elif config.plugins.TopfieldVFD.rcCommandSet.getValue() == "TF7700":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 0))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+			else: # enable both by default
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+
+			# set the allcaps parameter
+			if config.plugins.TopfieldVFD.allCaps.value:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 1))
+			else:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 0))
+
+			buf = array.array('h', [0])
+			fcntl.ioctl(fd.fileno(),ioBootReason,buf,1)
+			if buf[0] == 2:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioOffFlush)
+
+			fd.close()
+			self.valuesSet = 1
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: setValues ", e
+
+	def enableEthernet(self):
+		self.ethEnabled = True
+
+	def disableEthernet(self):
+		self.ethEnabled = False
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableEthernet ", e
+
+	def enableClock(self):
+		self.clockEnabled = True
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOn)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: enableClock ", e
+
+	def disableClock(self):
+		self.clockEnabled = False
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOff)
+			fd.close()
+			open("/dev/fpsmall", "w").write("     ")
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableClock ", e
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def displayHddUsed(self):
+		if debug:
+			print "TopfieldVFD: determine HDD usage"
+
+		# determine the HDD usage
+		used = 0;
+		try:
+			f = statvfs(defaultMoviePath())
+			# there are 8 HDD segments in the VFD
+			used = (f.f_blocks - f.f_bavail) * 8 / f.f_blocks
+		except:
+			used = 0;
+
+		if self.hddUsed != used:
+			try:
+				fd = open("/dev/fpc")
+				if self.hddUsed > used:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddClear)
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddUsage[used])
+				if used == 8:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddFull)
+				fd.close();
+			except IOError,e:
+				self.hddUsed = used # dummy operation
+			self.hddUsed = used
+
+	def handleTimer(self):
+		#print "[ TopfieldVFD timer ]"
+		if self.valuesSet == 0:
+			self.setValues()
+
+		if self.clockEnabled:
+			clock = strftime("%k%M",localtime(time()))
+			if clock != self.clock:
+				self.clock = clock
+				try:
+					open("/dev/fpsmall", "w").write(clock + "\0")
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (clock) ", e
+
+		# check HDD periodically
+		if self.hddCheckCounter < hddCheckPeriod:
+			self.hddCheckCounter += 1
+		else:
+			self.hddCheckCounter = 0
+			self.displayHddUsed()
+
+		if self.ethEnabled == False:
+			return
+
+		result = open("/proc/net/dev").readlines()
+		numRegExp = "[0-9]+"
+		numPattern = re_compile(numRegExp)
+		txPattern = re_compile("eth0:[ ]*" + numRegExp)
+		for item in result:
+			tmp = self.regExpMatch(txPattern, item)
+			if tmp != None:
+				tmp = tmp[5:].lstrip()
+				try:
+					fd = open("/dev/fpc")
+					if self.txCount != tmp:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthLeftOn)
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthRightOn)
+						self.txCount = tmp
+					else:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+					fd.close()
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (Ethernet) ", e
+					break
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if tmp:
+				print "[Timeshift enabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+			else:
+				print "[Timeshift disabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: __evSeekableStatusChanged ", e
+			self.tsEnabled = tmp
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs == self.recNum:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if config.usage.blinking_display_clock_during_recording.value:
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1Flush)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+			else:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOn)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1On)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: gotRecordEvent ", e
+		self.recNum = nrecs
+
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "TopfieldVFD aborting"
+
+def main(session, **kwargs):
+	session.open(TopfieldVFDSetup)
+
+tfVfd = None
+gReason = -1
+mySession = None
+
+def controlTfVfd():
+	global tfVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and tfVfd == None:
+		print "Starting TopfieldVFD"
+		tfVfd = TopfieldVFD(mySession)
+	elif gReason == 1 and tfVfd != None:
+		print "Stopping TopfieldVFD"
+		tfVfd.disableClock()
+		tfVfd = None
+
+def autostart(reason, **kwargs):
+	global tfVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlTfVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="TopfieldVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py	2013-08-11 08:11:19.258306130 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py	2013-08-11 08:18:50.278295930 +0200
@@ -106,7 +106,7 @@
 
 def Plugins(**kwargs):
 	from os import path
-	if path.exists("/dev/hdmi_cec") or path.exists("/dev/misc/hdmi_cec0"):
+	if path.exists("/dev/hdmi_cec") or path.exists("/lib/modules/cec.ko"):
 		import Components.HdmiCec
 		from Plugins.Plugin import PluginDescriptor
 		return [PluginDescriptor(name = "HDMI CEC setup", description = _("Adjust HDMI CEC settings"), where = PluginDescriptor.WHERE_PLUGINMENU, fnc = main)]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py	2013-08-11 08:11:19.258306130 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py	2013-08-11 08:18:50.282295929 +0200
@@ -9,6 +9,8 @@
 	action = v.get("ACTION")
 	device = v.get("DEVPATH")
 	physdevpath = v.get("PHYSDEVPATH")
+	if physdevpath == "-":
+		physdevpath = None
 	media_state = v.get("X_E2_MEDIA_STATUS")
 
 	dev = device.split('/')[-1]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Makefile.am enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Makefile.am	2013-08-11 08:11:19.258306130 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Makefile.am	2013-08-11 08:18:50.282295929 +0200
@@ -2,9 +2,9 @@
 
 SUBDIRS = SoftwareManager PositionerSetup Satfinder \
 	SkinSelector SatelliteEquipmentControl Videomode VideoTune Hotplug \
-	DefaultServicesScanner DiseqcTester CommonInterfaceAssignment \
+	DefaultServicesScanner DiseqcTester \
 	CableScan FastScan OSDPositionSetup OSD3DSetup HdmiCEC VideoClippingSetup \
-	VideoEnhancement WirelessLan NetworkWizard
+	VideoEnhancement WirelessLan NetworkWizard VFD-Icons
 
 if HAVE_TEMPFANCONTROL
 SUBDIRS += TempFanControl
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	2013-08-11 08:18:50.282295929 +0200
@@ -0,0 +1,2 @@
+
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	2013-08-11 08:18:50.282295929 +0200
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	2013-08-11 08:18:50.282295929 +0200
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	2013-08-11 08:18:50.282295929 +0200
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta
+
+dist_install_DATA = plugin_vfd-icons.xml
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	2013-08-11 08:18:50.282295929 +0200
@@ -0,0 +1,20 @@
+<default>
+	<prerequisites>
+		<hardware type="dm8000" />
+		<tag type="System" />
+	</prerequisites>
+	<info>
+		<author>Team Ducktales</author>
+		<name>VFD-Icons</name>
+		<packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		<packagetype>public</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+		<shortdescription>Displays text on vfd</shortdescription>
+		<description>Displays text on vfd.
+		</description>
+	</info>
+
+	<files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-vfd-icons" />
+	</files>
+
+</default>
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	2013-08-11 08:18:50.282295929 +0200
@@ -0,0 +1,152 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()
+
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+
+		print "vfd display text:", servicename[0:63]
+		evfd.getInstance().vfd_write_string(servicename[0:63])
+		return 1
+
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,0)
+
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,0)
+
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,0)
+
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,0)
+
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,0)
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,0)
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-08-11 08:11:19.310306128 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-08-11 08:18:50.282295929 +0200
@@ -67,6 +67,9 @@
 				self.list.append(getConfigListEntry(_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the screen resolution in PC output mode.")))
 			else:
 				self.list.append(getConfigListEntry(_("Refresh rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the refresh rate of the screen.")))
+#+++>
+		self.list.append(getConfigListEntry(_("3D Mode"), config.av.threedmode))
+#+++<
 
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
@@ -90,6 +93,14 @@
 
 #		if config.av.videoport.value == "DVI":
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
 			if level >= 1:
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-08-11 08:11:19.306306129 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-08-11 08:18:50.286295929 +0200
@@ -14,54 +14,35 @@
 
 	modes = { }  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] =			{ "50Hz":	{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
+	rates["PAL"] =			{ "50Hz":	{ 50: "pal" } }
 
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
+	rates["576i"] =			{ "50Hz":	{ 50: "576i50" } }
 
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
+	rates["576p"] =			{ "50Hz":	{ 50: "576p50" } }
 
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
-
-	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" } }
+	rates["720p"] =			{ "50Hz":	{ 50: "720p50" },
+								"60Hz":	{ 60: "720p60" } }
 
 	rates["1080i"] =		{ "50Hz":	{ 50: "1080i50" },
-								"60Hz":		{ 60: "1080i" },
-								"multi":	{ 50: "1080i50", 60: "1080i" } }
+								"60Hz":	{ 60: "1080i60" } }
 
-	rates["1080p"] =		{ "50Hz":	{ 50: "1080p50" },
-								"60Hz":		{ 60: "1080p" },
-								"multi":	{ 50: "1080p50", 60: "1080p" } }
+	rates["1080p"] =		{ "23Hz":	{ 50: "1080p23" },
+								"24Hz":	{ 60: "1080p24" },
+								"25Hz":	{ 60: "1080p25" },
+								"29Hz":	{ 60: "1080p29" },
+								"30Hz":	{ 60: "1080p30" },
+								"50Hz":	{ 60: "1080p50" } }
 
 	rates["PC"] = {
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768"  : { 60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100" }, #43 60 70 72 75 90 100
+		"1280x1024" : { 60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75" }, #43 47 60 70 74 75
+		"1600x1200" : { 60: "1600x1200_60" }, #60 66 76
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI"] = ["720p", "1080p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
+	modes["Scart"] = ["PAL"]
+	modes["Component"] = ["720p", "1080p", "1080i", "576p", "576i"]
+	modes["HDMI"] = ["720p", "1080p", "1080i", "576p", "576i"]
+	modes["HDMI-PC"] = ["PC"]
 
 	def getOutputAspect(self):
 		ret = (16,9)
@@ -109,14 +90,14 @@
 		portlist = self.getPortList()
 		has1080p50 = False
 		for port in portlist:
-			if port == 'DVI' and HardwareInfo().has_hdmi():
+			if port == 'HDMI' and HardwareInfo().has_hdmi():
 				if "1080p50" in self.modes_available:
 					has1080p50 = True
 
 		if has1080p50:
-			self.widescreen_modes = set(["720p", "1080i", "1080p"])
+			self.widescreen_modes = set(["576i", "576p", "720p", "1080i", "1080p"])
 		else:
-			self.widescreen_modes = set(["720p", "1080i"])
+			self.widescreen_modes = set(["576i", "576p", "720p", "1080i"])
 
 		# take over old AVSwitch component :)
 		from Components.AVSwitch import AVSwitch
@@ -125,6 +106,16 @@
 		config.av.wss.notifiers = [ ]
 		AVSwitch.getOutputAspect = self.getOutputAspect
 
+#+++>
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+		config.av.threedmode = ConfigSelection(choices = {"off": _("Off"), "sbs": _("Side by Side"),"tab": _("Top and Bottom")}, default="off")
+		config.av.threedmode.addNotifier(self.set3DMode)
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
+#+++<
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
@@ -156,6 +147,8 @@
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
+			if port == "HDMI-PC":
+				return True
 			if mode not in self.modes_available:
 				return False
 		return True
@@ -192,7 +185,12 @@
 		except IOError:
 			print "writing initial videomode to /etc/videomode failed."
 
+		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
+		from enigma import gMainDC
+		gMainDC.getInstance().setResolution(-1, -1)
+
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
@@ -210,7 +208,8 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+#		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -336,6 +335,33 @@
 		except IOError:
 			pass
 
+#+++>
+	def set3DMode(self, configElement):
+		open("/proc/stb/video/3d_mode", "w").write(configElement.value)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+#+++<
+
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/ChannelSelection.py enigma2-nightly.patched/lib/python/Screens/ChannelSelection.py
--- enigma2-nightly.org/lib/python/Screens/ChannelSelection.py	2013-08-11 08:11:19.314306128 +0200
+++ enigma2-nightly.patched/lib/python/Screens/ChannelSelection.py	2013-08-11 08:54:47.906247142 +0200
@@ -5,6 +5,11 @@
 import Components.ParentalControl
 from Components.Button import Button
 from Components.ServiceList import ServiceList, refreshServiceList
+#+++>
+from Components.Sources.StaticText import StaticText
+from Components.Label import Label
+from os import path as os_path, system, unlink
+#+++<
 from Components.ActionMap import NumberActionMap, ActionMap, HelpableActionMap
 from Components.MenuList import MenuList
 from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
@@ -478,7 +483,9 @@
 		self.__marked = [ ]
 		self.saved_title = None
 		self.saved_root = None
-
+#+++>
+		self["title"] = StaticText()
+#+++<
 		class ChannelSelectionEditActionMap(ActionMap):
 			def __init__(self, csel, contexts = [ ], actions = { }, prio=0):
 				ActionMap.__init__(self, contexts, actions, prio)
@@ -713,6 +720,9 @@
 			else:
 				new_title += ' ' + _("[favourite edit]")
 		self.setTitle(new_title)
+#+++>
+		self["title"].setText(new_title)
+#+++<
 		self.__marked = self.servicelist.getRootServices()
 		for x in self.__marked:
 			self.servicelist.addMarked(eServiceReference(x))
@@ -738,6 +748,9 @@
 		self.bouquet_mark_edit = OFF
 		self.mutableList = None
 		self.setTitle(self.saved_title)
+#+++>
+		self["title"].setText(self.saved_title)
+#+++<
 		self.saved_title = None
 		# self.servicePath is just a reference to servicePathTv or Radio...
 		# so we never ever do use the asignment operator in self.servicePath
@@ -791,6 +804,9 @@
 			self.mutableList.flushChanges() # FIXME add check if changes was made
 			self.mutableList = None
 			self.setTitle(self.saved_title)
+#+++>
+			self["title"].setText(self.saved_title)
+#+++<
 			self.saved_title = None
 			cur_root = self.getRoot()
 			self.servicelist.resetRoot()
@@ -803,6 +819,9 @@
 			pos = self.saved_title.find(')')
 			new_title = self.saved_title[:pos+1] + ' ' + _("[move mode]") + self.saved_title[pos+1:]
 			self.setTitle(new_title);
+#+++>
+			self["title"].setText(new_title)
+#+++<
 		self["Service"].editmode = True
 
 	def handleEditCancel(self):
@@ -855,6 +874,11 @@
 		self["list"] = ServiceList()
 		self.servicelist = self["list"]
 
+#+++>
+		self["boquet"] = Label(_("Channel Selection"))
+		self["title"] = StaticText()
+#+++<
+
 		self.numericalTextInput = NumericalTextInput()
 		self.numericalTextInput.setUseableChars(u'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
 
@@ -939,6 +963,9 @@
 			title = title[:pos]
 		title += _(" (TV)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRadioMode(self):
 		self.mode = MODE_RADIO
@@ -950,6 +977,9 @@
 			title = title[:pos]
 		title += _(" (Radio)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRoot(self, root, justSet=False):
 		if self.startRoot is None:
@@ -1005,6 +1035,9 @@
 					end_ref = None
 				nameStr = self.getServiceName(base_ref)
 				titleStr += ' - ' + nameStr
+#+++>
+				self["boquet"].setText("Channel Selection")
+#+++<
 				if end_ref is not None:
 					if Len > 2:
 						titleStr += '/../'
@@ -1012,7 +1045,13 @@
 						titleStr += '/'
 					nameStr = self.getServiceName(end_ref)
 					titleStr += nameStr
+#+++>
+					self["boquet"].setText(nameStr)
+#+++<
 				self.setTitle(titleStr)
+#+++>
+				self["title"].setText(titleStr)
+#+++<
 
 	def moveUp(self):
 		self.servicelist.moveUp()
@@ -1902,6 +1941,9 @@
 
 	def layoutFinished(self):
 		self.setModeTv()
+#+++>
+		self["title"].setText(self.title)
+#+++<
 
 	def channelSelected(self): # just return selected service
 		ref = self.getCurrentSelection()
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/ChannelSelection.py~ enigma2-nightly.patched/lib/python/Screens/ChannelSelection.py~
--- enigma2-nightly.org/lib/python/Screens/ChannelSelection.py~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Screens/ChannelSelection.py~	2013-08-11 08:18:50.290295930 +0200
@@ -0,0 +1,1958 @@
+from Tools.Profile import profile
+
+from Screen import Screen
+import Screens.InfoBar
+import Components.ParentalControl
+from Components.Button import Button
+from Components.ServiceList import ServiceList, refreshServiceList
+from Components.ActionMap import NumberActionMap, ActionMap, HelpableActionMap
+from Components.MenuList import MenuList
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from Components.SystemInfo import SystemInfo
+profile("ChannelSelection.py 1")
+from EpgSelection import EPGSelection
+from enigma import eServiceReference, eEPGCache, eServiceCenter, eRCInput, eTimer, eDVBDB, iPlayableService, iServiceInformation, getPrevAsciiCode, eEnv
+from Components.config import config, configfile, ConfigSubsection, ConfigText
+from Tools.NumericalTextInput import NumericalTextInput
+profile("ChannelSelection.py 2")
+from Components.NimManager import nimmanager
+profile("ChannelSelection.py 2.1")
+from Components.Sources.RdsDecoder import RdsDecoder
+profile("ChannelSelection.py 2.2")
+from Components.Sources.ServiceEvent import ServiceEvent
+from Components.Sources.Event import Event
+profile("ChannelSelection.py 2.3")
+from Components.Input import Input
+profile("ChannelSelection.py 3")
+from Components.ChoiceList import ChoiceList, ChoiceEntryComponent
+from Components.SystemInfo import SystemInfo
+from Screens.InputBox import InputBox, PinInput
+from Screens.VirtualKeyBoard import VirtualKeyBoard
+from Screens.MessageBox import MessageBox
+from Screens.ServiceInfo import ServiceInfo
+profile("ChannelSelection.py 4")
+from Screens.PictureInPicture import PictureInPicture
+from Screens.RdsDisplay import RassInteractive
+from ServiceReference import ServiceReference
+from Tools.BoundFunction import boundFunction
+from Tools import Notifications
+from os import remove
+profile("ChannelSelection.py after imports")
+
+FLAG_SERVICE_NEW_FOUND = 64 #define in lib/dvb/idvb.h as dxNewFound = 64
+
+class BouquetSelector(Screen):
+	def __init__(self, session, bouquets, selectedFunc, enableWrapAround=False):
+		Screen.__init__(self, session)
+
+		self.selectedFunc=selectedFunc
+
+		self["actions"] = ActionMap(["OkCancelActions"],
+			{
+				"ok": self.okbuttonClick,
+				"cancel": self.cancelClick
+			})
+		entrys = [ (x[0], x[1]) for x in bouquets ]
+		self["menu"] = MenuList(entrys, enableWrapAround)
+
+	def getCurrent(self):
+		cur = self["menu"].getCurrent()
+		return cur and cur[1]
+
+	def okbuttonClick(self):
+		self.selectedFunc(self.getCurrent())
+
+	def up(self):
+		self["menu"].up()
+
+	def down(self):
+		self["menu"].down()
+
+	def cancelClick(self):
+		self.close(False)
+
+class SilentBouquetSelector:
+	def __init__(self, bouquets, enableWrapAround=False, current=0):
+		self.bouquets = [b[1] for b in bouquets]
+		self.pos = current
+		self.count = len(bouquets)
+		self.enableWrapAround = enableWrapAround
+
+	def up(self):
+		if self.pos > 0 or self.enableWrapAround:
+			self.pos = (self.pos - 1) % self.count
+
+	def down(self):
+		if self.pos < (self.count - 1) or self.enableWrapAround:
+			self.pos = (self.pos + 1) % self.count
+
+	def getCurrent(self):
+		return self.bouquets[self.pos]
+
+# csel.bouquet_mark_edit values
+OFF = 0
+EDIT_BOUQUET = 1
+EDIT_ALTERNATIVES = 2
+
+def append_when_current_valid(current, menu, args, level = 0, key = ""):
+	if current and current.valid() and level <= config.usage.setup_level.index:
+		menu.append(ChoiceEntryComponent(key, args))
+
+class ChannelContextMenu(Screen):
+	def __init__(self, session, csel):
+
+		Screen.__init__(self, session)
+		#raise Exception("we need a better summary screen here")
+		self.csel = csel
+		self.bsel = None
+
+		self["actions"] = ActionMap(["OkCancelActions", "ColorActions", "NumberActions"],
+			{
+				"ok": self.okbuttonClick,
+				"cancel": self.cancelClick,
+				"blue": self.showServiceInPiP
+			})
+		menu = [ ]
+
+		self.pipAvailable = False
+		current = csel.getCurrentSelection()
+		current_root = csel.getRoot()
+		current_sel_path = current.getPath()
+		current_sel_flags = current.flags
+		inBouquetRootList = current_root and current_root.getPath().find('FROM BOUQUET "bouquets.') != -1 #FIXME HACK
+		inBouquet = csel.getMutableList() is not None
+		haveBouquets = config.usage.multibouquet.value
+
+		if not (current_sel_path or current_sel_flags & (eServiceReference.isDirectory|eServiceReference.isMarker)):
+			append_when_current_valid(current, menu, (_("show transponder info"), self.showServiceInformations), level = 2)
+		if csel.bouquet_mark_edit == OFF and not csel.movemode:
+			if not inBouquetRootList:
+				isPlayable = not (current_sel_flags & (eServiceReference.isMarker|eServiceReference.isDirectory))
+				if isPlayable:
+					if config.servicelist.startupservice.value == self.csel.getCurrentSelection().toString():
+						append_when_current_valid(current, menu, (_("stop using as startup service"), self.unsetStartupService), level = 0)
+					else:
+						append_when_current_valid(current, menu, (_("set as startup service"), self.setStartupService), level = 0)
+					if config.ParentalControl.configured.value:
+						from Components.ParentalControl import parentalControl
+						if parentalControl.getProtectionLevel(csel.getCurrentSelection().toCompareString()) == -1:
+							append_when_current_valid(current, menu, (_("add to parental protection"), boundFunction(self.addParentalProtection, csel.getCurrentSelection())), level = 0)
+						else:
+							append_when_current_valid(current, menu, (_("remove from parental protection"), boundFunction(self.removeParentalProtection, csel.getCurrentSelection())), level = 0)
+					if haveBouquets:
+						bouquets = self.csel.getBouquetList()
+						if bouquets is None:
+							bouquetCnt = 0
+						else:
+							bouquetCnt = len(bouquets)
+						if not inBouquet or bouquetCnt > 1:
+							append_when_current_valid(current, menu, (_("add service to bouquet"), self.addServiceToBouquetSelected), level = 0)
+					else:
+						if not inBouquet:
+							append_when_current_valid(current, menu, (_("add service to favourites"), self.addServiceToBouquetSelected), level = 0)
+
+					if SystemInfo.get("NumVideoDecoders", 1) > 1:
+						# only allow the service to be played directly in pip / mainwindow when the service is not under parental control
+						if not config.ParentalControl.configured.value or parentalControl.getProtectionLevel(csel.getCurrentSelection().toCompareString()) == -1:
+							if not csel.dopipzap:
+								append_when_current_valid(current, menu, (_("play as picture in picture"), self.showServiceInPiP), level = 0, key = "blue")
+								self.pipAvailable = True
+							else:
+								append_when_current_valid(current, menu, (_("play in mainwindow"), self.playMain), level = 0)
+				else:
+					if current_root.getPath().find('FROM SATELLITES') != -1:
+						append_when_current_valid(current, menu, (_("remove selected satellite"), self.removeSatelliteServices), level = 0)
+					if haveBouquets:
+						if not inBouquet and current_sel_path.find("PROVIDERS") == -1:
+							append_when_current_valid(current, menu, (_("copy to bouquets"), self.copyCurrentToBouquetList), level = 0)
+					if current_sel_path.find("flags == %d" %(FLAG_SERVICE_NEW_FOUND)) != -1:
+						append_when_current_valid(current, menu, (_("remove all new found flags"), self.removeAllNewFoundFlags), level = 0)
+				if inBouquet:
+					append_when_current_valid(current, menu, (_("rename entry"), self.renameEntry), level = 0)					
+					append_when_current_valid(current, menu, (_("remove entry"), self.removeCurrentService), level = 0)
+				if current_root and current_root.getPath().find("flags == %d" %(FLAG_SERVICE_NEW_FOUND)) != -1:
+					append_when_current_valid(current, menu, (_("remove new found flag"), self.removeNewFoundFlag), level = 0)
+			else:
+					menu.append(ChoiceEntryComponent(text = (_("add bouquet"), self.showBouquetInputBox)))
+					append_when_current_valid(current, menu, (_("rename entry"), self.renameEntry), level = 0)
+					append_when_current_valid(current, menu, (_("remove entry"), self.removeBouquet), level = 0)
+
+		if inBouquet: # current list is editable?
+			if csel.bouquet_mark_edit == OFF:
+				if not csel.movemode:
+					append_when_current_valid(current, menu, (_("enable move mode"), self.toggleMoveMode), level = 1)
+					if not inBouquetRootList and current_root and not (current_root.flags & eServiceReference.isGroup):
+						menu.append(ChoiceEntryComponent(text = (_("add marker"), self.showMarkerInputBox)))
+						if haveBouquets:
+							append_when_current_valid(current, menu, (_("enable bouquet edit"), self.bouquetMarkStart), level = 0)
+						else:
+							append_when_current_valid(current, menu, (_("enable favourite edit"), self.bouquetMarkStart), level = 0)
+						if current_sel_flags & eServiceReference.isGroup:
+							append_when_current_valid(current, menu, (_("edit alternatives"), self.editAlternativeServices), level = 2)
+							append_when_current_valid(current, menu, (_("show alternatives"), self.showAlternativeServices), level = 2)
+							append_when_current_valid(current, menu, (_("remove all alternatives"), self.removeAlternativeServices), level = 2)
+						elif not current_sel_flags & eServiceReference.isMarker:
+							append_when_current_valid(current, menu, (_("add alternatives"), self.addAlternativeServices), level = 2)
+				else:
+					append_when_current_valid(current, menu, (_("disable move mode"), self.toggleMoveMode), level = 0)
+			else:
+				if csel.bouquet_mark_edit == EDIT_BOUQUET:
+					if haveBouquets:
+						append_when_current_valid(current, menu, (_("end bouquet edit"), self.bouquetMarkEnd), level = 0)
+						append_when_current_valid(current, menu, (_("abort bouquet edit"), self.bouquetMarkAbort), level = 0)
+					else:
+						append_when_current_valid(current, menu, (_("end favourites edit"), self.bouquetMarkEnd), level = 0)
+						append_when_current_valid(current, menu, (_("abort favourites edit"), self.bouquetMarkAbort), level = 0)
+					if current_sel_flags & eServiceReference.isMarker:	
+						append_when_current_valid(current, menu, (_("rename entry"), self.renameEntry), level = 0)
+						append_when_current_valid(current, menu, (_("remove entry"), self.removeCurrentService), level = 0)
+				else:
+					append_when_current_valid(current, menu, (_("end alternatives edit"), self.bouquetMarkEnd), level = 0)
+					append_when_current_valid(current, menu, (_("abort alternatives edit"), self.bouquetMarkAbort), level = 0)
+
+		menu.append(ChoiceEntryComponent(text = (_("Configuration..."), boundFunction(self.openSetup, "userinterface"))))
+		self["menu"] = ChoiceList(menu)
+
+	def playMain(self):
+		# XXX: we want to keep the current selection
+		sel = self.csel.getCurrentSelection()
+		self.csel.zap()
+		self.csel.setCurrentSelection(sel)
+		self.close()
+
+	def okbuttonClick(self):
+		self["menu"].getCurrent()[0][1]()
+
+	def openSetup(self, key):
+		from Screens.Setup import Setup
+		self.session.open(Setup, key)
+
+	def cancelClick(self):
+		self.close(False)
+
+	def showServiceInformations(self):
+		self.session.open( ServiceInfo, self.csel.getCurrentSelection() )
+
+	def setStartupService(self):
+		config.servicelist.startupservice.value = self.csel.getCurrentSelection().toString()
+		path = ';'.join([i.toString() for i in self.csel.servicePath])
+		config.servicelist.startuproot.value = path
+		config.servicelist.startupmode.value = config.servicelist.lastmode.value
+		config.servicelist.save()
+		configfile.save()
+		self.close()
+
+	def unsetStartupService(self):
+		config.servicelist.startupservice.value = ''
+		config.servicelist.save()
+		configfile.save()
+		self.close()
+
+	def showBouquetInputBox(self):
+		self.session.openWithCallback(self.bouquetInputCallback, InputBox, title=_("Please enter a name for the new bouquet"), text="bouquetname", maxSize=False, visible_width = 56, type=Input.TEXT)
+
+	def bouquetInputCallback(self, bouquet):
+		if bouquet is not None:
+			self.csel.addBouquet(bouquet, None)
+		self.close()
+
+	def addParentalProtection(self, service):
+		from Components.ParentalControl import parentalControl
+		parentalControl.protectService(service.toCompareString())
+		self.close()
+
+	def removeParentalProtection(self, service):
+		self.session.openWithCallback(boundFunction(self.pinEntered, service.toCompareString()), PinInput, pinList = [config.ParentalControl.servicepin[0].value], triesEntry = config.ParentalControl.retries.servicepin, title = _("Enter the service pin"), windowTitle = _("Change pin code"))
+
+	def pinEntered(self, service, result):
+		if result:
+			from Components.ParentalControl import parentalControl
+			parentalControl.unProtectService(service)
+			self.close()
+		else:
+			self.session.openWithCallback(self.close, MessageBox, _("The pin code you entered is wrong."), MessageBox.TYPE_ERROR)
+			
+	def showServiceInPiP(self):
+		if not self.pipAvailable:
+			return
+		if self.session.pipshown:
+			del self.session.pip
+		self.session.pip = self.session.instantiateDialog(PictureInPicture)
+		self.session.pip.show()
+		newservice = self.csel.servicelist.getCurrent()
+		if self.session.pip.playService(newservice):
+			self.session.pipshown = True
+			self.session.pip.servicePath = self.csel.getCurrentServicePath()
+			self.close(True)
+		else:
+			self.session.pipshown = False
+			del self.session.pip
+			self.session.openWithCallback(self.close, MessageBox, _("Could not open Picture in Picture"), MessageBox.TYPE_ERROR)
+
+	def addServiceToBouquetSelected(self):
+		bouquets = self.csel.getBouquetList()
+		if bouquets is None:
+			cnt = 0
+		else:
+			cnt = len(bouquets)
+		if cnt > 1: # show bouquet list
+			self.bsel = self.session.openWithCallback(self.bouquetSelClosed, BouquetSelector, bouquets, self.addCurrentServiceToBouquet)
+		elif cnt == 1: # add to only one existing bouquet
+			self.addCurrentServiceToBouquet(bouquets[0][1], closeBouquetSelection = False)
+
+	def bouquetSelClosed(self, recursive):
+		self.bsel = None
+		if recursive:
+			self.close(False)
+
+	def removeSatelliteServices(self):
+		curpath = self.csel.getCurrentSelection().getPath()
+		idx = curpath.find("satellitePosition == ")
+		if idx != -1:
+			tmp = curpath[idx+21:]
+			idx = tmp.find(')')
+			if idx != -1:
+				satpos = int(tmp[:idx])
+				eDVBDB.getInstance().removeServices(-1, -1, -1, satpos)
+		self.close()
+
+	def copyCurrentToBouquetList(self):
+		self.csel.copyCurrentToBouquetList()
+		self.close()
+
+	def removeBouquet(self):
+		self.csel.removeBouquet()
+		eDVBDB.getInstance().reloadBouquets()
+		self.close()
+
+	def showMarkerInputBox(self):
+		self.session.openWithCallback(self.markerInputCallback, InputBox, title=_("Please enter a name for the new marker"), text="markername", maxSize=False, visible_width = 56, type=Input.TEXT)
+
+	def markerInputCallback(self, marker):
+		if marker is not None:
+			self.csel.addMarker(marker)
+		self.close()
+
+	def addCurrentServiceToBouquet(self, dest, closeBouquetSelection = True):
+		self.csel.addServiceToBouquet(dest)
+		if self.bsel is not None:
+			self.bsel.close(True)
+		else:
+			self.close(closeBouquetSelection) # close bouquet selection
+
+	def removeCurrentService(self):
+		self.csel.removeCurrentService()
+		self.close()
+
+	def renameEntry(self):
+		self.csel.renameEntry()
+		self.close()
+
+	def toggleMoveMode(self):
+		self.csel.toggleMoveMode()
+		self.close()
+
+	def bouquetMarkStart(self):
+		self.csel.startMarkedEdit(EDIT_BOUQUET)
+		self.close()
+
+	def bouquetMarkEnd(self):
+		self.csel.endMarkedEdit(abort=False)
+		self.close()
+
+	def bouquetMarkAbort(self):
+		self.csel.endMarkedEdit(abort=True)
+		self.close()
+
+	def removeNewFoundFlag(self):
+		eDVBDB.getInstance().removeFlag(self.csel.getCurrentSelection(), FLAG_SERVICE_NEW_FOUND)
+		self.close()
+
+	def removeAllNewFoundFlags(self):
+		curpath = self.csel.getCurrentSelection().getPath()
+		idx = curpath.find("satellitePosition == ")
+		if idx != -1:
+			tmp = curpath[idx+21:]
+			idx = tmp.find(')')
+			if idx != -1:
+				satpos = int(tmp[:idx])
+				eDVBDB.getInstance().removeFlags(FLAG_SERVICE_NEW_FOUND, -1, -1, -1, satpos)
+		self.close()
+
+	def editAlternativeServices(self):
+		self.csel.startMarkedEdit(EDIT_ALTERNATIVES)
+		self.close()
+
+	def showAlternativeServices(self):
+		self.csel["Service"].editmode = True
+		self.csel.enterPath(self.csel.getCurrentSelection())
+		self.close()
+
+	def removeAlternativeServices(self):
+		self.csel.removeAlternativeServices()
+		self.close()
+
+	def addAlternativeServices(self):
+		self.csel.addAlternativeServices()
+		self.csel.startMarkedEdit(EDIT_ALTERNATIVES)
+		self.close()
+
+class SelectionEventInfo:
+	def __init__(self):
+		self["Service"] = self["ServiceEvent"] = ServiceEvent()
+		self["Event"] = Event()
+		self.servicelist.connectSelChanged(self.__selectionChanged)
+		self.timer = eTimer()
+		self.timer.callback.append(self.updateEventInfo)
+		self.onShown.append(self.__selectionChanged)
+
+	def __selectionChanged(self):
+		if self.execing:
+			self.timer.start(100, True)
+
+	def updateEventInfo(self):
+		cur = self.getCurrentSelection()
+		service = self["Service"]
+		service.newService(cur)
+		self["Event"].newEvent(service.event)
+
+class ChannelSelectionEPG:
+	def __init__(self):
+		self["ChannelSelectEPGActions"] = ActionMap(["ChannelSelectEPGActions"],
+			{
+				"showEPGList": self.showEPGList,
+			})
+		self.epg_bouquet = None
+
+	def showEPGList(self):
+		ref=self.getCurrentSelection()
+		if ref:
+			self.epg_bouquet = self.servicelist.getRoot()
+			self.savedService = ref
+			self.session.openWithCallback(self.SingleServiceEPGClosed, EPGSelection, ref, self.zapToService, serviceChangeCB=self.changeServiceCB)
+
+	def SingleServiceEPGClosed(self, ret=False):
+		if ret:
+			service = self.getCurrentSelection()
+			if service is not None:
+				self.close()
+		else:
+			self.setCurrentSelection(self.savedService)
+
+	def changeServiceCB(self, direction, epg):
+		beg = self.getCurrentSelection()
+		while True:
+			if direction > 0:
+				self.moveDown()
+			else:
+				self.moveUp()
+			cur = self.getCurrentSelection()
+			if cur == beg or not (cur.flags & eServiceReference.isMarker):
+				break
+		epg.setService(ServiceReference(self.getCurrentSelection()))
+
+	def zapToService(self, service, preview = False, zapback = False):
+		if self.startServiceRef is None:
+			self.startServiceRef = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		if service is not None:
+			if self.servicelist.getRoot() != self.epg_bouquet:
+				self.servicelist.clearPath()
+				if self.servicelist.bouquet_root != self.epg_bouquet:
+					self.servicelist.enterPath(self.servicelist.bouquet_root)
+				self.servicelist.enterPath(self.epg_bouquet)
+			self.servicelist.setCurrent(service)
+		if not zapback or preview:
+			self.zap(enable_pipzap = True)
+		if (self.dopipzap or zapback) and not preview:
+			self.zapBack()
+		if not preview:
+			self.startServiceRef = None
+			self.startRoot = None
+
+class ChannelSelectionEdit:
+	def __init__(self):
+		self.entry_marked = False
+		self.movemode = False
+		self.bouquet_mark_edit = OFF
+		self.mutableList = None
+		self.__marked = [ ]
+		self.saved_title = None
+		self.saved_root = None
+#+++>
+		self["title"] = StaticText()
+#+++<
+		class ChannelSelectionEditActionMap(ActionMap):
+			def __init__(self, csel, contexts = [ ], actions = { }, prio=0):
+				ActionMap.__init__(self, contexts, actions, prio)
+				self.csel = csel
+
+			def action(self, contexts, action):
+				if action == "cancel":
+					self.csel.handleEditCancel()
+					return 0 # fall-trough
+				elif action == "ok":
+					return 0 # fall-trough
+				else:
+					return ActionMap.action(self, contexts, action)
+
+		self["ChannelSelectEditActions"] = ChannelSelectionEditActionMap(self, ["ChannelSelectEditActions", "OkCancelActions"],
+			{
+				"contextMenu": self.doContext,
+			})
+
+	def getMutableList(self, root=eServiceReference()):
+		if not self.mutableList is None:
+			return self.mutableList
+		serviceHandler = eServiceCenter.getInstance()
+		if not root.valid():
+			root=self.getRoot()
+		list = root and serviceHandler.list(root)
+		if list is not None:
+			return list.startEdit()
+		return None
+
+	def buildBouquetID(self, str):
+		tmp = str.lower()
+		name = ''
+		for c in tmp:
+			if (c >= 'a' and c <= 'z') or (c >= '0' and c <= '9'):
+				name += c
+			else:
+				name += '_'
+		return name
+
+	def renameEntry(self):
+		cur = self.getCurrentSelection()
+		name = eServiceCenter.getInstance().info(cur).getName(cur) or ServiceReference(cur).getServiceName() or ""
+		name.replace('\xc2\x86', '').replace('\xc2\x87', '')
+		if name:
+			self.session.openWithCallback(self.renameEntryCallback, VirtualKeyBoard, title=_("Please enter new name:"), text=name)
+
+	def renameEntryCallback(self, name):
+		if name:
+			current = self.servicelist.getCurrent()
+			if (current.flags & eServiceReference.mustDescent):
+				mutableList = self.getMutableList(current)
+				mutableList.setListName(name)
+				mutableList.flushChanges()
+			else:
+				end = self.atEnd()
+				if (current.flags & eServiceReference.isMarker):
+					self.addMarker(name)
+					mutableList = self.getMutableList()
+					mutableList.removeService(current)
+					mutableList.flushChanges()
+					self.servicelist.removeCurrent()
+				else:
+					sRef = current.toCompareString()
+					ref = eServiceReference(sRef)
+					ref.setName(name)
+					mutableList = self.getMutableList()
+					mutableList.removeService(current)
+					self.servicelist.removeCurrent()
+					if end:
+						if not mutableList.addService(ref):
+							self.servicelist.addService(ref, False)
+							self.moveDown()
+					else:
+						cur = self.servicelist.getCurrent()
+						if not mutableList.addService(ref, cur):
+							self.servicelist.addService(ref, True)
+					mutableList.flushChanges()
+				refreshServiceList()
+				self.servicelist.setCurrent(current)
+
+	def addMarker(self, name):
+		current = self.servicelist.getCurrent()
+		mutableList = self.getMutableList()
+		cnt = 0
+		while mutableList:
+			str = '1:64:%d:0:0:0:0:0:0:0::%s'%(cnt, name)
+			ref = eServiceReference(str)
+			if current and current.valid():
+				if not mutableList.addService(ref, current):
+					self.servicelist.addService(ref, True)
+					mutableList.flushChanges()
+					break
+			elif not mutableList.addService(ref):
+				self.servicelist.addService(ref, True)
+				mutableList.flushChanges()
+				break
+			cnt+=1
+
+	def addAlternativeServices(self):
+		cur_service = ServiceReference(self.getCurrentSelection())
+		root = self.getRoot()
+		cur_root = root and ServiceReference(root)
+		mutableBouquet = cur_root.list().startEdit()
+		if mutableBouquet:
+			name = cur_service.getServiceName()
+			print "NAME", name
+			if self.mode == MODE_TV:
+				str = '1:134:1:0:0:0:0:0:0:0:FROM BOUQUET \"alternatives.%s.tv\" ORDER BY bouquet'%(self.buildBouquetID(name))
+			else:
+				str = '1:134:2:0:0:0:0:0:0:0:FROM BOUQUET \"alternatives.%s.radio\" ORDER BY bouquet'%(self.buildBouquetID(name))
+			new_ref = ServiceReference(str)
+			if not mutableBouquet.addService(new_ref.ref, cur_service.ref):
+				mutableBouquet.removeService(cur_service.ref)
+				mutableBouquet.flushChanges()
+				eDVBDB.getInstance().reloadBouquets()
+				mutableAlternatives = new_ref.list().startEdit()
+				if mutableAlternatives:
+					mutableAlternatives.setListName(name)
+					if mutableAlternatives.addService(cur_service.ref):
+						print "add", cur_service.ref.toString(), "to new alternatives failed"
+					mutableAlternatives.flushChanges()
+					self.servicelist.addService(new_ref.ref, True)
+					self.servicelist.removeCurrent()
+					self.servicelist.moveUp()
+				else:
+					print "get mutable list for new created alternatives failed"
+			else:
+				print "add", str, "to", cur_root.getServiceName(), "failed"
+		else:
+			print "bouquetlist is not editable"
+
+	def addBouquet(self, bName, services):
+		serviceHandler = eServiceCenter.getInstance()
+		mutableBouquetList = serviceHandler.list(self.bouquet_root).startEdit()
+		if mutableBouquetList:
+			if self.mode == MODE_TV:
+				bName += _(" (TV)")
+				str = '1:7:1:0:0:0:0:0:0:0:FROM BOUQUET \"userbouquet.%s.tv\" ORDER BY bouquet'%(self.buildBouquetID(bName))
+			else:
+				bName += _(" (Radio)")
+				str = '1:7:2:0:0:0:0:0:0:0:FROM BOUQUET \"userbouquet.%s.radio\" ORDER BY bouquet'%(self.buildBouquetID(bName))
+			new_bouquet_ref = eServiceReference(str)
+			if not mutableBouquetList.addService(new_bouquet_ref):
+				mutableBouquetList.flushChanges()
+				eDVBDB.getInstance().reloadBouquets()
+				mutableBouquet = serviceHandler.list(new_bouquet_ref).startEdit()
+				if mutableBouquet:
+					mutableBouquet.setListName(bName)
+					if services is not None:
+						for service in services:
+							if mutableBouquet.addService(service):
+								print "add", service.toString(), "to new bouquet failed"
+					mutableBouquet.flushChanges()
+				else:
+					print "get mutable list for new created bouquet failed"
+				# do some voodoo to check if current_root is equal to bouquet_root
+				cur_root = self.getRoot();
+				str1 = cur_root and cur_root.toString()
+				pos1 = str1 and str1.find("FROM BOUQUET") or -1
+				pos2 = self.bouquet_rootstr.find("FROM BOUQUET")
+				if pos1 != -1 and pos2 != -1 and str1[pos1:] == self.bouquet_rootstr[pos2:]:
+					self.servicelist.addService(new_bouquet_ref)
+					self.servicelist.resetRoot()
+			else:
+				print "add", str, "to bouquets failed"
+		else:
+			print "bouquetlist is not editable"
+
+	def copyCurrentToBouquetList(self):
+		provider = ServiceReference(self.getCurrentSelection())
+		providerName = provider.getServiceName()
+		serviceHandler = eServiceCenter.getInstance()
+		services = serviceHandler.list(provider.ref)
+		self.addBouquet(providerName, services and services.getContent('R', True))
+
+	def removeAlternativeServices(self):
+		cur_service = ServiceReference(self.getCurrentSelection())
+		root = self.getRoot()
+		cur_root = root and ServiceReference(root)
+		list = cur_service.list()
+		first_in_alternative = list and list.getNext()
+		if first_in_alternative:
+			edit_root = cur_root and cur_root.list().startEdit()
+			if edit_root:
+				if not edit_root.addService(first_in_alternative, cur_service.ref):
+					self.servicelist.addService(first_in_alternative, True)
+				else:
+					print "couldn't add first alternative service to current root"
+			else:
+				print "couldn't edit current root!!"
+		else:
+			print "remove empty alternative list !!"
+		self.removeBouquet()
+		self.servicelist.moveUp()
+
+	def removeBouquet(self):
+		refstr = self.getCurrentSelection().toString()
+		print "removeBouquet", refstr
+		pos = refstr.find('FROM BOUQUET "')
+		filename = None
+		if pos != -1:
+			refstr = refstr[pos+14:]
+			pos = refstr.find('"')
+			if pos != -1:
+				filename = eEnv.resolve('${sysconfdir}/enigma2/') + refstr[:pos]
+		self.removeCurrentService()
+		try:
+			if filename is not None:
+				remove(filename)
+		except OSError:
+			print "error during remove of", filename
+
+#  multiple marked entry stuff ( edit mode, later multiepg selection )
+	def startMarkedEdit(self, type):
+		self.savedPath = self.servicePath[:]
+		if type == EDIT_ALTERNATIVES:
+			self.enterPath(self.getCurrentSelection())
+		self.mutableList = self.getMutableList()
+		# add all services from the current list to internal marked set in listboxservicecontent
+		self.clearMarks() # this clears the internal marked set in the listboxservicecontent
+		self.saved_title = self.getTitle()
+		pos = self.saved_title.find(')')
+		new_title = self.saved_title[:pos+1]
+		if type == EDIT_ALTERNATIVES:
+			self.bouquet_mark_edit = EDIT_ALTERNATIVES
+			new_title += ' ' + _("[alternative edit]")
+		else:
+			self.bouquet_mark_edit = EDIT_BOUQUET
+			if config.usage.multibouquet.value:
+				new_title += ' ' + _("[bouquet edit]")
+			else:
+				new_title += ' ' + _("[favourite edit]")
+		self.setTitle(new_title)
+#+++>
+		self["title"].setText(new_title)
+#+++<
+		self.__marked = self.servicelist.getRootServices()
+		for x in self.__marked:
+			self.servicelist.addMarked(eServiceReference(x))
+		self["Service"].editmode = True
+
+	def endMarkedEdit(self, abort):
+		if not abort and self.mutableList is not None:
+			new_marked = set(self.servicelist.getMarked())
+			old_marked = set(self.__marked)
+			removed = old_marked - new_marked
+			added = new_marked - old_marked
+			changed = False
+			for x in removed:
+				changed = True
+				self.mutableList.removeService(eServiceReference(x))
+			for x in added:
+				changed = True
+				self.mutableList.addService(eServiceReference(x))
+			if changed:
+				self.mutableList.flushChanges()
+		self.__marked = []
+		self.clearMarks()
+		self.bouquet_mark_edit = OFF
+		self.mutableList = None
+		self.setTitle(self.saved_title)
+#+++>
+		self["title"].setText(self.saved_title)
+#+++<
+		self.saved_title = None
+		# self.servicePath is just a reference to servicePathTv or Radio...
+		# so we never ever do use the asignment operator in self.servicePath
+		del self.servicePath[:] # remove all elements
+		self.servicePath += self.savedPath # add saved elements
+		del self.savedPath
+		self.setRoot(self.servicePath[-1])
+
+	def clearMarks(self):
+		self.servicelist.clearMarks()
+
+	def doMark(self):
+		ref = self.servicelist.getCurrent()
+		if self.servicelist.isMarked(ref):
+			self.servicelist.removeMarked(ref)
+		else:
+			self.servicelist.addMarked(ref)
+
+	def removeCurrentService(self):
+		ref = self.servicelist.getCurrent()
+		mutableList = self.getMutableList()
+		if ref.valid() and mutableList is not None:
+			if not mutableList.removeService(ref):
+				mutableList.flushChanges() #FIXME dont flush on each single removed service
+				self.servicelist.removeCurrent()
+				self.servicelist.resetRoot()
+
+	def addServiceToBouquet(self, dest, service=None):
+		mutableList = self.getMutableList(dest)
+		if not mutableList is None:
+			if service is None: #use current selected service
+				service = self.servicelist.getCurrent()
+			if not mutableList.addService(service):
+				mutableList.flushChanges()
+				# do some voodoo to check if current_root is equal to dest
+				cur_root = self.getRoot();
+				str1 = cur_root and cur_root.toString() or -1
+				str2 = dest.toString()
+				pos1 = str1.find("FROM BOUQUET")
+				pos2 = str2.find("FROM BOUQUET")
+				if pos1 != -1 and pos2 != -1 and str1[pos1:] == str2[pos2:]:
+					self.servicelist.addService(service)
+				self.servicelist.resetRoot()
+
+	def toggleMoveMode(self):
+		if self.movemode:
+			if self.entry_marked:
+				self.toggleMoveMarked() # unmark current entry
+			self.movemode = False
+			self.pathChangeDisabled = False # re-enable path change
+			self.mutableList.flushChanges() # FIXME add check if changes was made
+			self.mutableList = None
+			self.setTitle(self.saved_title)
+#+++>
+			self["title"].setText(self.saved_title)
+#+++<
+			self.saved_title = None
+			cur_root = self.getRoot()
+			self.servicelist.resetRoot()
+		else:
+			self.mutableList = self.getMutableList()
+			self.movemode = True
+			self.pathChangeDisabled = True # no path change allowed in movemode
+			self.saved_title = self.getTitle()
+			new_title = self.saved_title
+			pos = self.saved_title.find(')')
+			new_title = self.saved_title[:pos+1] + ' ' + _("[move mode]") + self.saved_title[pos+1:]
+			self.setTitle(new_title);
+#+++>
+			self["title"].setText(new_title)
+#+++<
+		self["Service"].editmode = True
+
+	def handleEditCancel(self):
+		if self.movemode: #movemode active?
+			self.channelSelected() # unmark
+			self.toggleMoveMode() # disable move mode
+		elif self.bouquet_mark_edit != OFF:
+			self.endMarkedEdit(True) # abort edit mode
+
+	def toggleMoveMarked(self):
+		if self.entry_marked:
+			self.servicelist.setCurrentMarked(False)
+			self.entry_marked = False
+		else:
+			self.servicelist.setCurrentMarked(True)
+			self.entry_marked = True
+
+	def doContext(self):
+		self.session.openWithCallback(self.exitContext, ChannelContextMenu, self)
+		
+	def exitContext(self, close = False):
+		if close:
+			self.cancel()
+
+MODE_TV = 0
+MODE_RADIO = 1
+
+# type 1 = digital television service
+# type 4 = nvod reference service (NYI)
+# type 17 = MPEG-2 HD digital television service
+# type 22 = advanced codec SD digital television
+# type 24 = advanced codec SD NVOD reference service (NYI)
+# type 25 = advanced codec HD digital television
+# type 27 = advanced codec HD NVOD reference service (NYI)
+# type 2 = digital radio sound service
+# type 10 = advanced codec digital radio sound service
+
+service_types_tv = '1:7:1:0:0:0:0:0:0:0:(type == 1) || (type == 17) || (type == 22) || (type == 25) || (type == 134) || (type == 195)'
+service_types_radio = '1:7:2:0:0:0:0:0:0:0:(type == 2) || (type == 10)'
+
+class ChannelSelectionBase(Screen):
+	def __init__(self, session):
+		Screen.__init__(self, session)
+
+		self["key_red"] = Button(_("All"))
+		self["key_green"] = Button(_("Satellites"))
+		self["key_yellow"] = Button(_("Provider"))
+		self["key_blue"] = Button(_("Favourites"))
+
+		self["list"] = ServiceList()
+		self.servicelist = self["list"]
+
+#+++>
+		self["boquet"] = Label(_("Channel Selection"))
+		self["title"] = StaticText()
+#+++<
+
+		self.numericalTextInput = NumericalTextInput()
+		self.numericalTextInput.setUseableChars(u'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
+
+		self.servicePathTV = [ ]
+		self.servicePathRadio = [ ]
+		self.servicePath = [ ]
+		self.history = [ ]
+		self.rootChanged = False
+		self.startRoot = None
+
+		self.mode = MODE_TV
+		self.dopipzap = False
+
+		self.pathChangeDisabled = False
+
+		self["ChannelSelectBaseActions"] = NumberActionMap(["ChannelSelectBaseActions", "NumberActions", "InputAsciiActions"],
+			{
+				"showFavourites": self.showFavourites,
+				"showAllServices": self.showAllServices,
+				"showProviders": self.showProviders,
+				"showSatellites": self.showSatellites,
+				"nextBouquet": self.nextBouquet,
+				"prevBouquet": self.prevBouquet,
+				"nextMarker": self.nextMarker,
+				"prevMarker": self.prevMarker,
+				"gotAsciiCode": self.keyAsciiCode,
+				"1": self.keyNumberGlobal,
+				"2": self.keyNumberGlobal,
+				"3": self.keyNumberGlobal,
+				"4": self.keyNumberGlobal,
+				"5": self.keyNumberGlobal,
+				"6": self.keyNumberGlobal,
+				"7": self.keyNumberGlobal,
+				"8": self.keyNumberGlobal,
+				"9": self.keyNumberGlobal,
+				"0": self.keyNumber0
+			})
+		self.maintitle = _("Channel selection")
+		self.recallBouquetMode()
+
+	def getBouquetNumOffset(self, bouquet):
+		if not config.usage.multibouquet.value:
+			return 0
+		str = bouquet.toString()
+		offset = 0
+		if 'userbouquet.' in bouquet.toCompareString():
+			serviceHandler = eServiceCenter.getInstance()
+			servicelist = serviceHandler.list(bouquet)
+			if not servicelist is None:
+				while True:
+					serviceIterator = servicelist.getNext()
+					if not serviceIterator.valid(): #check if end of list
+						break
+					number = serviceIterator.getChannelNum()
+					if number > 0:
+						offset = number - 1
+						break
+		return offset			
+
+	def recallBouquetMode(self):
+		if self.mode == MODE_TV:
+			self.service_types = service_types_tv
+			if config.usage.multibouquet.value:
+				self.bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "bouquets.tv" ORDER BY bouquet'
+			else:
+				self.bouquet_rootstr = '%s FROM BOUQUET "userbouquet.favourites.tv" ORDER BY bouquet'%(self.service_types)
+		else:
+			self.service_types = service_types_radio
+			if config.usage.multibouquet.value:
+				self.bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "bouquets.radio" ORDER BY bouquet'
+			else:
+				self.bouquet_rootstr = '%s FROM BOUQUET "userbouquet.favourites.radio" ORDER BY bouquet'%(self.service_types)
+		self.bouquet_root = eServiceReference(self.bouquet_rootstr)
+
+	def setTvMode(self):
+		self.mode = MODE_TV
+		self.servicePath = self.servicePathTV
+		self.recallBouquetMode()
+		title = self.maintitle
+		pos = title.find(" (")
+		if pos != -1:
+			title = title[:pos]
+		title += _(" (TV)")
+		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
+
+	def setRadioMode(self):
+		self.mode = MODE_RADIO
+		self.servicePath = self.servicePathRadio
+		self.recallBouquetMode()
+		title = self.maintitle
+		pos = title.find(" (")
+		if pos != -1:
+			title = title[:pos]
+		title += _(" (Radio)")
+		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
+
+	def setRoot(self, root, justSet=False):
+		if self.startRoot is None:
+			self.startRoot = self.getRoot()
+		path = root.getPath()
+		inBouquetRootList = path.find('FROM BOUQUET "bouquets.') != -1 #FIXME HACK
+		pos = path.find('FROM BOUQUET')
+		isBouquet = (pos != -1) and (root.flags & eServiceReference.isDirectory)
+		if not inBouquetRootList and isBouquet:
+			self.servicelist.setMode(ServiceList.MODE_FAVOURITES)
+		else:
+			self.servicelist.setMode(ServiceList.MODE_NORMAL)
+		self.servicelist.setRoot(root, justSet)
+		self.rootChanged = True
+		self.buildTitleString()
+
+	def removeModeStr(self, str):
+		if self.mode == MODE_TV:
+			pos = str.find(_(" (TV)"))
+		else:
+			pos = str.find(_(" (Radio)"))
+		if pos != -1:
+			return str[:pos]
+		return str
+
+	def getServiceName(self, ref):
+		str = self.removeModeStr(ServiceReference(ref).getServiceName())
+		if 'User - bouquets' in str:
+			return _("User - bouquets")
+		if not str:
+			pathstr = ref.getPath()
+			if 'FROM PROVIDERS' in pathstr:
+				return _("Provider")
+			if 'FROM SATELLITES' in pathstr:
+				return _("Satellites")
+			if ') ORDER BY name' in pathstr:
+				return _("All")
+		return str
+
+	def buildTitleString(self):
+		titleStr = self.getTitle()
+		pos = titleStr.find(']')
+		if pos == -1:
+			pos = titleStr.find(')')
+		if pos != -1:
+			titleStr = titleStr[:pos+1]
+			Len = len(self.servicePath)
+			if Len > 0:
+				base_ref = self.servicePath[0]
+				if Len > 1:
+					end_ref = self.servicePath[Len-1]
+				else:
+					end_ref = None
+				nameStr = self.getServiceName(base_ref)
+				titleStr += ' - ' + nameStr
+#+++>
+				self["boquet"].setText("Channel Selection")
+#+++<
+				if end_ref is not None:
+					if Len > 2:
+						titleStr += '/../'
+					else:
+						titleStr += '/'
+					nameStr = self.getServiceName(end_ref)
+					titleStr += nameStr
+#+++>
+					self["boquet"].setText(nameStr)
+#+++<
+				self.setTitle(titleStr)
+#+++>
+				self["title"].setText(titleStr)
+#+++<
+
+	def moveUp(self):
+		self.servicelist.moveUp()
+
+	def moveDown(self):
+		self.servicelist.moveDown()
+
+	def clearPath(self):
+		del self.servicePath[:]
+
+	def enterPath(self, ref, justSet=False):
+		self.servicePath.append(ref)
+		self.setRoot(ref, justSet)
+
+	def pathUp(self, justSet=False):
+		prev = self.servicePath.pop()
+		if self.servicePath:
+			current = self.servicePath[-1]
+			self.setRoot(current, justSet)
+			if not justSet:
+				self.setCurrentSelection(prev)
+		return prev
+
+	def isBasePathEqual(self, ref):
+		if len(self.servicePath) > 1 and self.servicePath[0] == ref:
+			return True
+		return False
+
+	def isPrevPathEqual(self, ref):
+		length = len(self.servicePath)
+		if length > 1 and self.servicePath[length-2] == ref:
+			return True
+		return False
+
+	def preEnterPath(self, refstr):
+		return False
+
+	def showAllServices(self):
+		if not self.pathChangeDisabled:
+			refstr = '%s ORDER BY name'%(self.service_types)
+			if not self.preEnterPath(refstr):
+				ref = eServiceReference(refstr)
+				currentRoot = self.getRoot()
+				if currentRoot is None or currentRoot != ref:
+					self.clearPath()
+					self.enterPath(ref)
+					self.setCurrentSelectionAlternative(self.session.nav.getCurrentlyPlayingServiceOrGroup())
+
+	def showSatellites(self):
+		if not self.pathChangeDisabled:
+			refstr = '%s FROM SATELLITES ORDER BY satellitePosition'%(self.service_types)
+			if not self.preEnterPath(refstr):
+				ref = eServiceReference(refstr)
+				justSet=False
+				prev = None
+
+				if self.isBasePathEqual(ref):
+					if self.isPrevPathEqual(ref):
+						justSet=True
+					prev = self.pathUp(justSet)
+				else:
+					currentRoot = self.getRoot()
+					if currentRoot is None or currentRoot != ref:
+						justSet=True
+						self.clearPath()
+						self.enterPath(ref, True)
+				if justSet:
+					serviceHandler = eServiceCenter.getInstance()
+					servicelist = serviceHandler.list(ref)
+					if not servicelist is None:
+						while True:
+							service = servicelist.getNext()
+							if not service.valid(): #check if end of list
+								break
+							unsigned_orbpos = service.getUnsignedData(4) >> 16
+							orbpos = service.getData(4) >> 16
+							if orbpos < 0:
+								orbpos += 3600
+							if service.getPath().find("FROM PROVIDER") != -1:
+								service_type = _("Providers")
+							elif service.getPath().find("flags == %d" %(FLAG_SERVICE_NEW_FOUND)) != -1:
+								service_type = _("New")
+							else:
+								service_type = _("Services")
+							try:
+								# why we need this cast?
+								service_name = str(nimmanager.getSatDescription(orbpos))
+							except:
+								if unsigned_orbpos == 0xFFFF: #Cable
+									service_name = _("Cable")
+								elif unsigned_orbpos == 0xEEEE: #Terrestrial
+									service_name = _("Terrestrial")
+								else:
+									if orbpos > 1800: # west
+										orbpos = 3600 - orbpos
+										h = _("W")
+									else:
+										h = _("E")
+									service_name = ("%d.%d" + h) % (orbpos / 10, orbpos % 10)
+							service.setName("%s - %s" % (service_name, service_type))
+							self.servicelist.addService(service)
+						cur_ref = self.session.nav.getCurrentlyPlayingServiceReference()
+						if cur_ref:
+							pos = self.service_types.rfind(':')
+							refstr = '%s (channelID == %08x%04x%04x) && %s ORDER BY name' %(self.service_types[:pos+1],
+								cur_ref.getUnsignedData(4), # NAMESPACE
+								cur_ref.getUnsignedData(2), # TSID
+								cur_ref.getUnsignedData(3), # ONID
+								self.service_types[pos+1:])
+							ref = eServiceReference(refstr)
+							ref.setName(_("Current transponder"))
+							self.servicelist.addService(ref)
+						self.servicelist.finishFill()
+						if prev is not None:
+							self.setCurrentSelection(prev)
+						elif cur_ref:
+							refstr = cur_ref.toString()
+							op = "".join(refstr.split(':', 10)[6:7])
+							if len(op) >= 4:
+								hop = int(op[:-4],16)
+								refstr = '1:7:0:0:0:0:%s:0:0:0:(satellitePosition == %s) && %s ORDER BY name'%(op,hop,self.service_types[self.service_types.rfind(':')+1:])
+								self.setCurrentSelectionAlternative(eServiceReference(refstr))
+
+	def showProviders(self):
+		if not self.pathChangeDisabled:
+			refstr = '%s FROM PROVIDERS ORDER BY name'%(self.service_types)
+			if not self.preEnterPath(refstr):
+				ref = eServiceReference(refstr)
+				if self.isBasePathEqual(ref):
+					self.pathUp()
+				else:
+					currentRoot = self.getRoot()
+					if currentRoot is None or currentRoot != ref:
+						self.clearPath()
+						self.enterPath(ref)
+						service = self.session.nav.getCurrentService()
+						if service:
+							info = service.info()
+							if info:
+								provider = info.getInfoString(iServiceInformation.sProvider)
+								refstr = '1:7:0:0:0:0:0:0:0:0:(provider == \"%s\") && %s ORDER BY name:%s'%(provider,self.service_types[self.service_types.rfind(':')+1:],provider)
+								self.setCurrentSelectionAlternative(eServiceReference(refstr))
+
+	def changeBouquet(self, direction):
+		if not self.pathChangeDisabled:
+			if len(self.servicePath) > 1:
+				#when enter satellite root list we must do some magic stuff..
+				ref = eServiceReference('%s FROM SATELLITES ORDER BY satellitePosition'%(self.service_types))
+				if self.isBasePathEqual(ref):
+					self.showSatellites()
+				else:
+					self.pathUp()
+				if direction < 0:
+					self.moveUp()
+				else:
+					self.moveDown()
+				ref = self.getCurrentSelection()
+				self.enterPath(ref)
+
+	def inBouquet(self):
+		if self.servicePath and self.servicePath[0] == self.bouquet_root:
+			return True
+		return False
+
+	def atBegin(self):
+		return self.servicelist.atBegin()
+
+	def atEnd(self):
+		return self.servicelist.atEnd()
+
+	def nextBouquet(self):
+		if "reverseB" in config.usage.servicelist_cursor_behavior.value:
+			self.changeBouquet(-1)
+		else:
+			self.changeBouquet(+1)
+
+	def prevBouquet(self):
+		if "reverseB" in config.usage.servicelist_cursor_behavior.value:
+			self.changeBouquet(+1)
+		else:
+			self.changeBouquet(-1)
+
+	def showFavourites(self):
+		if not self.pathChangeDisabled:
+			if not self.preEnterPath(self.bouquet_rootstr):
+				if self.isBasePathEqual(self.bouquet_root):
+					self.pathUp()
+				else:
+					currentRoot = self.getRoot()
+					if currentRoot is None or currentRoot != self.bouquet_root:
+						self.clearPath()
+						self.enterPath(self.bouquet_root)
+
+	def keyNumberGlobal(self, number):
+		if self.isBasePathEqual(self.bouquet_root):
+			self.BouqetNumberActions(number)
+		else:
+			unichar = self.numericalTextInput.getKey(number)
+			charstr = unichar.encode("utf-8")
+			if len(charstr) == 1:
+				self.servicelist.moveToChar(charstr[0])
+
+	def BouqetNumberActions(self, number):
+		if number == 1: #Set focus on current playing service when available in current userbouquet
+			currentSelectedService = self.servicelist.getCurrent()
+			currentPlayingService = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+			self.servicelist.setCurrent(currentPlayingService)
+			if self.servicelist.getCurrent() != currentPlayingService:
+				self.servicelist.setCurrent(currentSelectedService)
+		elif number == 2: #set focus on service available from history in current userbouquet
+			currentSelectedService = self.servicelist.getCurrent()
+			root = self.getRoot()
+			service = None
+			for path in self.history:
+				if len(path) > 2 and path[1] == root:
+					service = path[2]
+			if service:
+				self.setCurrentSelection(service)
+				if self.servicelist.getCurrent() != service:
+					self.servicelist.setCurrent(currentSelectedService)
+		elif number == 4:
+			self.renameEntry()
+		elif number == 5:
+			self.session.openWithCallback(self.removeCurrentServiceCallback, MessageBox, _("Are you sure to remove this entry?"))
+		elif number == 6:
+			self.toggleMoveMode()
+
+	def removeCurrentServiceCallback(self, confirmation):
+		if confirmation:
+			self.removeCurrentService()
+
+	def keyAsciiCode(self):
+		unichar = unichr(getPrevAsciiCode())
+		charstr = unichar.encode("utf-8")
+		if len(charstr) == 1:
+			self.servicelist.moveToChar(charstr[0])
+
+	def getRoot(self):
+		return self.servicelist.getRoot()
+
+	def getCurrentSelection(self):
+		return self.servicelist.getCurrent()
+
+	def setCurrentSelection(self, service):
+		if service:
+			self.servicelist.setCurrent(service)
+
+	def setCurrentSelectionAlternative(self, ref):
+		if self.bouquet_mark_edit == EDIT_ALTERNATIVES and not (ref.flags & eServiceReference.isDirectory):
+			for markedService in self.servicelist.getMarked():
+				markedService = eServiceReference(markedService)
+				self.setCurrentSelection(markedService)
+				if markedService == self.getCurrentSelection():
+					return
+		self.setCurrentSelection(ref)
+
+	def getBouquetList(self):
+		bouquets = [ ]
+		serviceHandler = eServiceCenter.getInstance()
+		if config.usage.multibouquet.value:
+			list = serviceHandler.list(self.bouquet_root)
+			if list:
+				while True:
+					s = list.getNext()
+					if not s.valid():
+						break
+					if s.flags & eServiceReference.isDirectory:
+						info = serviceHandler.info(s)
+						if info:
+							bouquets.append((info.getName(s), s))
+				return bouquets
+		else:
+			info = serviceHandler.info(self.bouquet_root)
+			if info:
+				bouquets.append((info.getName(self.bouquet_root), self.bouquet_root))
+			return bouquets
+		return None
+
+	def keyNumber0(self, num):
+		if len(self.servicePath) > 1:
+			self.keyGoUp()
+		else:
+			self.keyNumberGlobal(num)
+
+	def keyGoUp(self):
+		if len(self.servicePath) > 1:
+			if self.isBasePathEqual(self.bouquet_root):
+				self.showFavourites()
+			else:
+				ref = eServiceReference('%s FROM SATELLITES ORDER BY satellitePosition'%(self.service_types))
+				if self.isBasePathEqual(ref):
+					self.showSatellites()
+				else:
+					ref = eServiceReference('%s FROM PROVIDERS ORDER BY name'%(self.service_types))
+					if self.isBasePathEqual(ref):
+						self.showProviders()
+					else:
+						self.showAllServices()
+
+	def nextMarker(self):
+		self.servicelist.moveToNextMarker()
+
+	def prevMarker(self):
+		self.servicelist.moveToPrevMarker()
+
+	def gotoCurrentServiceOrProvider(self, ref):
+		str = ref.toString()
+		if str.find(_("Providers")) != -1:
+			service = self.session.nav.getCurrentService()
+			if service:
+				info = service.info()
+				if info:
+					provider = info.getInfoString(iServiceInformation.sProvider)
+					op = int(self.session.nav.getCurrentlyPlayingServiceOrGroup().toString().split(':')[6][:-4] or "0",16)
+					refstr = '1:7:0:0:0:0:0:0:0:0:(provider == \"%s\") && (satellitePosition == %s) && %s ORDER BY name:%s'%(provider,op,self.service_types[self.service_types.rfind(':')+1:],provider)
+					self.servicelist.setCurrent(eServiceReference(refstr))
+		elif not self.isBasePathEqual(self.bouquet_root) or self.bouquet_mark_edit == EDIT_ALTERNATIVES:
+			self.setCurrentSelectionAlternative(self.session.nav.getCurrentlyPlayingServiceOrGroup())
+
+HISTORYSIZE = 20
+
+#config for lastservice
+config.tv = ConfigSubsection()
+config.tv.lastservice = ConfigText()
+config.tv.lastroot = ConfigText()
+config.radio = ConfigSubsection()
+config.radio.lastservice = ConfigText()
+config.radio.lastroot = ConfigText()
+config.servicelist = ConfigSubsection()
+config.servicelist.lastmode = ConfigText(default = "tv")
+config.servicelist.startupservice = ConfigText()
+config.servicelist.startuproot = ConfigText()
+config.servicelist.startupmode = ConfigText(default = "tv")
+
+class ChannelSelection(ChannelSelectionBase, ChannelSelectionEdit, ChannelSelectionEPG, SelectionEventInfo):
+	def __init__(self, session):
+		ChannelSelectionBase.__init__(self,session)
+		ChannelSelectionEdit.__init__(self)
+		ChannelSelectionEPG.__init__(self)
+		SelectionEventInfo.__init__(self)
+
+		self["actions"] = ActionMap(["OkCancelActions", "TvRadioActions"],
+			{
+				"cancel": self.cancel,
+				"ok": self.channelSelected,
+				"keyRadio": self.doRadioButton,
+				"keyTV": self.doTVButton,
+			})
+
+		self.__event_tracker = ServiceEventTracker(screen=self, eventmap=
+			{
+				iPlayableService.evStart: self.__evServiceStart,
+				iPlayableService.evEnd: self.__evServiceEnd
+			})
+
+		self.startServiceRef = None
+
+		self.history_tv = [ ]
+		self.history_radio = [ ]
+		self.history = self.history_tv
+		self.history_pos = 0
+
+		if config.servicelist.startupservice.value and config.servicelist.startuproot.value:
+			config.servicelist.lastmode.value = config.servicelist.startupmode.value
+			if config.servicelist.lastmode.value == "tv":
+				config.tv.lastservice.value = config.servicelist.startupservice.value
+				config.tv.lastroot.value = config.servicelist.startuproot.value
+			elif config.servicelist.lastmode.value == "radio":
+				config.radio.lastservice.value = config.servicelist.startupservice.value
+				config.radio.lastroot.value = config.servicelist.startuproot.value
+
+		self.lastservice = config.tv.lastservice
+		self.lastroot = config.tv.lastroot
+		self.revertMode = None
+		config.usage.multibouquet.addNotifier(self.multibouquet_config_changed)
+		self.new_service_played = False
+		self.dopipzap = False
+		self.onExecBegin.append(self.asciiOn)
+
+		self.lastChannelRootTimer = eTimer()
+		self.lastChannelRootTimer.callback.append(self.__onCreate)
+		self.lastChannelRootTimer.start(100,True)
+
+	def asciiOn(self):
+		rcinput = eRCInput.getInstance()
+		rcinput.setKeyboardMode(rcinput.kmAscii)
+
+	def asciiOff(self):
+		rcinput = eRCInput.getInstance()
+		rcinput.setKeyboardMode(rcinput.kmNone)
+
+	def multibouquet_config_changed(self, val):
+		self.recallBouquetMode()
+
+	def __evServiceStart(self):
+		service = self.session.nav.getCurrentService()
+		if service:
+			info = service.info()
+			if info:
+				refstr = info.getInfoString(iServiceInformation.sServiceref)
+				self.servicelist.setPlayableIgnoreService(eServiceReference(refstr))
+
+	def __evServiceEnd(self):
+		self.servicelist.setPlayableIgnoreService(eServiceReference())
+
+	def setMode(self):
+		self.rootChanged = True
+		self.restoreRoot()
+		lastservice = eServiceReference(self.lastservice.value)
+		if lastservice.valid():
+			self.setCurrentSelection(lastservice)
+
+	def doTVButton(self):
+		if self.mode == MODE_TV:
+			self.channelSelected(doClose = False)
+		else:
+			self.setModeTv()
+
+	def setModeTv(self):
+		if self.revertMode is None:
+			self.revertMode = self.mode
+		self.history = self.history_tv
+		self.lastservice = config.tv.lastservice
+		self.lastroot = config.tv.lastroot
+		config.servicelist.lastmode.value = "tv"
+		self.setTvMode()
+		self.setMode()
+
+	def doRadioButton(self):
+		if self.mode == MODE_RADIO:
+			self.channelSelected(doClose = False)
+		else:
+			self.setModeRadio()
+
+	def setModeRadio(self):
+		if self.revertMode is None:
+			self.revertMode = self.mode
+		if config.usage.e1like_radio_mode.value:
+			self.history = self.history_radio
+			self.lastservice = config.radio.lastservice
+			self.lastroot = config.radio.lastroot
+			config.servicelist.lastmode.value = "radio"
+			self.setRadioMode()
+			self.setMode()
+
+	def __onCreate(self):
+		if config.usage.e1like_radio_mode.value:
+			if config.servicelist.lastmode.value == "tv":
+				self.setModeTv()
+			else:
+				self.setModeRadio()
+		else:
+			self.setModeTv()
+		lastservice = eServiceReference(self.lastservice.value)
+		if lastservice.valid():
+			self.zap()
+
+	def channelSelected(self, doClose = True):
+		if self.startServiceRef is None and not doClose:
+			self.startServiceRef = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		ref = self.getCurrentSelection()
+		if self.movemode:
+			self.toggleMoveMarked()
+		elif (ref.flags & eServiceReference.flagDirectory) == eServiceReference.flagDirectory:
+			self.enterPath(ref)
+			self.gotoCurrentServiceOrProvider(ref)
+		elif self.bouquet_mark_edit != OFF:
+			if not (self.bouquet_mark_edit == EDIT_ALTERNATIVES and ref.flags & eServiceReference.isGroup):
+				self.doMark()
+		elif not (ref.flags & eServiceReference.isMarker): # no marker
+			root = self.getRoot()
+			if not root or not (root.flags & eServiceReference.isGroup):
+				self.zap(enable_pipzap = doClose, preview_zap = not doClose)
+				self.asciiOff()
+				if doClose:
+					if self.dopipzap:
+						self.zapBack()
+					self.startServiceRef = None
+					self.startRoot = None
+					self.close(ref)
+
+	def togglePipzap(self):
+		assert(self.session.pip)
+		title = self.instance.getTitle()
+		pos = title.find(" (")
+		if pos != -1:
+			title = title[:pos]
+		if self.dopipzap:
+			# Mark PiP as inactive and effectively deactivate pipzap
+			self.session.pip.inactive()
+			self.dopipzap = False
+
+			# Disable PiP if not playing a service
+			if self.session.pip.pipservice is None:
+				self.session.pipshown = False
+				del self.session.pip
+
+			# Move to playing service
+			lastservice = eServiceReference(self.lastservice.value)      
+			if lastservice.valid() and self.getCurrentSelection() != lastservice:                        
+				self.setCurrentSelection(lastservice)
+
+			title += _(" (TV)")
+		else:
+			# Mark PiP as active and effectively active pipzap
+			self.session.pip.active()
+			self.dopipzap = True
+
+			# Move to service playing in pip (will not work with subservices)
+			self.setCurrentSelection(self.session.pip.getCurrentService())
+
+			title += _(" (PiP)")
+		self.setTitle(title)
+		self.buildTitleString()
+
+	#called from infoBar and channelSelected
+	def zap(self, enable_pipzap = False, preview_zap = False, checkParentalControl = True, ref = None):
+		self.curRoot = self.startRoot
+		ref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		nref = self.getCurrentSelection()
+		if enable_pipzap and self.dopipzap:
+			ref = self.session.pip.getCurrentService()
+			if not checkParentalControl or Components.ParentalControl.parentalControl.isServicePlayable(nref, boundFunction(self.zap, checkParentalControl = False)):
+				if ref is None or ref != nref:
+					if not self.session.pip.playService(nref):
+						# XXX: Make sure we set an invalid ref
+						self.session.pip.playService(None)
+			else:
+				self.setStartRoot(self.curRoot)
+				self.setCurrentSelection(ref)
+		elif ref is None or ref != nref or self.rootChanged:
+			Screens.InfoBar.InfoBar.instance.checkTimeshiftRunning(boundFunction(self.zapCheckTimeshiftCallback, enable_pipzap, preview_zap, nref))
+
+	def zapCheckTimeshiftCallback(self, enable_pipzap, preview_zap, nref, answer):
+		if answer:
+			self.new_service_played = True
+			self.session.nav.playService(nref, forceRestart=self.rootChanged)
+			if not preview_zap:
+				self.saveRoot()
+				self.saveChannel(nref)
+				config.servicelist.lastmode.save()
+				if self.startServiceRef is None or nref != self.startServiceRef:
+					self.addToHistory(nref)
+				if self.dopipzap:
+					self.setCurrentSelection(self.session.pip.getCurrentService())
+				self.revertMode = None
+				self.rootChanged = False
+			else:
+				Notifications.RemovePopup("Parental control")
+				self.setCurrentSelection(nref)
+		else:
+			self.setStartRoot(self.curRoot)
+			self.setCurrentSelection(self.session.nav.getCurrentlyPlayingServiceOrGroup())
+		if not preview_zap:
+			self.hide()
+
+	def newServicePlayed(self):
+		ret = self.new_service_played
+		self.new_service_played = False
+		return ret
+
+	def addToHistory(self, ref):
+		if self.servicePath is not None:
+			tmp=self.servicePath[:]
+			tmp.append(ref)
+			try:
+				del self.history[self.history_pos+1:]
+			except:
+				pass
+			self.history.append(tmp)
+			hlen = len(self.history)
+			if hlen > HISTORYSIZE:
+				del self.history[0]
+				hlen -= 1
+			self.history_pos = hlen-1
+
+	def historyBack(self):
+		hlen = len(self.history)
+		currentPlayedRef = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		if hlen > 0 and self.history[self.history_pos][-1] != currentPlayedRef:
+			self.addToHistory(currentPlayedRef)
+			hlen = len(self.history)
+		if hlen > 1 and self.history_pos > 0:
+			self.history_pos -= 1
+			self.setHistoryPath()
+
+	def historyNext(self):
+		hlen = len(self.history)
+		if hlen > 1 and self.history_pos < (hlen-1):
+			self.history_pos += 1
+			self.setHistoryPath()
+
+	def setHistoryPath(self):
+		path = self.history[self.history_pos][:]
+		ref = path.pop()
+		del self.servicePath[:]
+		self.servicePath += path
+		self.saveRoot()
+		root = path[-1]
+		cur_root = self.getRoot()
+		if cur_root and cur_root != root:
+			self.setRoot(root)
+		self.session.nav.playService(ref)
+		if self.dopipzap:
+			self.setCurrentSelection(self.session.pip.getCurrentService())
+		else:
+			self.setCurrentSelection(ref)
+		self.saveChannel(ref)
+
+	def saveRoot(self):
+		path = ''
+		for i in self.servicePath:
+			path += i.toString()
+			path += ';'
+		if path and path != self.lastroot.value:
+			self.lastroot.value = path
+			self.lastroot.save()
+
+	def restoreRoot(self):
+		tmp = [x for x in self.lastroot.value.split(';') if x != '']
+		current = [x.toString() for x in self.servicePath]
+		if tmp != current or self.rootChanged:
+			self.clearPath()
+			cnt = 0
+			for i in tmp:
+				self.servicePath.append(eServiceReference(i))
+				cnt += 1
+			if cnt:
+				path = self.servicePath.pop()
+				self.enterPath(path)
+			else:
+				self.showFavourites()
+				self.saveRoot()
+			self.rootChanged = False
+
+	def preEnterPath(self, refstr):
+		if self.servicePath and self.servicePath[0] != eServiceReference(refstr):
+			pathstr = self.lastroot.value
+			if pathstr is not None and pathstr.find(refstr) == 0:
+				self.restoreRoot()
+				lastservice = eServiceReference(self.lastservice.value)
+				if lastservice.valid():
+					self.setCurrentSelection(lastservice)
+				return True
+		return False
+
+	def saveChannel(self, ref):
+		if ref is not None:
+			refstr = ref.toString()
+		else:
+			refstr = ""
+		if refstr != self.lastservice.value:
+			self.lastservice.value = refstr
+			self.lastservice.save()
+
+	def setCurrentServicePath(self, path):
+		if self.history:
+			self.history[self.history_pos] = path
+		else:
+			self.history.append(path)
+		self.setHistoryPath()
+
+	def getCurrentServicePath(self):
+		if self.history:
+			return self.history[self.history_pos]
+		return None
+
+	def recallPrevService(self):
+		hlen = len(self.history)
+		currentPlayedRef = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+		if hlen > 0 and self.history[self.history_pos][-1] != currentPlayedRef:
+			self.addToHistory(currentPlayedRef)
+			hlen = len(self.history)
+		if hlen > 1:
+			if self.history_pos == hlen-1:
+				tmp = self.history[self.history_pos]
+				self.history[self.history_pos] = self.history[self.history_pos-1]
+				self.history[self.history_pos-1] = tmp
+			else:
+				tmp = self.history[self.history_pos+1]
+				self.history[self.history_pos+1] = self.history[self.history_pos]
+				self.history[self.history_pos] = tmp
+			self.setHistoryPath()
+
+	def cancel(self):
+		if self.revertMode is None:
+			self.restoreRoot()
+			if self.dopipzap:
+				# This unfortunately won't work with subservices
+				self.setCurrentSelection(self.session.pip.getCurrentService())
+			else:
+				lastservice = eServiceReference(self.lastservice.value)
+				if lastservice.valid() and self.getCurrentSelection() != lastservice:
+					self.setCurrentSelection(lastservice)
+		self.asciiOff()
+		self.zapBack()
+		self.close(None)
+
+	def zapBack(self):
+		if self.startServiceRef and self.session.nav.getCurrentlyPlayingServiceOrGroup() != self.startServiceRef:
+			self.setStartRoot(self.startRoot)
+			self.new_service_played = True
+			self.session.nav.playService(self.startServiceRef)
+			self.saveChannel(self.startServiceRef)
+		self.startServiceRef = None
+		self.startRoot = None
+		if self.dopipzap:
+			# This unfortunately won't work with subservices
+			self.setCurrentSelection(self.session.pip.getCurrentService())
+
+	def setStartRoot(self, root):
+		if root:
+			if self.revertMode == MODE_TV:
+				self.setModeTv()
+			elif self.revertMode == MODE_RADIO:
+				self.setModeRadio()
+			self.revertMode = None
+			self.clearPath()
+			self.recallBouquetMode()
+			if self.bouquet_root:
+				self.enterPath(self.bouquet_root)
+			self.enterPath(root)
+			self.startRoot = None
+			self.saveRoot()
+
+class RadioInfoBar(Screen):
+	def __init__(self, session):
+		Screen.__init__(self, session)
+		self["RdsDecoder"] = RdsDecoder(self.session.nav)
+
+class ChannelSelectionRadio(ChannelSelectionBase, ChannelSelectionEdit, ChannelSelectionEPG, InfoBarBase):
+	ALLOW_SUSPEND = True
+
+	def __init__(self, session, infobar):
+		ChannelSelectionBase.__init__(self, session)
+		ChannelSelectionEdit.__init__(self)
+		ChannelSelectionEPG.__init__(self)
+		InfoBarBase.__init__(self)
+		self.infobar = infobar
+		self.startServiceRef = None
+		self.onLayoutFinish.append(self.onCreate)
+
+		self.info = session.instantiateDialog(RadioInfoBar) # our simple infobar
+
+		self["actions"] = ActionMap(["OkCancelActions", "TvRadioActions"],
+			{
+				"keyTV": self.cancel,
+				"keyRadio": self.cancel,
+				"cancel": self.cancel,
+				"ok": self.channelSelected,
+			})
+
+		self.__event_tracker = ServiceEventTracker(screen=self, eventmap=
+			{
+				iPlayableService.evStart: self.__evServiceStart,
+				iPlayableService.evEnd: self.__evServiceEnd
+			})
+
+########## RDS Radiotext / Rass Support BEGIN
+		self.infobar = infobar # reference to real infobar (the one and only)
+		self["RdsDecoder"] = self.info["RdsDecoder"]
+		self["RdsActions"] = HelpableActionMap(self, "InfobarRdsActions",
+		{
+			"startRassInteractive": (self.startRassInteractive, _("View Rass interactive..."))
+		},-1)
+		self["RdsActions"].setEnabled(False)
+		infobar.rds_display.onRassInteractivePossibilityChanged.append(self.RassInteractivePossibilityChanged)
+		self.onClose.append(self.__onClose)
+
+	def __onClose(self):
+		lastservice = eServiceReference(config.tv.lastservice.value)
+		self.session.nav.playService(lastservice)
+
+	def startRassInteractive(self):
+		self.info.hide();
+		self.infobar.rass_interactive = self.session.openWithCallback(self.RassInteractiveClosed, RassInteractive)
+
+	def RassInteractiveClosed(self):
+		self.info.show()
+		self.infobar.rass_interactive = None
+		self.infobar.RassSlidePicChanged()
+
+	def RassInteractivePossibilityChanged(self, state):
+		self["RdsActions"].setEnabled(state)
+########## RDS Radiotext / Rass Support END
+
+	def cancel(self):
+		self.infobar.rds_display.onRassInteractivePossibilityChanged.remove(self.RassInteractivePossibilityChanged)
+		self.info.hide()
+		#set previous tv service
+		self.close(None)
+
+	def __evServiceStart(self):
+		service = self.session.nav.getCurrentService()
+		if service:
+			info = service.info()
+			if info:
+				refstr = info.getInfoString(iServiceInformation.sServiceref)
+				self.servicelist.setPlayableIgnoreService(eServiceReference(refstr))
+
+	def __evServiceEnd(self):
+		self.servicelist.setPlayableIgnoreService(eServiceReference())
+
+	def saveRoot(self):
+		path = ''
+		for i in self.servicePathRadio:
+			path += i.toString()
+			path += ';'
+		if path and path != config.radio.lastroot.value:
+			config.radio.lastroot.value = path
+			config.radio.lastroot.save()
+
+	def restoreRoot(self):
+		tmp = [x for x in config.radio.lastroot.value.split(';') if x != '']
+		current = [x.toString() for x in self.servicePath]
+		if tmp != current or self.rootChanged:
+			cnt = 0
+			for i in tmp:
+				self.servicePathRadio.append(eServiceReference(i))
+				cnt += 1
+			if cnt:
+				path = self.servicePathRadio.pop()
+				self.enterPath(path)
+			else:
+				self.showFavourites()
+				self.saveRoot()
+			self.rootChanged = False
+
+	def preEnterPath(self, refstr):
+		if self.servicePathRadio and self.servicePathRadio[0] != eServiceReference(refstr):
+			pathstr = config.radio.lastroot.value
+			if pathstr is not None and pathstr.find(refstr) == 0:
+				self.restoreRoot()
+				lastservice = eServiceReference(config.radio.lastservice.value)
+				if lastservice.valid():
+					self.setCurrentSelection(lastservice)
+				return True
+		return False
+
+	def onCreate(self):
+		self.setRadioMode()
+		self.restoreRoot()
+		lastservice = eServiceReference(config.radio.lastservice.value)
+		if lastservice.valid():
+			self.servicelist.setCurrent(lastservice)
+			self.session.nav.playService(lastservice)
+		else:
+			self.session.nav.stopService()
+		self.info.show()
+
+	def channelSelected(self): # just return selected service
+		ref = self.getCurrentSelection()
+		if self.movemode:
+			self.toggleMoveMarked()
+		elif (ref.flags & eServiceReference.flagDirectory) == eServiceReference.flagDirectory:
+			self.enterPath(ref)
+			self.gotoCurrentServiceOrProvider(ref)
+		elif self.bouquet_mark_edit != OFF:
+			if not (self.bouquet_mark_edit == EDIT_ALTERNATIVES and ref.flags & eServiceReference.isGroup):
+				self.doMark()
+		elif not (ref.flags & eServiceReference.isMarker): # no marker
+			cur_root = self.getRoot()
+			if not cur_root or not (cur_root.flags & eServiceReference.isGroup):
+				playingref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+				if playingref is None or playingref != ref:
+					self.session.nav.playService(ref)
+					config.radio.lastservice.value = ref.toString()
+					config.radio.lastservice.save()
+				self.saveRoot()
+
+	def zapBack(self):
+		self.channelSelected()
+
+class SimpleChannelSelection(ChannelSelectionBase):
+	def __init__(self, session, title):
+		ChannelSelectionBase.__init__(self, session)
+		self["actions"] = ActionMap(["OkCancelActions", "TvRadioActions"],
+			{
+				"cancel": self.close,
+				"ok": self.channelSelected,
+				"keyRadio": self.setModeRadio,
+				"keyTV": self.setModeTv,
+			})
+		self.bouquet_mark_edit = OFF
+		self.title = title
+		self.onLayoutFinish.append(self.layoutFinished)
+
+	def layoutFinished(self):
+		self.setModeTv()
+#+++>
+		self["title"].setText(self.title)
+#+++<
+
+	def channelSelected(self): # just return selected service
+		ref = self.getCurrentSelection()
+		if (ref.flags & eServiceReference.flagDirectory) == eServiceReference.flagDirectory:
+			self.enterPath(ref)
+			self.gotoCurrentServiceOrProvider(ref)
+		elif not (ref.flags & eServiceReference.isMarker):
+			ref = self.getCurrentSelection()
+			self.close(ref)
+
+	def setModeTv(self):
+		self.setTvMode()
+		self.showFavourites()
+
+	def setModeRadio(self):
+		self.setRadioMode()
+		self.showFavourites()
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py enigma2-nightly.patched/lib/python/Screens/InfoBarGenerics.py
--- enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py	2013-08-11 08:11:19.318306128 +0200
+++ enigma2-nightly.patched/lib/python/Screens/InfoBarGenerics.py	2013-08-11 08:18:50.290295930 +0200
@@ -9,7 +9,7 @@
 from Components.PluginComponent import plugins
 from Components.ServiceEventTracker import ServiceEventTracker
 from Components.Sources.Boolean import Boolean
-from Components.config import config, ConfigBoolean, ConfigClock
+from Components.config import config, ConfigBoolean, ConfigClock, ConfigSubsection, ConfigYesNo, ConfigText
 from Components.SystemInfo import SystemInfo
 from Components.UsageConfig import preferredInstantRecordPath, defaultMoviePath, ConfigSelection
 from EpgSelection import EPGSelection
@@ -35,6 +35,7 @@
 
 from Tools import Notifications, ASCIItranslit
 from Tools.Directories import fileExists, getRecordingFilename, moveFiles
+from Tools.Command import command
 
 from enigma import eTimer, eServiceCenter, eDVBServicePMTHandler, iServiceInformation, \
 	iPlayableService, eServiceReference, eEPGCache, eActionMap
@@ -105,7 +106,7 @@
 	global resumePointCache, resumePointCacheLast
 	import cPickle
 	try:
-		f = open('/home/root/resumepoints.pkl', 'wb')
+		f = open('/etc/enigma2/resumepoints.pkl', 'wb')
 		cPickle.dump(resumePointCache, f, cPickle.HIGHEST_PROTOCOL)
 	except Exception, ex:
 		print "[InfoBar] Failed to write resumepoints:", ex
@@ -114,7 +115,7 @@
 def loadResumePoints():
 	import cPickle
 	try:
-		return cPickle.load(open('/home/root/resumepoints.pkl', 'rb'))
+		return cPickle.load(open('/etc/enigma2/resumepoints.pkl', 'rb'))
 	except Exception, ex:
 		print "[InfoBar] Failed to load resumepoints:", ex
 		return {}
@@ -222,6 +223,7 @@
 	STATE_HIDING = 1
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+	STATE_EPG = 4
 
 	def __init__(self):
 		self["ShowHideActions"] = ActionMap( ["InfobarShowHideActions"] ,
@@ -317,6 +319,12 @@
 		if self.__state == self.STATE_SHOWN:
 			self.hide()
 
+	def epg(self):
+		self.__state = self.STATE_EPG
+		self.hide()
+		self.hideTimer.stop()
+		self.openEventView()
+
 	def toggleShow(self):
 		if self.__state == self.STATE_HIDDEN:
 			self.show()
@@ -327,7 +335,9 @@
 		elif self.secondInfoBarScreen and config.usage.show_second_infobar.value and not self.secondInfoBarScreen.shown:
 			self.secondInfoBarScreen.show()
 			self.startHideTimer()
-		else:
+		elif self.__state == self.STATE_SHOWN:
+			self.epg()
+		elif self.__state == self.STATE_EPG:
 			self.hide()
 			self.hideTimer.stop()
 
@@ -1763,7 +1773,7 @@
 
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
 		self.extensionKeys = {}
 		for x in self.list:
 			if x[0] == self.EXTENSION_SINGLE:
@@ -2267,16 +2277,16 @@
 				idx += 1
 
 			if self.bouquets and len(self.bouquets):
-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+				keys = ["red", "blue", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
 				if config.usage.multibouquet.value:
-					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
 				else:
-					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
-				selection += 3
+					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+				selection += 4
 			else:
-				tlist = [(_("Quick zap"), "quickzap", service.subServices()), ("--", "")] + tlist
-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
-				selection += 2
+				tlist = [(_("Quick zap"), "quickzap", service.subServices()), ("Exit", "exit"), ("--", "")] + tlist
+				keys = ["red", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+				selection += 3
 
 			self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a sub service..."), list = tlist, selection = selection, keys = keys, skin_name = "SubserviceSelection")
 
@@ -2964,3 +2974,140 @@
 		elif not Screens.Standby.inStandby:
 			print "[InfoBarPowersaver] goto standby"
 			self.session.open(Screens.Standby.Standby)
+
+class InfoBarAspectSelection:
+	def __init__(self):
+		self["AspectSelectionAction"] = HelpableActionMap(self, "InfobarAspectSelectionActions",
+			{
+				"aspectSelection": (self.ExGreen_toggleGreen, _("Aspect list...")),
+			})
+
+		self["key_green"] = Boolean(True)
+		self["key_yellow"] = Boolean(True)
+		self["key_blue"] = Boolean(True)
+
+	def ExGreen_doResolution(self):
+		self.resolutionSelection()
+
+	def ExGreen_toggleGreen(self, arg=""):
+		self.aspectSelection()
+
+	def aspectSelection(self):
+		selection = 0
+		tlist = []
+		tlist.append((_("Subservice list..."), "subservice"))
+		tlist.append((_("Resolution"), "resolution"))
+		tlist.append((_("3D Modus"), "tdmodus"))
+		tlist.append(("--", ""))
+		tlist.append(("Letterbox", "letterbox"))
+		tlist.append(("PanScan", "panscan"))
+		tlist.append(("Non Linear", "non"))
+		tlist.append(("Bestfit", "bestfit"))
+
+		mode = open("/proc/stb/video/policy").read()[:-1]
+		print mode
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		keys = ["green", "yellow", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+		self.session.openWithCallback(self.aspectSelected, ChoiceBox, title=_("Please select an aspect ratio..."), list = tlist, selection = selection, keys = keys) 
+
+	def aspectSelected(self, aspect):
+		if not aspect is None:
+			if isinstance(aspect[1], str):
+				if aspect[1] == "resolution":
+					self.ExGreen_doResolution()
+				elif aspect[1] == "tdmodus":
+					self.tdmodus()
+				elif aspect[1] == "subservice":
+					self.subserviceSelection()
+				else:
+					open("/proc/stb/video/policy", "w").write(aspect[1])
+		return
+
+	def tdmodus(self):
+		selection = 0
+		tlist = []
+		tlist.append((_("off"), "off"))
+		tlist.append((_("Side-by-Side"), "sbs"))
+		tlist.append((_("Top and Bottom"), "tab"))
+		keys = ["green", "yellow", "blue"]
+		self.session.openWithCallback(self.tdSelected, ChoiceBox, title=_("Please select an 3D modus..."), list = tlist, selection = selection, keys = keys)
+
+	def tdSelected(self, tdmod):
+		if not tdmod is None:
+			if isinstance(tdmod[1], str):
+				if tdmod[1] == "off":
+					config.av.threedmode.value = "off"
+					config.av.threedmode.save()
+					command('killall 3d-mode')
+				elif tdmod[1] == "sbs":
+					config.av.threedmode.value = "sbs"
+					config.av.threedmode.save()
+					command('3d-mode 40 &')
+				elif tdmod[1] == "tab":
+					config.av.threedmode.value = "tab"
+					config.av.threedmode.save()
+		return
+
+	def resolutionSelection(self):
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+		selection = 0
+		tlist = []
+		tlist.append((_("Exit"), "exit"))
+		tlist.append((_("Auto(not available)"), "auto"))
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", ""))
+		tlist.append(("--", ""))
+		tlist.append(("576i", "576i50"))
+		tlist.append(("576p", "576p50"))
+		tlist.append(("720p@50hz", "720p50"))
+		tlist.append(("720p@60hz", "720p60"))
+		tlist.append(("1080i@50hz", "1080i50"))
+		tlist.append(("1080i@60hz", "1080i60"))
+		tlist.append(("1080p@23.976hz", "1080p23"))
+		tlist.append(("1080p@24hz", "1080p24"))
+		tlist.append(("1080p@25hz", "1080p25"))
+		tlist.append(("1080p@29hz", "1080p29"))
+		tlist.append(("1080p@30hz", "1080p30"))
+		tlist.append(("1080p@50hz", "1080p50"))
+		tlist.append(("1080p@59hz", "1080p59"))
+		tlist.append(("1080p@60hz", "1080p60"))
+
+		keys = ["green", "yellow", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+
+		mode = open("/proc/stb/video/videomode").read()[:-1]
+		print mode
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		self.session.openWithCallback(self.ResolutionSelected, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys)
+
+	def ResolutionSelected(self, Resolution):
+		if not Resolution is None:
+			if isinstance(Resolution[1], str):
+				if Resolution[1] != "auto":
+					open("/proc/stb/video/videomode", "w").write(Resolution[1])
+					from enigma import gMainDC
+					gMainDC.getInstance().setResolution(-1, -1)
+		return
+
+class InfoBarSleepTimer:
+	def __init__(self):
+		self.addExtension((self.getSleepTimerName, self.showSleepTimerSetup, lambda: True), "blue")
+
+	def getSleepTimerName(self):
+		return _("Sleep Timer")
+
+	def showSleepTimerSetup(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/InfoBar.py enigma2-nightly.patched/lib/python/Screens/InfoBar.py
--- enigma2-nightly.org/lib/python/Screens/InfoBar.py	2013-08-11 08:11:19.318306128 +0200
+++ enigma2-nightly.patched/lib/python/Screens/InfoBar.py	2013-08-11 08:18:50.294295931 +0200
@@ -9,6 +9,9 @@
 
 profile("LOAD:enigma")
 import enigma
+#+++>
+from enigma import iServiceInformation, iPlayableService
+#+++<
 
 profile("LOAD:InfoBarGenerics")
 from Screens.InfoBarGenerics import InfoBarShowHide, \
@@ -19,7 +22,7 @@
 	InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarSimpleEventView, \
 	InfoBarSummarySupport, InfoBarMoviePlayerSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions, \
 	InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarJobman, InfoBarPowersaver, \
-	setResumePoint, delResumePoint
+	InfoBarAspectSelection, InfoBarSleepTimer, setResumePoint, delResumePoint
 
 profile("LOAD:InitBar_Components")
 from Components.ActionMap import HelpableActionMap
@@ -36,7 +39,7 @@
 	InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek, InfoBarCueSheetSupport,
 	InfoBarSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions,
 	InfoBarPiP, InfoBarPlugins, InfoBarSubtitleSupport, InfoBarServiceErrorPopupSupport, InfoBarJobman, InfoBarPowersaver,
-	Screen):
+	InfoBarAspectSelection, InfoBarSleepTimer, Screen):
 	
 	ALLOW_SUSPEND = True
 	instance = None
@@ -48,6 +51,11 @@
 				"showMovies": (self.showMovies, _("Play recorded movies...")),
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
+				"toogleTvRadio": (self.toogleTvRadio, _("toggels betwenn tv and radio...")),
+				"volumeUp": (self._volUp, _("...")),
+				"volumeDown": (self._volDown, _("...")),
+				"resolution": (self.resolution, _("...")),
+				"aspect": (self.aspect, _("...")),
 			}, prio=2)
 		
 		self.allowPiP = True
@@ -59,7 +67,7 @@
 				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarSubserviceSelection, \
 				InfoBarTimeshift, InfoBarSeek, InfoBarCueSheetSupport, InfoBarSummarySupport, InfoBarTimeshiftState, \
 				InfoBarTeletextPlugin, InfoBarExtensions, InfoBarPiP, InfoBarSubtitleSupport, InfoBarJobman, InfoBarPowersaver, \
-				InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+				InfoBarAspectSelection, InfoBarSleepTimer, InfoBarPlugins, InfoBarServiceErrorPopupSupport:
 			x.__init__(self)
 
 		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("Watch recordings..."))]))
@@ -74,6 +82,88 @@
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
 
+	def aspect(self):
+		selection = 0
+		tlist = []
+		try:
+			policy = open("/proc/stb/video/policy_choices").read()[:-1]
+		except IOError:
+			print "couldn't read available policymodes."
+			policy_available = [ ]
+			return
+		policy_available = policy.split(' ')
+		for x in policy_available:
+			tlist.append((x[0].upper() + x[1:], _(x)))
+
+		mode = open("/proc/stb/video/policy").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		keys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.aspectSelect, ChoiceBox, title=_("Please select an aspect ratio..."), list = tlist, selection = selection, keys = keys)
+
+	def aspectSelect(self, aspect):
+		if not aspect is None:
+			if isinstance(aspect[1], str):
+				open("/proc/stb/video/policy", "w").write(aspect[1])
+		return
+
+	def resolution(self):
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+		selection = 0
+		tlist = []
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", ""))
+		tlist.append(("--", ""))
+		tlist.append(("576i", "576i50"))
+		tlist.append(("576p", "576p50"))
+		tlist.append(("720p@50hz", "720p50"))
+		tlist.append(("720p@60hz", "720p60"))
+		tlist.append(("1080i@50hz", "1080i50"))
+		tlist.append(("1080i@60hz", "1080i60"))
+		tlist.append(("1080p@23.976hz", "1080p23"))
+		tlist.append(("1080p@24hz", "1080p24"))
+		tlist.append(("1080p@25hz", "1080p25"))
+		tlist.append(("1080p@30hz", "1080p30"))
+		tlist.append(("1080p@50hz", "1080p50"))
+		tlist.append(("1080p@59hz", "1080p59"))
+		tlist.append(("1080p@60hz", "1080p60"))
+		keys = ["green", "", "yellow", "blue", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+
+		mode = open("/proc/stb/video/videomode").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.ResolutionSelect, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys)
+
+	def ResolutionSelect(self, Resolution):
+		if not Resolution is None:
+			if isinstance(Resolution[1], str):
+				open("/proc/stb/video/videomode", "w").write(Resolution[1])
+				from enigma import gMainDC
+				gMainDC.getInstance().setResolution(-1, -1)
+		return
+
+	def _volUp(self):
+		print "_volUp"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volUp()
+
+	def _volDown(self):
+		print "_volDown"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volDown()
+
 	def __onClose(self):
 		InfoBar.instance = None
 
@@ -92,6 +182,22 @@
 		self.__serviceStarted(True)
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+	def toogleTvRadio(self): 
+		service = self.session.nav.getCurrentService()
+		info = service.info()
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID)
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID)
+
+		print "sAudioPID", AudioPID
+		print "sVideoPID", VideoPID
+
+		if VideoPID == -1:
+			print "radio->tv"
+			self.showTv2()
+		else:
+			print "tv->radio"
+			self.showRadio2()
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
 		if self.execing:
@@ -115,6 +221,19 @@
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
 
+	def showTv2(self):
+		self.showTvChannelList(False)
+		self.openServiceList()
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+			self.openServiceList()
+		else:
+			self.rds_display.hide() # in InfoBarRdsDecoder
+			from Screens.ChannelSelection import ChannelSelectionRadio
+			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+
 	def ChannelSelectionRadioClosed(self, *arg):
 		self.rds_display.show()  # in InfoBarRdsDecoder
 
@@ -136,6 +255,7 @@
 		InfoBarSeek, InfoBarShowMovies, InfoBarInstantRecord, InfoBarAudioSelection, HelpableScreen, InfoBarNotifications,
 		InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarSimpleEventView,
 		InfoBarMoviePlayerSummarySupport, InfoBarSubtitleSupport, Screen, InfoBarTeletextPlugin,
+		InfoBarAspectSelection, InfoBarSubserviceSelection,
 		InfoBarServiceErrorPopupSupport, InfoBarExtensions, InfoBarPlugins, InfoBarPiP):
 
 	ENABLE_RESUME_SUPPORT = True
@@ -144,6 +264,8 @@
 	def __init__(self, session, service, slist = None, lastservice = None):
 		Screen.__init__(self, session)
 		
+		InfoBarAspectSelection.__init__(self)
+
 		self["actions"] = HelpableActionMap(self, "MoviePlayerActions",
 			{
 				"leavePlayer": (self.leavePlayer, _("leave movie player...")),
@@ -264,11 +386,21 @@
 					return
 
 		if answer in ("quit", "quitanddeleteconfirmed"):
+#+++>
+			# make sure that playback is unpaused otherwise the
+			# player driver might stop working
+			self.setSeekState(self.SEEK_STATE_PLAY)
+#+++<
 			self.close()
 		elif answer == "movielist":
 			ref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
 			self.returning = True
 			self.session.openWithCallback(self.movieSelected, Screens.MovieSelection.MovieSelection, ref)
+#+++>
+			# make sure that playback is unpaused otherwise the
+			# player driver might stop working
+			self.setSeekState(self.SEEK_STATE_PLAY)
+#+++<
 			self.session.nav.stopService()
 		elif answer == "restart":
 			self.doSeek(0)
@@ -422,3 +554,7 @@
 
 	def ref2HumanName(self, ref):
 		return enigma.eServiceCenter.getInstance().info(ref).getName(ref)
+
+	def sleepTimer(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/InputDeviceSetup.py enigma2-nightly.patched/lib/python/Screens/InputDeviceSetup.py
--- enigma2-nightly.org/lib/python/Screens/InputDeviceSetup.py	2013-08-11 10:28:06.878120536 +0200
+++ enigma2-nightly.patched/lib/python/Screens/InputDeviceSetup.py	2013-08-11 08:11:19.322306128 +0200
@@ -223,7 +223,7 @@
 				self["config"].invalidate(self.nameEntry)
 
 		self["config"].list = self.list
-		self["config"].l.setSeperation(600)
+		self["config"].l.setSeperation(400)
 		self["config"].l.setList(self.list)
 		if not self.selectionChanged in self["config"].onSelectionChanged:
 			self["config"].onSelectionChanged.append(self.selectionChanged)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/Standby.py enigma2-nightly.patched/lib/python/Screens/Standby.py
--- enigma2-nightly.org/lib/python/Screens/Standby.py	2013-08-11 08:11:19.326306128 +0200
+++ enigma2-nightly.patched/lib/python/Screens/Standby.py	2013-08-11 08:56:08.010248593 +0200
@@ -13,6 +13,9 @@
 class Standby(Screen):
 	def Power(self):
 		print "leave standby"
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("on")
+#+++<
 		#set input to encoder
 		self.avswitch.setInput("ENCODER")
 		#restart last played service
@@ -69,6 +72,9 @@
 			self.avswitch.setInput("SCART")
 		else:
 			self.avswitch.setInput("AUX")
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("off")
+#+++<
 
 		gotoShutdownTime = int(config.usage.standby_to_shutdown_timer.value)
 		if gotoShutdownTime:
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/Standby.py~ enigma2-nightly.patched/lib/python/Screens/Standby.py~
--- enigma2-nightly.org/lib/python/Screens/Standby.py~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Screens/Standby.py~	2013-08-11 08:18:50.294295931 +0200
@@ -0,0 +1,217 @@
+from Screen import Screen
+from Components.ActionMap import ActionMap
+from Components.config import config
+from Components.AVSwitch import AVSwitch
+from Components.SystemInfo import SystemInfo
+from Tools import Notifications
+from GlobalActions import globalActionMap
+import RecordTimer
+from enigma import eDVBVolumecontrol, eTimer
+
+inStandby = None
+
+class Standby(Screen):
+	def Power(self):
+		print "leave standby"
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("on")
+#+++<
+		#set input to encoder
+		self.avswitch.setInput("ENCODER")
+		#restart last played service
+		#unmute adc
+		self.leaveMute()
+		#kill me
+		self.close(True)
+
+	def setMute(self):
+		if (eDVBVolumecontrol.getInstance().isMuted()):
+			self.wasMuted = 1
+			print "mute already active"
+		else:
+			self.wasMuted = 0
+			eDVBVolumecontrol.getInstance().volumeToggleMute()
+
+	def leaveMute(self):
+		if self.wasMuted == 0:
+			eDVBVolumecontrol.getInstance().volumeToggleMute()
+
+	def __init__(self, session, StandbyCounterIncrease=True):
+		Screen.__init__(self, session)
+		self.avswitch = AVSwitch()
+
+		print "enter standby"
+
+		self["actions"] = ActionMap( [ "StandbyActions" ],
+		{
+			"power": self.Power,
+			"discrete_on": self.Power
+		}, -1)
+
+		globalActionMap.setEnabled(False)
+
+		self.StandbyCounterIncrease = StandbyCounterIncrease
+
+		#mute adc
+		self.setMute()
+
+		self.paused_service = None
+		self.prev_running_service = None
+		if self.session.current_dialog:
+			if self.session.current_dialog.ALLOW_SUSPEND == Screen.SUSPEND_STOPS:
+				#get currently playing service reference
+				self.prev_running_service = self.session.nav.getCurrentlyPlayingServiceOrGroup()
+				#stop actual played dvb-service
+				self.session.nav.stopService()
+			elif self.session.current_dialog.ALLOW_SUSPEND == Screen.SUSPEND_PAUSES:
+				self.paused_service = self.session.current_dialog
+				self.paused_service.pauseService()
+
+		#set input to vcr scart
+		if SystemInfo["ScartSwitch"]:
+			self.avswitch.setInput("SCART")
+		else:
+			self.avswitch.setInput("AUX")
+
+		gotoShutdownTime = int(config.usage.standby_to_shutdown_timer.value)
+		if gotoShutdownTime:
+			self.standbyTimeoutTimer = eTimer()
+			self.standbyTimeoutTimer.callback.append(self.standbyTimeout)
+			self.standbyTimeoutTimer.startLongTimer(gotoShutdownTime)
+
+		self.onFirstExecBegin.append(self.__onFirstExecBegin)
+		self.onClose.append(self.__onClose)
+
+	def __onClose(self):
+		global inStandby
+		inStandby = None
+		if self.prev_running_service:
+			self.session.nav.playService(self.prev_running_service)
+		elif self.paused_service:
+			self.paused_service.unPauseService()
+		self.session.screen["Standby"].boolean = False
+		globalActionMap.setEnabled(True)
+		if RecordTimer.RecordTimerEntry.receiveRecordEvents:
+			RecordTimer.RecordTimerEntry.stopTryQuitMainloop()
+
+	def __onFirstExecBegin(self):
+		global inStandby
+		inStandby = self
+		self.session.screen["Standby"].boolean = True
+		if self.StandbyCounterIncrease:
+			config.misc.standbyCounter.value += 1
+
+	def createSummary(self):
+		return StandbySummary
+
+	def standbyTimeout(self):
+		from RecordTimer import RecordTimerEntry
+		RecordTimerEntry.TryQuitMainloop()
+
+class StandbySummary(Screen):
+	skin = """
+	<screen position="0,0" size="132,64">
+		<widget source="global.CurrentTime" render="Label" position="0,0" size="132,64" font="Regular;40" halign="center">
+			<convert type="ClockToText" />
+		</widget>
+		<widget source="session.RecordState" render="FixedLabel" text=" " position="0,0" size="132,64" zPosition="1" >
+			<convert type="ConfigEntryTest">config.usage.blinking_display_clock_during_recording,True,CheckSourceBoolean</convert>
+			<convert type="ConditionalShowHide">Blink</convert>
+		</widget>
+	</screen>"""
+
+from enigma import quitMainloop, iRecordableService
+from Screens.MessageBox import MessageBox
+from time import time
+from Components.Task import job_manager
+
+class QuitMainloopScreen(Screen):
+
+	def __init__(self, session, retvalue=1):
+		self.skin = """<screen name="QuitMainloopScreen" position="fill" flags="wfNoBorder">
+				<ePixmap pixmap="skin_default/icons/input_info.png" position="c-27,c-60" size="53,53" alphatest="on" />
+				<widget name="text" position="center,c+5" size="720,100" font="Regular;22" halign="center" />
+			</screen>"""
+		Screen.__init__(self, session)
+		from Components.Label import Label
+		text = { 1: _("Your receiver is shutting down"),
+			2: _("Your receiver is rebooting"),
+			3: _("The user interface of your receiver is restarting"),
+			4: _("Your frontprocessor will be upgraded\nPlease wait until your receiver reboots\nThis may take a few minutes"),
+			5: _("The user interface of your receiver is restarting\ndue to an error in mytest.py"),
+			42: _("Unattended upgrade in progress\nPlease wait until your receiver reboots\nThis may take a few minutes") }.get(retvalue)
+		self["text"] = Label(text)
+
+inTryQuitMainloop = False
+
+class TryQuitMainloop(MessageBox):
+	def __init__(self, session, retvalue=1, timeout=-1, default_yes = False):
+		self.retval = retvalue
+		recordings = session.nav.getRecordings()
+		jobs = len(job_manager.getPendingJobs())
+		self.connected = False
+		reason = ""
+		next_rec_time = -1
+		if not recordings:
+			next_rec_time = session.nav.RecordTimer.getNextRecordingTime()
+		if recordings or (next_rec_time > 0 and (next_rec_time - time()) < 360):
+			reason = _("Recording(s) are in progress or coming up in few seconds!") + '\n'
+		if jobs:
+			if jobs == 1:
+				job = job_manager.getPendingJobs()[0]
+				reason += "%s: %s (%d%%)\n" % (job.getStatustext(), job.name, int(100*job.progress/float(job.end)))
+			else:
+				reason += (ngettext("%d job is running in the background!", "%d jobs are running in the background!", jobs) % jobs) + '\n'
+		if reason:
+			text = { 1: _("Really shutdown now?"),
+				2: _("Really reboot now?"),
+				3: _("Really restart now?"),
+				4: _("Really upgrade the frontprocessor and reboot now?"),
+				42: _("Really upgrade your settop box and reboot now?") }.get(retvalue)
+			if text:
+				MessageBox.__init__(self, session, reason+text, type = MessageBox.TYPE_YESNO, timeout = timeout, default = default_yes)
+				self.skinName = "MessageBoxSimple"
+				session.nav.record_event.append(self.getRecordEvent)
+				self.connected = True
+				self.onShow.append(self.__onShow)
+				self.onHide.append(self.__onHide)
+				return
+		self.skin = """<screen position="0,0" size="0,0"/>"""
+		Screen.__init__(self, session)
+		self.close(True)
+
+	def getRecordEvent(self, recservice, event):
+		if event == iRecordableService.evEnd:
+			recordings = self.session.nav.getRecordings()
+			if not recordings: # no more recordings exist
+				rec_time = self.session.nav.RecordTimer.getNextRecordingTime()
+				if rec_time > 0 and (rec_time - time()) < 360:
+					self.initTimeout(360) # wait for next starting timer
+					self.startTimer()
+				else:
+					self.close(True) # immediate shutdown
+		elif event == iRecordableService.evStart:
+			self.stopTimer()
+
+	def close(self, value):
+		if self.connected:
+			self.conntected=False
+			self.session.nav.record_event.remove(self.getRecordEvent)
+		if value:
+			self.hide()
+			if self.retval == 1:
+				config.misc.DeepStandby.value = True
+			self.session.nav.stopService()
+			self.quitScreen = self.session.instantiateDialog(QuitMainloopScreen,retvalue=self.retval)
+			self.quitScreen.show()
+			quitMainloop(self.retval)
+		else:
+			MessageBox.close(self, True)
+
+	def __onShow(self):
+		global inTryQuitMainloop
+		inTryQuitMainloop = True
+
+	def __onHide(self):
+		global inTryQuitMainloop
+		inTryQuitMainloop = False
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/Wizard.py enigma2-nightly.patched/lib/python/Screens/Wizard.py
--- enigma2-nightly.org/lib/python/Screens/Wizard.py	2013-08-11 08:11:19.330306128 +0200
+++ enigma2-nightly.patched/lib/python/Screens/Wizard.py	2013-08-11 08:18:50.294295931 +0200
@@ -14,6 +14,9 @@
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 class WizardSummary(Screen):
 	def __init__(self, session, parent):
@@ -351,6 +354,9 @@
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -443,6 +449,9 @@
 			if self.wizard[self.currStep].has_key("onselect"):
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string("-> " + self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 		
 	def resetCounter(self):
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Tools/Command.py enigma2-nightly.patched/lib/python/Tools/Command.py
--- enigma2-nightly.org/lib/python/Tools/Command.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Tools/Command.py	2013-08-11 08:18:50.294295931 +0200
@@ -0,0 +1,22 @@
+from os import stat as os_stat, path as os_path, system
+import os
+
+def command(comandline, strip=1):
+	comandline = comandline + " >/tmp/command.txt"
+	os.system(comandline)
+	text = ""
+	if os.path.exists("/tmp/command.txt") is True:
+		file = open("/tmp/command.txt", "r")
+		if strip == 1:
+			for line in file:
+				text = text + line.strip() + '\n'
+		else:
+			for line in file:
+				text = text + line
+				if text[-1:] != '\n': text = text + "\n"
+		file.close
+	if text[-1:] == '\n': text = text[:-1]
+	comandline = text
+	os.system("rm /tmp/command.txt")
+	return comandline
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Tools/KeyBindings.py enigma2-nightly.patched/lib/python/Tools/KeyBindings.py
--- enigma2-nightly.org/lib/python/Tools/KeyBindings.py	2013-08-11 08:11:19.334306128 +0200
+++ enigma2-nightly.patched/lib/python/Tools/KeyBindings.py	2013-08-11 08:18:50.294295931 +0200
@@ -45,7 +45,10 @@
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("STOP",),
-		KEYIDS["KEY_RECORD"]: ("RECORD",)
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
 	},
 	{
 		KEYIDS["BTN_0"]: ("UP", "fp"),
@@ -87,7 +90,10 @@
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("TV", "SHIFT"),
-		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT")
+		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT"),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
 	},
 	{
 		KEYIDS["BTN_0"]: ("UP", "fp"),
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Tools/Makefile.am enigma2-nightly.patched/lib/python/Tools/Makefile.am
--- enigma2-nightly.org/lib/python/Tools/Makefile.am	2013-08-11 08:11:19.334306128 +0200
+++ enigma2-nightly.patched/lib/python/Tools/Makefile.am	2013-08-11 08:18:50.294295931 +0200
@@ -5,4 +5,4 @@
 	KeyBindings.py BoundFunction.py ISO639.py Notifications.py __init__.py \
 	RedirectOutput.py StbHardware.py Import.py Event.py CList.py \
 	LoadPixmap.py Profile.py HardwareInfo.py Transponder.py ASCIItranslit.py \
-	Downloader.py Trashcan.py GetEcmInfo.py Alternatives.py
+	Downloader.py Trashcan.py GetEcmInfo.py Alternatives.py Command.py
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/Makefile.inc enigma2-nightly.patched/lib/service/Makefile.inc
--- enigma2-nightly.org/lib/service/Makefile.inc	2013-08-11 08:11:19.338306128 +0200
+++ enigma2-nightly.patched/lib/service/Makefile.inc	2013-08-11 09:47:07.998176137 +0200
@@ -14,6 +14,13 @@
 	service/servicem2ts.cpp \
 	service/servicedvbstream.cpp
 
+if ENABLE_LIBEPLAYER3 
+if ENABLE_MEDIAFWGSTREAMER
+service_libenigma_service_a_SOURCES += \
+	service/serviceeplayer3.cpp
+endif
+endif
+
 serviceincludedir = $(pkgincludedir)/lib/service
 serviceinclude_HEADERS = \
 	service/event.h \
@@ -27,6 +34,13 @@
 	service/servicem2ts.h \
 	service/servicedvbstream.h
 
+if ENABLE_LIBEPLAYER3 
+if ENABLE_MEDIAFWGSTREAMER
+serviceinclude_HEADERS += \
+	service/serviceeplayer3.h
+endif
+endif
+
 if HAVE_LIBXINE
 service_libenigma_service_a_SOURCES += \
 	service/servicexine.cpp
@@ -39,4 +53,4 @@
 	service/servicedvd.cpp
 serviceinclude_HEADERS += \
 	service/servicedvd.h
-endif
\ Kein Zeilenumbruch am Dateiende.
+endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/Makefile.inc~ enigma2-nightly.patched/lib/service/Makefile.inc~
--- enigma2-nightly.org/lib/service/Makefile.inc~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/service/Makefile.inc~	2013-08-11 08:11:19.338306128 +0200
@@ -0,0 +1,42 @@
+noinst_LIBRARIES += service/libenigma_service.a
+
+service_libenigma_service_a_CXXFLAGS = \
+	$(LIBXINE_CFLAGS)
+
+service_libenigma_service_a_SOURCES = \
+	service/event.cpp \
+	service/listboxservice.cpp \
+	service/service.cpp \
+	service/servicedvb.cpp \
+	service/servicedvbrecord.cpp \
+	service/servicefs.cpp \
+	service/servicemp3.cpp \
+	service/servicem2ts.cpp \
+	service/servicedvbstream.cpp
+
+serviceincludedir = $(pkgincludedir)/lib/service
+serviceinclude_HEADERS = \
+	service/event.h \
+	service/iservice.h \
+	service/listboxservice.h \
+	service/service.h \
+	service/servicedvb.h \
+	service/servicedvbrecord.h \
+	service/servicefs.h \
+	service/servicemp3.h \
+	service/servicem2ts.h \
+	service/servicedvbstream.h
+
+if HAVE_LIBXINE
+service_libenigma_service_a_SOURCES += \
+	service/servicexine.cpp
+serviceinclude_HEADERS += \
+	service/servicexine.h
+endif
+
+if HAVE_LIBDDVD
+service_libenigma_service_a_SOURCES += \
+	service/servicedvd.cpp
+serviceinclude_HEADERS += \
+	service/servicedvd.h
+endif
\ Kein Zeilenumbruch am Dateiende.
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/servicedvb.cpp enigma2-nightly.patched/lib/service/servicedvb.cpp
--- enigma2-nightly.org/lib/service/servicedvb.cpp	2013-08-11 08:11:19.338306128 +0200
+++ enigma2-nightly.patched/lib/service/servicedvb.cpp	2013-08-11 08:18:50.298295931 +0200
@@ -625,6 +625,9 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/servicedvbrecord.cpp enigma2-nightly.patched/lib/service/servicedvbrecord.cpp
--- enigma2-nightly.org/lib/service/servicedvbrecord.cpp	2013-08-11 08:11:19.342306128 +0200
+++ enigma2-nightly.patched/lib/service/servicedvbrecord.cpp	2013-08-11 08:18:50.298295931 +0200
@@ -10,6 +10,10 @@
 #include <netinet/in.h>
 
 
+#if defined(__sh__)
+#include <sys/vfs.h>
+#include <linux/magic.h>
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref, bool isstreamclient): m_ref(ref)
@@ -299,9 +303,43 @@
 	
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+#if defined(__sh__)
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+		struct statfs sbuf;
+#endif
 		eDebug("Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
+#if defined(__sh__)
+		//we must creat a file for statfs
 		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0666);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0)
+		{
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!");
+		} else
+		{
+			if (sbuf.f_type == EXT3_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n");
+			else
+			if (sbuf.f_type == NFS_SUPER_MAGIC)
+			{
+				eDebug("eDVBServiceRecord - NFS Filesystem; add O_DIRECT to flags\n");
+				flags |= O_DIRECT;
+			}
+			else
+			if (sbuf.f_type == USBDEVICE_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - USB Device\n");
+			else
+			if (sbuf.f_type == SMB_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - SMBs Device\n");
+			else 
+			if (sbuf.f_type == MSDOS_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - MSDOS Device\n");
+		}
+		fd = ::open(m_filename.c_str(), flags, 0644);
+#else
+		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+#endif
 		if (fd == -1)
 		{
 			eDebug("eDVBServiceRecord - can't open recording file!");
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/serviceeplayer3.cpp enigma2-nightly.patched/lib/service/serviceeplayer3.cpp
--- enigma2-nightly.org/lib/service/serviceeplayer3.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/service/serviceeplayer3.cpp	2013-08-10 23:26:36.000000000 +0200
@@ -0,0 +1,1151 @@
+	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
+	/* it's currently hardcoded to use a big-endian alsasink as sink. */
+#include <lib/base/ebase.h>
+#include <lib/base/eerror.h>
+#include <lib/base/init_num.h>
+#include <lib/base/init.h>
+#include <lib/base/nconfig.h>
+#include <lib/base/object.h>
+#include <lib/dvb/decoder.h>
+#include <lib/components/file_eraser.h>
+#include <lib/gui/esubtitle.h>
+#include <lib/service/serviceeplayer3.h>
+#include <lib/service/service.h>
+#include <lib/gdi/gpixmap.h>
+
+#include <string>
+#include <sys/stat.h>
+
+#define HTTP_TIMEOUT 60
+
+typedef enum
+{
+	GST_PLAY_FLAG_VIDEO         = 0x00000001,
+	GST_PLAY_FLAG_AUDIO         = 0x00000002,
+	GST_PLAY_FLAG_TEXT          = 0x00000004,
+	GST_PLAY_FLAG_VIS           = 0x00000008,
+	GST_PLAY_FLAG_SOFT_VOLUME   = 0x00000010,
+	GST_PLAY_FLAG_NATIVE_AUDIO  = 0x00000020,
+	GST_PLAY_FLAG_NATIVE_VIDEO  = 0x00000040,
+	GST_PLAY_FLAG_DOWNLOAD      = 0x00000080,
+	GST_PLAY_FLAG_BUFFERING     = 0x00000100
+} GstPlayFlags;
+
+// eServiceFactoryEPlayer3
+
+/*
+ * gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
+ * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
+ * As a workaround, we run the subsink in sync=false mode
+ */
+#define GSTREAMER_SUBTITLE_SYNC_MODE_BUG
+/**/
+
+eServiceFactoryEPlayer3::eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+	{
+		std::list<std::string> extensions;
+		//extensions.push_back("dts");
+		//extensions.push_back("mp2");
+		//extensions.push_back("mp3");
+		//extensions.push_back("ogg");
+		//extensions.push_back("ogm");
+		//extensions.push_back("ogv");
+		extensions.push_back("mpg");
+		extensions.push_back("vob");
+		//extensions.push_back("wav");
+		//extensions.push_back("wave");
+		extensions.push_back("m4v");
+		extensions.push_back("mkv");
+		extensions.push_back("avi");
+		extensions.push_back("divx");
+		extensions.push_back("dat");
+		//extensions.push_back("flac");
+		//extensions.push_back("flv");
+		extensions.push_back("mp4");
+		extensions.push_back("mov");
+		//extensions.push_back("m4a");
+		//extensions.push_back("3gp");
+		//extensions.push_back("3g2");
+		//extensions.push_back("asf");
+#if defined(__sh__)
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		extensions.push_back("wmv");
+#endif
+		//extensions.push_back("wma");
+		sc->addServiceFactory(eServiceFactoryEPlayer3::id, this, extensions);
+	}
+
+	m_service_info = new eStaticServiceEPlayer3Info();
+}
+
+eServiceFactoryEPlayer3::~eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+		sc->removeServiceFactory(eServiceFactoryEPlayer3::id);
+}
+
+DEFINE_REF(eServiceFactoryEPlayer3)
+
+	// iServiceHandler
+RESULT eServiceFactoryEPlayer3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
+{
+		// check resources...
+	ptr = new eServiceEPlayer3(ref);
+	return 0;
+}
+
+RESULT eServiceFactoryEPlayer3::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::list(const eServiceReference &, ePtr<iListableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
+{
+	ptr = m_service_info;
+	return 0;
+}
+
+class eEPlayer3ServiceOfflineOperations: public iServiceOfflineOperations
+{
+	DECLARE_REF(eEPlayer3ServiceOfflineOperations);
+	eServiceReference m_ref;
+public:
+	eEPlayer3ServiceOfflineOperations(const eServiceReference &ref);
+
+	RESULT deleteFromDisk(int simulate);
+	RESULT getListOfFilenames(std::list<std::string> &);
+	RESULT reindex();
+};
+
+DEFINE_REF(eEPlayer3ServiceOfflineOperations);
+
+eEPlayer3ServiceOfflineOperations::eEPlayer3ServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReference&)ref)
+{
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::deleteFromDisk(int simulate)
+{
+	if (!simulate)
+	{
+		std::list<std::string> res;
+		if (getListOfFilenames(res))
+			return -1;
+
+		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
+		if (!eraser)
+			eDebug("FATAL !! can't get background file eraser");
+
+		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
+		{
+			eDebug("Removing %s...", i->c_str());
+			if (eraser)
+				eraser->erase(i->c_str());
+			else
+				::unlink(i->c_str());
+		}
+	}
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
+{
+	res.clear();
+	res.push_back(m_ref.path);
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::reindex()
+{
+	return -1;
+}
+
+
+RESULT eServiceFactoryEPlayer3::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
+{
+	ptr = new eEPlayer3ServiceOfflineOperations(ref);
+	return 0;
+}
+
+// eStaticServiceEPlayer3Info
+
+
+// eStaticServiceEPlayer3Info is seperated from eServiceEPlayer3 to give information
+// about unopened files.
+
+// probably eServiceEPlayer3 should use this class as well, and eStaticServiceEPlayer3Info
+// should have a database backend where ID3-files etc. are cached.
+// this would allow listing the mp3 database based on certain filters.
+
+DEFINE_REF(eStaticServiceEPlayer3Info)
+
+eStaticServiceEPlayer3Info::eStaticServiceEPlayer3Info()
+{
+}
+
+RESULT eStaticServiceEPlayer3Info::getName(const eServiceReference &ref, std::string &name)
+{
+	if ( ref.name.length() )
+		name = ref.name;
+	else
+	{
+		size_t last = ref.path.rfind('/');
+		if (last != std::string::npos)
+			name = ref.path.substr(last+1);
+		else
+			name = ref.path;
+	}
+	return 0;
+}
+
+int eStaticServiceEPlayer3Info::getLength(const eServiceReference &ref)
+{
+	return -1;
+}
+
+int eStaticServiceEPlayer3Info::getInfo(const eServiceReference &ref, int w)
+{
+	switch (w)
+	{
+	case iServiceInformation::sTimeCreate:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_mtime;
+			}
+		}
+		break;
+	case iServiceInformation::sFileSize:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_size;
+			}
+		}
+		break;
+	}
+	return iServiceInformation::resNA;
+}
+
+long long eStaticServiceEPlayer3Info::getFileSize(const eServiceReference &ref)
+{
+	struct stat s;
+	if (stat(ref.path.c_str(), &s) == 0)
+	{
+		return s.st_size;
+	}
+	return 0;
+}
+
+DEFINE_REF(eStreamBufferEPlayer3Info)
+
+eStreamBufferEPlayer3Info::eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size)
+: bufferPercentage(percentage),
+	inputRate(inputrate),
+	outputRate(outputrate),
+	bufferSpace(space),
+	bufferSize(size)
+{
+}
+
+int eStreamBufferEPlayer3Info::getBufferPercentage() const
+{
+	return bufferPercentage;
+}
+
+int eStreamBufferEPlayer3Info::getAverageInputRate() const
+{
+	return inputRate;
+}
+
+int eStreamBufferEPlayer3Info::getAverageOutputRate() const
+{
+	return outputRate;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSpace() const
+{
+	return bufferSpace;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSize() const
+{
+	return bufferSize;
+}
+
+// eServiceEPlayer3
+int eServiceEPlayer3::ac3_delay = 0,
+    eServiceEPlayer3::pcm_delay = 0;
+
+eServiceEPlayer3::eServiceEPlayer3(eServiceReference ref)
+	:m_ref(ref), m_pump(eApp, 1)
+{
+	m_subtitle_sync_timer = eTimer::create(eApp);
+	m_streamingsrc_timeout = 0;
+
+	m_currentAudioStream = -1;
+	m_currentSubtitleStream = -1;
+	m_cachedSubtitleStream = 0; /* report the first subtitle stream to be 'cached'. TODO: use an actual cache. */
+	m_subtitle_widget = 0;
+	m_currentTrickRatio = 1.0;
+	m_buffer_size = 8 * 1024 * 1024;
+
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	m_errorInfo.missing_codec = "";
+
+
+	CONNECT(m_subtitle_sync_timer->timeout, eServiceEPlayer3::pushSubtitles);
+
+	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
+
+	m_state = stIdle;
+	eDebug("eServiceEPlayer3::construct!");
+
+	const char *filename = m_ref.path.c_str();
+	const char *ext = strrchr(filename, '.');
+	if (!ext)
+		ext = filename + strlen(filename);
+
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+		;
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+		;
+	else
+		strcat(file, "file://");
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+						audio.type = atMP3;
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+						audio.type = atMP3;
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+						audio.type = atAC3;
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+						audio.type = atDTS;
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+						audio.type = atAAC;
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+						audio.type = atPCM;
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+						audio.type = atOGG;
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+						audio.type = atFLAC;
+					else
+						audio.type = atUnknown;
+
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10) ||
+							!strncmp("S_SSA", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10) ||
+							!strncmp("S_AAS", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10) ||
+							!strncmp("S_SRT", TrackList[i+1], 5))
+						sub.type = stSRT;
+					else
+						sub.type = stPlainText;
+
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+		if (player)
+			free(player);
+		player = NULL;
+	}
+	//m_state = stRunning;
+	eDebug("eServiceEPlayer3-<\n");
+}
+
+eServiceEPlayer3::~eServiceEPlayer3()
+{
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+
+	if (m_state == stRunning)
+		stop();
+}
+
+DEFINE_REF(eServiceEPlayer3);
+
+RESULT eServiceEPlayer3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+	m_event(this, evSeekableStatusChanged);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::start()
+{
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+
+	m_state = stRunning;
+
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+
+	m_event(this, evStart);
+
+	return 0;
+}
+
+void eServiceEPlayer3::sourceTimeout()
+{
+	eDebug("eServiceEPlayer3::http source timeout! issuing eof...");
+	m_event((iPlayableService*)this, evEOF);
+}
+
+RESULT eServiceEPlayer3::stop()
+{
+	if (m_state == stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+
+	if (m_state == stStopped)
+		return -1;
+
+	eDebug("eServiceEPlayer3::stop %s", m_ref.path.c_str());
+
+	if (player && player->playback && player->output)
+	{
+		player->playback->Command(player, PLAYBACK_STOP, NULL);
+		player->output->Command(player, OUTPUT_CLOSE, NULL);
+	}
+
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+	if (player)
+		free(player);
+
+	if (player != NULL)
+		player = NULL;
+
+	m_state = stStopped;
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTarget(int target)
+{
+	return -1;
+}
+
+RESULT eServiceEPlayer3::pause(ePtr<iPauseableService> &ptr)
+{
+	ptr=this;
+	m_event((iPlayableService*)this, evUpdatedInfo);
+	return 0;
+}
+
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::setSlowMotion(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setFastForward(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+}
+
+		// iPausableService
+RESULT eServiceEPlayer3::pause()
+{
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::unpause()
+{
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+	return 0;
+}
+
+	/* iSeekableService */
+RESULT eServiceEPlayer3::seek(ePtr<iSeekableService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getLength(pts_t &pts)
+{
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekToImpl(pts_t to)
+{
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekTo(pts_t to)
+{
+	RESULT ret = -1;
+
+	float pos = (to/90000.0)-10;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	ret =0;
+	return ret;
+}
+
+RESULT eServiceEPlayer3::seekRelative(int direction, pts_t to)
+{
+	pts_t ppos;
+	if (getPlayPosition(ppos) < 0) return -1;
+	ppos += to * direction;
+	if (ppos < 0)
+		ppos = 0;
+
+	float pos = direction*(to/90000.0);
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getPlayPosition(pts_t &pts)
+{
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceEPlayer3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTrickmode(int trick)
+{
+		/* trickmode is not yet supported by our dvbmediasinks. */
+	return -1;
+}
+
+RESULT eServiceEPlayer3::isCurrentlySeekable()
+{
+	return 3;
+}
+
+RESULT eServiceEPlayer3::info(ePtr<iServiceInformation>&i)
+{
+	i = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getName(std::string &name)
+{
+	std::string title = m_ref.getName();
+	if (title.empty())
+	{
+		name = m_ref.path;
+		size_t n = name.rfind('/');
+		if (n != std::string::npos)
+			name = name.substr(n + 1);
+	}
+	else
+		name = title;
+	return 0;
+}
+
+int eServiceEPlayer3::getInfo(int w)
+{
+	switch (w)
+	{
+	case sServiceref: return m_ref;
+	case sVideoHeight: return m_height;
+	case sVideoWidth: return m_width;
+	case sFrameRate: return m_framerate;
+	case sProgressive: return m_progressive;
+	case sAspect: return m_aspect;
+	case sTagTitle:
+	case sTagArtist:
+	case sTagAlbum:
+	case sTagTitleSortname:
+	case sTagArtistSortname:
+	case sTagAlbumSortname:
+	case sTagDate:
+	case sTagComposer:
+	case sTagGenre:
+	case sTagComment:
+	case sTagExtendedComment:
+	case sTagLocation:
+	case sTagHomepage:
+	case sTagDescription:
+	case sTagVersion:
+	case sTagISRC:
+	case sTagOrganization:
+	case sTagCopyright:
+	case sTagCopyrightURI:
+	case sTagContact:
+	case sTagLicense:
+	case sTagLicenseURI:
+	case sTagCodec:
+	case sTagAudioCodec:
+	case sTagVideoCodec:
+	case sTagEncoder:
+	case sTagLanguageCode:
+	case sTagKeywords:
+	case sTagChannelMode:
+	case sUser+12:
+#if not defined(__sh__)
+		return resIsString;
+#endif
+	case sTagTrackGain:
+	case sTagTrackPeak:
+	case sTagAlbumGain:
+	case sTagAlbumPeak:
+	case sTagReferenceLevel:
+	case sTagBeatsPerMinute:
+	case sTagImage:
+	case sTagPreviewImage:
+	case sTagAttachment:
+		return resIsPyObject;
+	default:
+		return resNA;
+	}
+
+	return 0;
+}
+
+std::string eServiceEPlayer3::getInfoString(int w)
+{
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+
+	return "";
+}
+
+RESULT eServiceEPlayer3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioTracks(ePtr<iAudioTrackSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::subtitle(ePtr<iSubtitleOutput> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioDelay(ePtr<iAudioDelay> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+int eServiceEPlayer3::getNumberOfTracks()
+{
+ 	return m_audioStreams.size();
+}
+
+int eServiceEPlayer3::getCurrentTrack()
+{
+	return m_currentAudioStream;
+}
+
+RESULT eServiceEPlayer3::selectTrack(unsigned int i)
+{
+	int ret = selectAudioStream(i);
+
+	return ret;
+}
+
+int eServiceEPlayer3::selectAudioStream(int i)
+{
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+}
+
+int eServiceEPlayer3::getCurrentChannel()
+{
+	return STEREO;
+}
+
+RESULT eServiceEPlayer3::selectChannel(int i)
+{
+	eDebug("eServiceEPlayer3::selectChannel(%i)",i);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
+{
+ 	if (i >= m_audioStreams.size())
+		return -2;
+
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+
+	if (info.m_language.empty())
+		info.m_language = m_audioStreams[i].language_code;
+	return 0;
+}
+
+eAutoInitPtr<eServiceFactoryEPlayer3> init_eServiceFactoryEPlayer3(eAutoInitNumbers::service+1, "eServiceFactoryEPlayer3");
+
+void eServiceEPlayer3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceEPlayer3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceEPlayer3 *_this = (eServiceEPlayer3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceEPlayer3::%s <", __func__);
+}
+
+void eServiceEPlayer3::pushSubtitles()
+{
+}
+
+RESULT eServiceEPlayer3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
+{
+	if (m_currentSubtitleStream != track.pid)
+	{
+		m_subtitle_sync_timer->stop();
+		m_subtitle_pages.clear();
+		m_prev_decoder_time = -1;
+		m_decoder_time_valid_state = 0;
+
+		m_subtitle_widget = user;
+
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&track.pid);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::disableSubtitles()
+{
+	eDebug("eServiceEPlayer3::disableSubtitles");
+
+	m_subtitle_sync_timer->stop();
+	m_subtitle_pages.clear();
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+
+	int pid = -1;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getCachedSubtitle(struct SubtitleTrack &track)
+{
+
+	bool autoturnon = eConfigManager::getConfigBoolValue("config.subtitles.pango_autoturnon", true);
+	if (!autoturnon)
+		return -1;
+
+	if (m_cachedSubtitleStream >= 0 && m_cachedSubtitleStream < (int)m_subtitleStreams.size())
+	{
+		track.type = 2;
+		track.pid = m_cachedSubtitleStream;
+		track.page_number = int(m_subtitleStreams[m_cachedSubtitleStream].type);
+		track.magazine_number = 0;
+		return 0;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::getSubtitleList(std::vector<struct SubtitleTrack> &subtitlelist)
+{
+// 	eDebug("eServiceEPlayer3::getSubtitleList");
+	int stream_idx = 0;
+
+	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
+	{
+		subtype_t type = IterSubtitleStream->type;
+		switch(type)
+		{
+		case stUnknown:
+		case stVOB:
+		case stPGS:
+			break;
+		default:
+		{
+			struct SubtitleTrack track;
+			track.type = 2;
+			track.pid = stream_idx;
+			track.page_number = int(type);
+			track.magazine_number = 0;
+			track.language_code = IterSubtitleStream->language_code;
+			subtitlelist.push_back(track);
+		}
+		}
+		stream_idx++;
+	}
+	eDebug("eServiceEPlayer3::getSubtitleList finished");
+	return 0;
+}
+
+RESULT eServiceEPlayer3::streamed(ePtr<iStreamedService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+ePtr<iStreamBufferInfo> eServiceEPlayer3::getBufferCharge()
+{
+	return new eStreamBufferEPlayer3Info(m_bufferInfo.bufferPercent, m_bufferInfo.avgInRate, m_bufferInfo.avgOutRate, m_bufferInfo.bufferingLeft, m_buffer_size);
+}
+
+int eServiceEPlayer3::setBufferSize(int size)
+{
+	m_buffer_size = size;
+	return 0;
+}
+
+int eServiceEPlayer3::getAC3Delay()
+{
+	return ac3_delay;
+}
+
+int eServiceEPlayer3::getPCMDelay()
+{
+	return pcm_delay;
+}
+
+void eServiceEPlayer3::setAC3Delay(int delay)
+{
+
+}
+
+void eServiceEPlayer3::setPCMDelay(int delay)
+{
+}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/serviceeplayer3.h enigma2-nightly.patched/lib/service/serviceeplayer3.h
--- enigma2-nightly.org/lib/service/serviceeplayer3.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/service/serviceeplayer3.h	2013-08-10 23:26:49.000000000 +0200
@@ -0,0 +1,301 @@
+#ifndef __serviceeplayer3_h
+#define __serviceeplayer3_h
+
+#include <lib/base/message.h>
+#include <lib/service/iservice.h>
+#include <lib/dvb/pmt.h>
+#include <lib/dvb/subtitle.h>
+#include <lib/dvb/teletext.h>
+
+#include <common.h>
+#include <subtitle.h>
+#define gint int
+#define gint64 int64_t
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+
+/* for subtitles */
+#include <lib/gui/esubtitle.h>
+
+class eStaticServiceEPlayer3Info;
+
+class eServiceFactoryEPlayer3: public iServiceHandler
+{
+	DECLARE_REF(eServiceFactoryEPlayer3);
+public:
+	eServiceFactoryEPlayer3();
+	virtual ~eServiceFactoryEPlayer3();
+	enum { id = 0x1003 };
+
+		// iServiceHandler
+	RESULT play(const eServiceReference &, ePtr<iPlayableService> &ptr);
+	RESULT record(const eServiceReference &, ePtr<iRecordableService> &ptr);
+	RESULT list(const eServiceReference &, ePtr<iListableService> &ptr);
+	RESULT info(const eServiceReference &, ePtr<iStaticServiceInformation> &ptr);
+	RESULT offlineOperations(const eServiceReference &, ePtr<iServiceOfflineOperations> &ptr);
+private:
+	ePtr<eStaticServiceEPlayer3Info> m_service_info;
+};
+
+class eStaticServiceEPlayer3Info: public iStaticServiceInformation
+{
+	DECLARE_REF(eStaticServiceEPlayer3Info);
+	friend class eServiceFactoryEPlayer3;
+	eStaticServiceEPlayer3Info();
+public:
+	RESULT getName(const eServiceReference &ref, std::string &name);
+	int getLength(const eServiceReference &ref);
+	int getInfo(const eServiceReference &ref, int w);
+	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore, bool simulate) { return 1; }
+	long long getFileSize(const eServiceReference &ref);
+};
+
+class eStreamBufferEPlayer3Info: public iStreamBufferInfo
+{
+	DECLARE_REF(eStreamBufferEPlayer3Info);
+	int bufferPercentage;
+	int inputRate;
+	int outputRate;
+	int bufferSpace;
+	int bufferSize;
+
+public:
+	eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size);
+
+	int getBufferPercentage() const;
+	int getAverageInputRate() const;
+	int getAverageOutputRate() const;
+	int getBufferSpace() const;
+	int getBufferSize() const;
+};
+
+class eServiceEPlayer3InfoContainer: public iServiceInfoContainer
+{
+	DECLARE_REF(eServiceEPlayer3InfoContainer);
+
+	double doubleValue;
+
+
+	unsigned char *bufferData;
+	unsigned int bufferSize;
+
+public:
+	eServiceEPlayer3InfoContainer();
+	~eServiceEPlayer3InfoContainer();
+
+	double getDouble(unsigned int index) const;
+	unsigned char *getBuffer(unsigned int &size) const;
+
+	void setDouble(double value);
+};
+
+typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
+typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
+typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA, ctASF, ctOGG } containertype_t;
+
+class eServiceEPlayer3: public iPlayableService, public iPauseableService,
+	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection, 
+	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public Object
+{
+	DECLARE_REF(eServiceEPlayer3);
+public:
+	virtual ~eServiceEPlayer3();
+
+		// iPlayableService
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT start();
+	RESULT stop();
+	RESULT setTarget(int target);
+	
+	RESULT pause(ePtr<iPauseableService> &ptr);
+	RESULT setSlowMotion(int ratio);
+	RESULT setFastForward(int ratio);
+
+	RESULT seek(ePtr<iSeekableService> &ptr);
+	RESULT audioTracks(ePtr<iAudioTrackSelection> &ptr);
+	RESULT audioChannel(ePtr<iAudioChannelSelection> &ptr);
+	RESULT subtitle(ePtr<iSubtitleOutput> &ptr);
+	RESULT audioDelay(ePtr<iAudioDelay> &ptr);
+
+		// not implemented (yet)
+	RESULT frontendInfo(ePtr<iFrontendInformation> &ptr) { ptr = 0; return -1; }
+	RESULT subServices(ePtr<iSubserviceList> &ptr) { ptr = 0; return -1; }
+	RESULT timeshift(ePtr<iTimeshiftService> &ptr) { ptr = 0; return -1; }
+	RESULT cueSheet(ePtr<iCueSheet> &ptr) { ptr = 0; return -1; }
+
+	RESULT rdsDecoder(ePtr<iRdsDecoder> &ptr) { ptr = 0; return -1; }
+	RESULT keys(ePtr<iServiceKeys> &ptr) { ptr = 0; return -1; }
+	RESULT stream(ePtr<iStreamableService> &ptr) { ptr = 0; return -1; }
+
+		// iPausableService
+	RESULT pause();
+	RESULT unpause();
+	
+	RESULT info(ePtr<iServiceInformation>&);
+	
+		// iSeekableService
+	RESULT getLength(pts_t &SWIG_OUTPUT);
+	RESULT seekTo(pts_t to);
+	RESULT seekRelative(int direction, pts_t to);
+	RESULT getPlayPosition(pts_t &SWIG_OUTPUT);
+	RESULT setTrickmode(int trick);
+	RESULT isCurrentlySeekable();
+
+		// iServiceInformation
+	RESULT getName(std::string &name);
+	int getInfo(int w);
+	std::string getInfoString(int w);
+
+		// iAudioTrackSelection	
+	int getNumberOfTracks();
+	RESULT selectTrack(unsigned int i);
+	RESULT getTrackInfo(struct iAudioTrackInfo &, unsigned int n);
+	int getCurrentTrack();
+
+		// iAudioChannelSelection	
+	int getCurrentChannel();
+	RESULT selectChannel(int i);
+
+		// iSubtitleOutput
+	RESULT enableSubtitles(iSubtitleUser *user, SubtitleTrack &track);
+	RESULT disableSubtitles();
+	RESULT getSubtitleList(std::vector<SubtitleTrack> &sublist);
+	RESULT getCachedSubtitle(SubtitleTrack &track);
+
+		// iStreamedService
+	RESULT streamed(ePtr<iStreamedService> &ptr);
+	ePtr<iStreamBufferInfo> getBufferCharge();
+	int setBufferSize(int size);
+
+		// iAudioDelay
+	int getAC3Delay();
+	int getPCMDelay();
+	void setAC3Delay(int);
+	void setPCMDelay(int);
+
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+
+	struct bufferInfo
+	{
+		gint bufferPercent;
+		gint avgInRate;
+		gint avgOutRate;
+		gint64 bufferingLeft;
+		bufferInfo()
+			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
+		{
+		}
+	};
+	struct errorInfo
+	{
+		std::string error_message;
+		std::string missing_codec;
+	};
+
+private:
+	static int pcm_delay;
+	static int ac3_delay;
+	int m_currentAudioStream;
+	int m_currentSubtitleStream;
+	int m_cachedSubtitleStream;
+	int selectAudioStream(int i);
+	std::vector<audioStream> m_audioStreams;
+	std::vector<subtitleStream> m_subtitleStreams;
+	iSubtitleUser *m_subtitle_widget;
+
+	int m_currentTrickRatio;
+
+	friend class eServiceFactoryEPlayer3;
+	eServiceReference m_ref;
+	int m_buffer_size;
+
+	bufferInfo m_bufferInfo;
+	errorInfo m_errorInfo;
+	std::string m_download_buffer_path;
+	eServiceEPlayer3(eServiceReference ref);
+	Signal2<void,iPlayableService*,int> m_event;
+	enum
+	{
+		stIdle, stRunning, stStopped,
+	};
+	int m_state;
+
+	Context_t * player;
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+
+	struct subtitle_page_t
+	{
+		uint32_t start_ms;
+		uint32_t end_ms;
+		std::string text;
+
+		subtitle_page_t(uint32_t start_ms_in, uint32_t end_ms_in, std::string text_in)
+			: start_ms(start_ms_in), end_ms(end_ms_in), text(text_in)
+		{
+		}
+	};
+
+	typedef std::map<uint32_t, subtitle_page_t> subtitle_pages_map_t;
+	typedef std::pair<uint32_t, subtitle_page_t> subtitle_pages_map_pair_t;
+	subtitle_pages_map_t m_subtitle_pages;
+	ePtr<eTimer> m_subtitle_sync_timer;
+	
+	ePtr<eTimer> m_streamingsrc_timeout;
+	pts_t m_prev_decoder_time;
+	int m_decoder_time_valid_state;
+
+	void pushSubtitles();
+
+	void sourceTimeout();
+	sourceStream m_sourceinfo;
+
+	RESULT seekToImpl(pts_t to);
+
+	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
+	std::string m_useragent;
+};
+
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/servicemp3.cpp enigma2-nightly.patched/lib/service/servicemp3.cpp
--- enigma2-nightly.org/lib/service/servicemp3.cpp	2013-08-11 08:11:19.342306128 +0200
+++ enigma2-nightly.patched/lib/service/servicemp3.cpp	2013-08-11 09:44:43.138179413 +0200
@@ -15,8 +15,10 @@
 
 #include <string>
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
+#endif
 #include <sys/stat.h>
 
 #define HTTP_TIMEOUT 30
@@ -58,24 +60,49 @@
 		extensions.push_back("ogg");
 		extensions.push_back("ogm");
 		extensions.push_back("ogv");
-		extensions.push_back("mpg");
-		extensions.push_back("vob");
 		extensions.push_back("wav");
 		extensions.push_back("wave");
-		extensions.push_back("m4v");
-		extensions.push_back("mkv");
-		extensions.push_back("avi");
-		extensions.push_back("divx");
-		extensions.push_back("dat");
 		extensions.push_back("flac");
 		extensions.push_back("flv");
-		extensions.push_back("mp4");
-		extensions.push_back("mov");
 		extensions.push_back("m4a");
 		extensions.push_back("3gp");
 		extensions.push_back("3g2");
 		extensions.push_back("asf");
-		extensions.push_back("wmv");
+#if defined(__sh__)
+#if !defined(ENABLE_MEDIAFWGSTREAMER) || !defined(ENABLE_MEDIAFWGSTREAMER)
+/* Hellmaster1024: if both gst and eplayer3 are enabled, this is the GST service!
+ * We only select the audio extensions (above), and leave the Video extensions for
+ * the ePlayer3 service located in serviceeplayer3
+ * If only one of GST and ePlayer3 this service handles all extensions and switches between
+ * GST and ePlayer3
+*/
+		extensions.push_back("m4v");
+		extensions.push_back("mkv");
+		extensions.push_back("avi");
+		extensions.push_back("divx");
+		extensions.push_back("dat");		
+		extensions.push_back("mpg");
+		extensions.push_back("vob");		
+		extensions.push_back("mp4");
+		extensions.push_back("mov");		
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		int fd = open("/proc/stb/info/model", O_RDONLY);
+		char tmp[255];
+		int rd = fd >= 0 ? read(fd, tmp, 255) : 0;
+		if (fd >= 0)
+			close(fd);
+		if (!strncmp(tmp, "ufs912\n", rd) || !strncmp(tmp, "ufs913\n", rd) || !strncmp(tmp, "atevio7500\n", rd) || !strncmp(tmp, "hs7110\n", rd) || !strncmp(tmp, "hs7810a\n", rd) || !strncmp(tmp, "spark7162\n", rd) || !strncmp(tmp, "whitebox\n", rd))
+			extensions.push_back("wmv");
+#endif
+#endif
 		extensions.push_back("wma");
 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
 	}
@@ -289,6 +316,7 @@
 	return bufferSize;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(eServiceMP3InfoContainer);
 
 eServiceMP3InfoContainer::eServiceMP3InfoContainer()
@@ -339,6 +367,7 @@
 	bufferSize = map.size;
 #endif
 }
+#endif
 
 // eServiceMP3
 int eServiceMP3::ac3_delay = 0,
@@ -349,25 +378,33 @@
 {
 	m_subtitle_sync_timer = eTimer::create(eApp);
 	m_streamingsrc_timeout = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_stream_tags = 0;
+#endif
 	m_currentAudioStream = -1;
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = 0; /* report the first subtitle stream to be 'cached'. TODO: use an actual cache. */
 	m_subtitle_widget = 0;
 	m_currentTrickRatio = 1.0;
 	m_buffer_size = 5 * 1024 * 1024;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_ignore_buffering_messages = 0;
 	m_is_live = false;
 	m_use_prefillbuffer = false;
 	m_extra_headers = "";
 	m_download_buffer_path = "";
+#endif
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	m_errorInfo.missing_codec = "";
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	audioSink = videoSink = NULL;
+#endif
 
 	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
+#endif
 	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
 
 	m_state = stIdle;
@@ -378,6 +415,7 @@
 	if (!ext)
 		ext = filename + strlen(filename);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_sourceinfo.is_video = FALSE;
 	m_sourceinfo.audiotype = atUnknown;
 	if ( (strcasecmp(ext, ".mpeg") && strcasecmp(ext, ".mpg") && strcasecmp(ext, ".vob") && strcasecmp(ext, ".bin") && strcasecmp(ext, ".dat") ) == 0 )
@@ -559,10 +597,177 @@
 		eDebug("eServiceMP3::sorry, can't play: %s",m_errorInfo.error_message.c_str());
 	}
 	g_free(uri);
+#else
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+		;
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+		;
+	else
+		strcat(file, "file://");
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+						audio.type = atMP3;
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+						audio.type = atMP3;
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+						audio.type = atAC3;
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+						audio.type = atDTS;
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+						audio.type = atAAC;
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+						audio.type = atPCM;
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+						audio.type = atOGG;
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+						audio.type = atFLAC;
+					else
+						audio.type = atUnknown;
+
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10) ||
+							!strncmp("S_SSA", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10) ||
+							!strncmp("S_AAS", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10) ||
+							!strncmp("S_SRT", TrackList[i+1], 5))
+						sub.type = stSRT;
+					else
+						sub.type = stPlainText;
+
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+		if (player)
+			free(player);
+		player = NULL;
+	}
+	//m_state = stRunning;
+	eDebug("eServiceMP3-<\n");
+#endif
 }
 
 eServiceMP3::~eServiceMP3()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	// disconnect subtitle callback
 	GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
 
@@ -571,10 +776,12 @@
 		g_signal_handler_disconnect (subsink, m_subs_to_pull_handler_id);
 		gst_object_unref(subsink);
 	}
+#endif
 
 	if (m_subtitle_widget) m_subtitle_widget->destroy();
 	m_subtitle_widget = 0;
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		// disconnect sync handler callback
@@ -586,10 +793,12 @@
 #endif
 		gst_object_unref(bus);
 	}
+#endif
 
 	if (m_state == stRunning)
 		stop();
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_stream_tags)
 		gst_tag_list_free(m_stream_tags);
 
@@ -608,28 +817,51 @@
 		gst_object_unref (GST_OBJECT (m_gst_playbin));
 		eDebug("eServiceMP3::destruct!");
 	}
+#endif
 }
 
 DEFINE_REF(eServiceMP3);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(eServiceMP3::GstMessageContainer);
+#endif
 
 RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	m_event(this, evSeekableStatusChanged);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::start()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ASSERT(m_state == stIdle);
+#else
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+#endif
 
 	m_state = stRunning;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		eDebug("eServiceMP3::starting pipeline");
 		gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
 	}
+#else
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+#endif
 
 	m_event(this, evStart);
 
@@ -644,13 +876,45 @@
 
 RESULT eServiceMP3::stop()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ASSERT(m_state != stIdle);
+#else
+	if (m_state == stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+#endif
 
 	if (m_state == stStopped)
 		return -1;
 
 	eDebug("eServiceMP3::stop %s", m_ref.path.c_str());
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
+#else
+	if (player && player->playback && player->output)
+	{
+		player->playback->Command(player, PLAYBACK_STOP, NULL);
+		player->output->Command(player, OUTPUT_CLOSE, NULL);
+	}
+
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+	if (player)
+		free(player);
+
+	if (player != NULL)
+		player = NULL;
+#endif
 	m_state = stStopped;
 
 	return 0;
@@ -664,40 +928,126 @@
 RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
 {
 	ptr=this;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	m_event((iPlayableService*)this, evUpdatedInfo);
+#endif
 	return 0;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+#endif
+
 RESULT eServiceMP3::setSlowMotion(int ratio)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!ratio)
 		return 0;
 	eDebug("eServiceMP3::setSlowMotion ratio=%f",1.0/(gdouble)ratio);
 	return trickSeek(1.0/(gdouble)ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 RESULT eServiceMP3::setFastForward(int ratio)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
 	return trickSeek(ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 		// iPausableService
 RESULT eServiceMP3::pause()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	trickSeek(0.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#endif
 
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	trickSeek(1.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#endif
 
 	return 0;
 }
@@ -711,6 +1061,7 @@
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin)
 		return -1;
 
@@ -728,11 +1079,23 @@
 		/* len is in nanoseconds. we have 90 000 pts per second. */
 
 	pts = len / 11111LL;
+#else
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		/* convert pts to nanoseconds */
 	gint64 time_nanoseconds = to * 11111LL;
 	if (!gst_element_seek (m_gst_playbin, m_currentTrickRatio, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
@@ -742,6 +1105,7 @@
 		eDebug("eServiceMP3::seekTo failed");
 		return -1;
 	}
+#endif
 
 	return 0;
 }
@@ -750,17 +1114,25 @@
 {
 	RESULT ret = -1;
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
 		ret = seekToImpl(to);
 	}
+#else
+	float pos = (to/90000.0)-10;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
 
+	ret =0;
+#endif
 	return ret;
 }
 
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 RESULT eServiceMP3::trickSeek(gdouble ratio)
 {
 	if (!m_gst_playbin)
@@ -801,28 +1173,41 @@
 	m_decoder_time_valid_state = 0;
 	return 0;
 }
+#endif
 
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin)
 		return -1;
-
+#endif
 	pts_t ppos;
 	if (getPlayPosition(ppos) < 0) return -1;
 	ppos += to * direction;
 	if (ppos < 0)
 		ppos = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	return seekTo(ppos);
+#else
+	float pos = direction*(to/90000.0);
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	return 0;
+#endif
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 gint eServiceMP3::match_sinktype(GstElement *element, gpointer type)
 {
 	return strcmp(g_type_name(G_OBJECT_TYPE(element)), (const char*)type);
 }
+#endif
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gint64 pos;
 	pts = 0;
 
@@ -852,6 +1237,27 @@
 
 	/* pos is in nanoseconds. we have 90 000 pts per second. */
 	pts = pos / 11111LL;
+#else
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+#endif
 	return 0;
 }
 
@@ -863,6 +1269,7 @@
 
 RESULT eServiceMP3::isCurrentlySeekable()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER // Hellmaster1024: 1 for skipping 3 for skipping anf fast forward
 	int ret = 3; /* just assume that seeking and fast/slow winding are possible */
 
 	if (!m_gst_playbin)
@@ -871,6 +1278,9 @@
 		return 0;
 
 	return ret;
+#else
+	return 3;
+#endif
 }
 
 RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
@@ -896,7 +1306,9 @@
 
 int eServiceMP3::getInfo(int w)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	const gchar *tag = 0;
+#endif
 
 	switch (w)
 	{
@@ -936,7 +1348,9 @@
 	case sTagKeywords:
 	case sTagChannelMode:
 	case sUser+12:
+#if not defined(__sh__)
 		return resIsString;
+#endif
 	case sTagTrackGain:
 	case sTagTrackPeak:
 	case sTagAlbumGain:
@@ -947,6 +1361,7 @@
 	case sTagPreviewImage:
 	case sTagAttachment:
 		return resIsPyObject;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	case sTagTrackNumber:
 		tag = GST_TAG_TRACK_NUMBER;
 		break;
@@ -980,22 +1395,26 @@
 	case sTagCRC:
 		tag = "has-crc";
 		break;
+#endif
 	default:
 		return resNA;
 	}
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_stream_tags || !tag)
 		return 0;
 
 	guint value;
 	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
 		return (int) value;
+#endif
 
 	return 0;
 }
 
 std::string eServiceMP3::getInfoString(int w)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if ( !m_stream_tags && w < sUser && w > 26 )
 		return "";
 	const gchar *tag = 0;
@@ -1108,9 +1527,69 @@
 		g_free(value);
 		return res;
 	}
+#else
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+#endif
 	return "";
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 ePtr<iServiceInfoContainer> eServiceMP3::getInfoObject(int w)
 {
 	eServiceMP3InfoContainer *container = new eServiceMP3InfoContainer;
@@ -1174,6 +1653,7 @@
 	}
 	return retval;
 }
+#endif
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
 {
@@ -1206,13 +1686,16 @@
 
 int eServiceMP3::getCurrentTrack()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_currentAudioStream == -1)
 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+#endif
 	return m_currentAudioStream;
 }
 
 RESULT eServiceMP3::selectTrack(unsigned int i)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	bool validposition = false;
 	pts_t ppos = 0;
 	if (getPlayPosition(ppos) >= 0)
@@ -1222,8 +1705,10 @@
 		if (ppos < 0)
 			ppos = 0;
 	}
+#endif
 
 	int ret = selectAudioStream(i);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!ret)
 	{
 		if (validposition)
@@ -1232,12 +1717,14 @@
 			seekTo(ppos);
 		}
 	}
+#endif
 
 	return ret;
 }
 
 int eServiceMP3::selectAudioStream(int i)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	int current_audio;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
@@ -1248,6 +1735,16 @@
 		return 0;
 	}
 	return -1;
+#else
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+#endif
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1265,6 +1762,7 @@
 {
  	if (i >= m_audioStreams.size())
 		return -2;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		info.m_description = m_audioStreams[i].codec;
 /*	if (m_audioStreams[i].type == atMPEG)
 		info.m_description = "MPEG";
@@ -1284,11 +1782,28 @@
 		info.m_description = "FLAC";
 	else
 		info.m_description = "???";*/
+#else
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+#endif
 	if (info.m_language.empty())
 		info.m_language = m_audioStreams[i].language_code;
 	return 0;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
 {
 	subtype_t type = stUnknown;
@@ -2008,9 +2523,11 @@
 		}
 	}
 }
+#endif
 
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 void eServiceMP3::gstCBsubtitleAvail(GstElement *subsink, GstBuffer *buffer, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
@@ -2138,9 +2655,30 @@
 		}
 	}
 }
+#else
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif
 
 void eServiceMP3::pushSubtitles()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	pts_t running_pts = 0;
 	int32_t next_timer = 0, decoder_ms, start_ms, end_ms, diff_start_ms, diff_end_ms;
 	subtitle_pages_map_t::iterator current;
@@ -2243,23 +2781,30 @@
 	m_subtitle_sync_timer->start(next_timer, true);
 
 	eDebug("\n\n");
+
+#endif
 }
 
 RESULT eServiceMP3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
 {
 	if (m_currentSubtitleStream != track.pid)
-	{
+	{	
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", -1, NULL);
+#endif
 		m_subtitle_sync_timer->stop();
 		m_subtitle_pages.clear();
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		m_currentSubtitleStream = track.pid;
 		m_cachedSubtitleStream = m_currentSubtitleStream;
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 
 		m_subtitle_widget = user;
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		eDebug ("eServiceMP3::switched to subtitle stream %i", m_currentSubtitleStream);
 
 #ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
@@ -2269,7 +2814,13 @@
 		 */
 		seekRelative(-1, 90000);
 #endif
+#endif
 	}
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 
 	return 0;
 }
@@ -2277,15 +2828,23 @@
 RESULT eServiceMP3::disableSubtitles()
 {
 	eDebug("eServiceMP3::disableSubtitles");
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = m_currentSubtitleStream;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 	m_subtitle_sync_timer->stop();
 	m_subtitle_pages.clear();
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	if (m_subtitle_widget) m_subtitle_widget->destroy();
 	m_subtitle_widget = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	int pid = -1;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 	return 0;
 }
 
@@ -2352,7 +2911,9 @@
 int eServiceMP3::setBufferSize(int size)
 {
 	m_buffer_size = size;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
 	return 0;
 }
 
@@ -2368,6 +2929,7 @@
 
 void eServiceMP3::setAC3Delay(int delay)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ac3_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -2395,10 +2957,12 @@
 			eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
 		}
 	}
+#endif
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	pcm_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -2426,4 +2990,5 @@
 			eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
 		}
 	}
+#endif
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/servicemp3.cpp~ enigma2-nightly.patched/lib/service/servicemp3.cpp~
--- enigma2-nightly.org/lib/service/servicemp3.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/service/servicemp3.cpp~	2013-08-11 09:42:11.078182851 +0200
@@ -0,0 +1,2994 @@
+	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
+	/* it's currently hardcoded to use a big-endian alsasink as sink. */
+#include <lib/base/ebase.h>
+#include <lib/base/eerror.h>
+#include <lib/base/init_num.h>
+#include <lib/base/init.h>
+#include <lib/base/nconfig.h>
+#include <lib/base/object.h>
+#include <lib/dvb/decoder.h>
+#include <lib/components/file_eraser.h>
+#include <lib/gui/esubtitle.h>
+#include <lib/service/servicemp3.h>
+#include <lib/service/service.h>
+#include <lib/gdi/gpixmap.h>
+
+#include <string>
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#include <gst/gst.h>
+#include <gst/pbutils/missing-plugins.h>
+#endif
+#include <sys/stat.h>
+
+#define HTTP_TIMEOUT 30
+
+typedef enum
+{
+	GST_PLAY_FLAG_VIDEO         = 0x00000001,
+	GST_PLAY_FLAG_AUDIO         = 0x00000002,
+	GST_PLAY_FLAG_TEXT          = 0x00000004,
+	GST_PLAY_FLAG_VIS           = 0x00000008,
+	GST_PLAY_FLAG_SOFT_VOLUME   = 0x00000010,
+	GST_PLAY_FLAG_NATIVE_AUDIO  = 0x00000020,
+	GST_PLAY_FLAG_NATIVE_VIDEO  = 0x00000040,
+	GST_PLAY_FLAG_DOWNLOAD      = 0x00000080,
+	GST_PLAY_FLAG_BUFFERING     = 0x00000100
+} GstPlayFlags;
+
+// eServiceFactoryMP3
+
+/*
+ * gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
+ * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
+ * As a workaround, we run the subsink in sync=false mode
+ */
+#define GSTREAMER_SUBTITLE_SYNC_MODE_BUG
+/**/
+
+eServiceFactoryMP3::eServiceFactoryMP3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+	{
+		std::list<std::string> extensions;
+		extensions.push_back("dts");
+		extensions.push_back("mp2");
+		extensions.push_back("mp3");
+		extensions.push_back("ogg");
+		extensions.push_back("ogm");
+		extensions.push_back("ogv");
+		extensions.push_back("wav");
+		extensions.push_back("wave");
+		extensions.push_back("flac");
+		extensions.push_back("flv");
+		extensions.push_back("m4a");
+		extensions.push_back("3gp");
+		extensions.push_back("3g2");
+		extensions.push_back("asf");
+#if defined(__sh__)
+#if !defined(ENABLE_MEDIAFWGSTREAMER) || !defined(ENABLE_MEDIAFWGSTREAMER)
+/* Hellmaster1024: if both gst and eplayer3 are enabled, this is the GST service!
+ * We only select the audio extensions (above), and leave the Video extensions for
+ * the ePlayer3 service located in serviceeplayer3
+ * If only one of GST and ePlayer3 this service handles all extensions and switches between
+ * GST and ePlayer3
+*/
+		extensions.push_back("m4v");
+		extensions.push_back("mkv");
+		extensions.push_back("avi");
+		extensions.push_back("divx");
+		extensions.push_back("dat");		
+		extensions.push_back("mpg");
+		extensions.push_back("vob");		
+		extensions.push_back("mp4");
+		extensions.push_back("mov");		
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		int fd = open("/proc/stb/info/model", O_RDONLY);
+		char tmp[255];
+		int rd = fd >= 0 ? read(fd, tmp, 255) : 0;
+		if (fd >= 0)
+			close(fd);
+		if (!strncmp(tmp, "ufs912\n", rd) || !strncmp(tmp, "ufs913\n", rd) || !strncmp(tmp, "atevio7500\n", rd) || !strncmp(tmp, "hs7110\n", rd) || !strncmp(tmp, "hs7810a\n", rd) || !strncmp(tmp, "spark7162\n", rd) || !strncmp(tmp, "whitebox\n", rd))
+			extensions.push_back("wmv");
+#endif
+#endif
+		extensions.push_back("wma");
+		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
+	}
+
+	m_service_info = new eStaticServiceMP3Info();
+}
+
+eServiceFactoryMP3::~eServiceFactoryMP3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+		sc->removeServiceFactory(eServiceFactoryMP3::id);
+}
+
+DEFINE_REF(eServiceFactoryMP3)
+
+	// iServiceHandler
+RESULT eServiceFactoryMP3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
+{
+		// check resources...
+	ptr = new eServiceMP3(ref);
+	return 0;
+}
+
+RESULT eServiceFactoryMP3::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryMP3::list(const eServiceReference &, ePtr<iListableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryMP3::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
+{
+	ptr = m_service_info;
+	return 0;
+}
+
+class eMP3ServiceOfflineOperations: public iServiceOfflineOperations
+{
+	DECLARE_REF(eMP3ServiceOfflineOperations);
+	eServiceReference m_ref;
+public:
+	eMP3ServiceOfflineOperations(const eServiceReference &ref);
+
+	RESULT deleteFromDisk(int simulate);
+	RESULT getListOfFilenames(std::list<std::string> &);
+	RESULT reindex();
+};
+
+DEFINE_REF(eMP3ServiceOfflineOperations);
+
+eMP3ServiceOfflineOperations::eMP3ServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReference&)ref)
+{
+}
+
+RESULT eMP3ServiceOfflineOperations::deleteFromDisk(int simulate)
+{
+	if (!simulate)
+	{
+		std::list<std::string> res;
+		if (getListOfFilenames(res))
+			return -1;
+
+		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
+		if (!eraser)
+			eDebug("FATAL !! can't get background file eraser");
+
+		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
+		{
+			eDebug("Removing %s...", i->c_str());
+			if (eraser)
+				eraser->erase(i->c_str());
+			else
+				::unlink(i->c_str());
+		}
+	}
+	return 0;
+}
+
+RESULT eMP3ServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
+{
+	res.clear();
+	res.push_back(m_ref.path);
+	return 0;
+}
+
+RESULT eMP3ServiceOfflineOperations::reindex()
+{
+	return -1;
+}
+
+
+RESULT eServiceFactoryMP3::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
+{
+	ptr = new eMP3ServiceOfflineOperations(ref);
+	return 0;
+}
+
+// eStaticServiceMP3Info
+
+
+// eStaticServiceMP3Info is seperated from eServiceMP3 to give information
+// about unopened files.
+
+// probably eServiceMP3 should use this class as well, and eStaticServiceMP3Info
+// should have a database backend where ID3-files etc. are cached.
+// this would allow listing the mp3 database based on certain filters.
+
+DEFINE_REF(eStaticServiceMP3Info)
+
+eStaticServiceMP3Info::eStaticServiceMP3Info()
+{
+}
+
+RESULT eStaticServiceMP3Info::getName(const eServiceReference &ref, std::string &name)
+{
+	if ( ref.name.length() )
+		name = ref.name;
+	else
+	{
+		size_t last = ref.path.rfind('/');
+		if (last != std::string::npos)
+			name = ref.path.substr(last+1);
+		else
+			name = ref.path;
+	}
+	return 0;
+}
+
+int eStaticServiceMP3Info::getLength(const eServiceReference &ref)
+{
+	return -1;
+}
+
+int eStaticServiceMP3Info::getInfo(const eServiceReference &ref, int w)
+{
+	switch (w)
+	{
+	case iServiceInformation::sTimeCreate:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_mtime;
+			}
+		}
+		break;
+	case iServiceInformation::sFileSize:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_size;
+			}
+		}
+		break;
+	}
+	return iServiceInformation::resNA;
+}
+
+long long eStaticServiceMP3Info::getFileSize(const eServiceReference &ref)
+{
+	struct stat s;
+	if (stat(ref.path.c_str(), &s) == 0)
+	{
+		return s.st_size;
+	}
+	return 0;
+}
+
+DEFINE_REF(eStreamBufferInfo)
+
+eStreamBufferInfo::eStreamBufferInfo(int percentage, int inputrate, int outputrate, int space, int size)
+: bufferPercentage(percentage),
+	inputRate(inputrate),
+	outputRate(outputrate),
+	bufferSpace(space),
+	bufferSize(size)
+{
+}
+
+int eStreamBufferInfo::getBufferPercentage() const
+{
+	return bufferPercentage;
+}
+
+int eStreamBufferInfo::getAverageInputRate() const
+{
+	return inputRate;
+}
+
+int eStreamBufferInfo::getAverageOutputRate() const
+{
+	return outputRate;
+}
+
+int eStreamBufferInfo::getBufferSpace() const
+{
+	return bufferSpace;
+}
+
+int eStreamBufferInfo::getBufferSize() const
+{
+	return bufferSize;
+}
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+DEFINE_REF(eServiceMP3InfoContainer);
+
+eServiceMP3InfoContainer::eServiceMP3InfoContainer()
+: doubleValue(0.0), bufferValue(NULL), bufferData(NULL), bufferSize(0)
+{
+}
+
+eServiceMP3InfoContainer::~eServiceMP3InfoContainer()
+{
+	if (bufferValue)
+	{
+#if GST_VERSION_MAJOR >= 1
+		gst_buffer_unmap(bufferValue, &map);
+#endif
+		gst_buffer_unref(bufferValue);
+		bufferValue = NULL;
+		bufferData = NULL;
+		bufferSize = 0;
+	}
+}
+
+double eServiceMP3InfoContainer::getDouble(unsigned int index) const
+{
+	return doubleValue;
+}
+
+unsigned char *eServiceMP3InfoContainer::getBuffer(unsigned int &size) const
+{
+	size = bufferSize;
+	return bufferData;
+}
+
+void eServiceMP3InfoContainer::setDouble(double value)
+{
+	doubleValue = value;
+}
+
+void eServiceMP3InfoContainer::setBuffer(GstBuffer *buffer)
+{
+	bufferValue = buffer;
+	gst_buffer_ref(bufferValue);
+#if GST_VERSION_MAJOR < 1
+	bufferData = GST_BUFFER_DATA(bufferValue);
+	bufferSize = GST_BUFFER_SIZE(bufferValue);
+#else
+	gst_buffer_map(bufferValue, &map, GST_MAP_READ);
+	bufferData = map.data;
+	bufferSize = map.size;
+#endif
+}
+#endif
+
+// eServiceMP3
+int eServiceMP3::ac3_delay = 0,
+    eServiceMP3::pcm_delay = 0;
+
+eServiceMP3::eServiceMP3(eServiceReference ref)
+	:m_ref(ref), m_pump(eApp, 1)
+{
+	m_subtitle_sync_timer = eTimer::create(eApp);
+	m_streamingsrc_timeout = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	m_stream_tags = 0;
+#endif
+	m_currentAudioStream = -1;
+	m_currentSubtitleStream = -1;
+	m_cachedSubtitleStream = 0; /* report the first subtitle stream to be 'cached'. TODO: use an actual cache. */
+	m_subtitle_widget = 0;
+	m_currentTrickRatio = 1.0;
+	m_buffer_size = 5 * 1024 * 1024;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	m_ignore_buffering_messages = 0;
+	m_is_live = false;
+	m_use_prefillbuffer = false;
+	m_extra_headers = "";
+	m_download_buffer_path = "";
+#endif
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	m_errorInfo.missing_codec = "";
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	audioSink = videoSink = NULL;
+#endif
+
+	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
+#endif
+	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
+
+	m_state = stIdle;
+	eDebug("eServiceMP3::construct!");
+
+	const char *filename = m_ref.path.c_str();
+	const char *ext = strrchr(filename, '.');
+	if (!ext)
+		ext = filename + strlen(filename);
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	m_sourceinfo.is_video = FALSE;
+	m_sourceinfo.audiotype = atUnknown;
+	if ( (strcasecmp(ext, ".mpeg") && strcasecmp(ext, ".mpg") && strcasecmp(ext, ".vob") && strcasecmp(ext, ".bin") && strcasecmp(ext, ".dat") ) == 0 )
+	{
+		m_sourceinfo.containertype = ctMPEGPS;
+		m_sourceinfo.is_video = TRUE;
+	}
+	else if ( strcasecmp(ext, ".ts") == 0 )
+	{
+		m_sourceinfo.containertype = ctMPEGTS;
+		m_sourceinfo.is_video = TRUE;
+	}
+	else if ( strcasecmp(ext, ".mkv") == 0 )
+	{
+		m_sourceinfo.containertype = ctMKV;
+		m_sourceinfo.is_video = TRUE;
+	}
+	else if ( strcasecmp(ext, ".ogm") == 0 || strcasecmp(ext, ".ogv") == 0)
+	{
+		m_sourceinfo.containertype = ctOGG;
+		m_sourceinfo.is_video = TRUE;
+	}
+	else if ( strcasecmp(ext, ".avi") == 0 || strcasecmp(ext, ".divx") == 0)
+	{
+		m_sourceinfo.containertype = ctAVI;
+		m_sourceinfo.is_video = TRUE;
+	}
+	else if ( strcasecmp(ext, ".mp4") == 0 || strcasecmp(ext, ".mov") == 0 || strcasecmp(ext, ".m4v") == 0 || strcasecmp(ext, ".3gp") == 0 || strcasecmp(ext, ".3g2") == 0)
+	{
+		m_sourceinfo.containertype = ctMP4;
+		m_sourceinfo.is_video = TRUE;
+	}
+	else if ( strcasecmp(ext, ".asf") == 0 || strcasecmp(ext, ".wmv") == 0)
+	{
+		m_sourceinfo.containertype = ctASF;
+		m_sourceinfo.is_video = TRUE;
+	}
+	else if ( strcasecmp(ext, ".m4a") == 0 )
+	{
+		m_sourceinfo.containertype = ctMP4;
+		m_sourceinfo.audiotype = atAAC;
+	}
+	else if ( strcasecmp(ext, ".mp3") == 0 )
+		m_sourceinfo.audiotype = atMP3;
+	else if ( strcasecmp(ext, ".wma") == 0 )
+		m_sourceinfo.audiotype = atWMA;
+	else if ( (strncmp(filename, "/autofs/", 8) || strncmp(filename+strlen(filename)-13, "/track-", 7) || strcasecmp(ext, ".wav")) == 0 )
+		m_sourceinfo.containertype = ctCDA;
+	if ( strcasecmp(ext, ".dat") == 0 )
+	{
+		m_sourceinfo.containertype = ctVCD;
+		m_sourceinfo.is_video = TRUE;
+	}
+	if ( strstr(filename, "://") )
+		m_sourceinfo.is_streaming = TRUE;
+
+	gchar *uri;
+
+	if ( m_sourceinfo.is_streaming )
+	{
+		uri = g_strdup_printf ("%s", filename);
+		m_streamingsrc_timeout = eTimer::create(eApp);;
+		CONNECT(m_streamingsrc_timeout->timeout, eServiceMP3::sourceTimeout);
+
+		std::string config_str;
+		if (eConfigManager::getConfigBoolValue("config.mediaplayer.useAlternateUserAgent"))
+		{
+			m_useragent = eConfigManager::getConfigValue("config.mediaplayer.alternateUserAgent");
+		}
+		if (m_useragent.empty())
+			m_useragent = "Enigma2 Mediaplayer";
+		m_extra_headers = eConfigManager::getConfigValue("config.mediaplayer.extraHeaders");
+		if (strstr(filename, " buffer=1"))
+		{
+			m_use_prefillbuffer = true;
+		}
+		else if (strstr(filename, " buffer=2"))
+		{
+			/* progressive download buffering */
+			if (::access("/hdd/movie", X_OK) >= 0)
+			{
+				/* It looks like /hdd points to a valid mount, so we can store a download buffer on it */
+				m_download_buffer_path = "/hdd/gstreamer_XXXXXXXXXX";
+			}
+			m_use_prefillbuffer = true;
+		}
+	}
+	else if ( m_sourceinfo.containertype == ctCDA )
+	{
+		int i_track = atoi(filename+18);
+		uri = g_strdup_printf ("cdda://%i", i_track);
+	}
+	else if ( m_sourceinfo.containertype == ctVCD )
+	{
+		int ret = -1;
+		int fd = open(filename,O_RDONLY);
+		if (fd >= 0)
+		{
+			char tmp[128*1024];
+			ret = read(fd, tmp, 128*1024);
+			close(fd);
+		}
+		if ( ret == -1 ) // this is a "REAL" VCD
+			uri = g_strdup_printf ("vcd://");
+		else
+			uri = g_filename_to_uri(filename, NULL, NULL);
+	}
+	else
+		uri = g_filename_to_uri(filename, NULL, NULL);
+
+	eDebug("eServiceMP3::playbin uri=%s", uri);
+#if GST_VERSION_MAJOR < 1
+	m_gst_playbin = gst_element_factory_make("playbin2", "playbin");
+#else
+	m_gst_playbin = gst_element_factory_make("playbin", "playbin");
+#endif
+	if ( m_gst_playbin )
+	{
+		guint flags;
+		g_object_get(G_OBJECT (m_gst_playbin), "flags", &flags, NULL);
+		/* avoid video conversion, let the (hardware) sinks handle that */
+		flags |= GST_PLAY_FLAG_NATIVE_VIDEO;
+		/* volume control is done by hardware */
+		flags &= ~GST_PLAY_FLAG_SOFT_VOLUME;
+		if ( m_sourceinfo.is_streaming )
+		{
+			g_signal_connect (G_OBJECT (m_gst_playbin), "notify::source", G_CALLBACK (playbinNotifySource), this);
+			if (m_download_buffer_path != "")
+			{
+				/* use progressive download buffering */
+				flags |= GST_PLAY_FLAG_DOWNLOAD;
+				g_signal_connect(G_OBJECT(m_gst_playbin), "element-added", G_CALLBACK(handleElementAdded), this);
+				/* limit file size */
+				g_object_set(m_gst_playbin, "ring-buffer-max-size", (guint64)(8LL * 1024LL * 1024LL), NULL);
+			}
+			/*
+			 * regardless whether or not we configured a progressive download file, use a buffer as well
+			 * (progressive download might not work for all formats)
+			 */
+			flags |= GST_PLAY_FLAG_BUFFERING;
+			/* increase the default 2 second / 2 MB buffer limitations to 5s / 5MB */
+			g_object_set(G_OBJECT(m_gst_playbin), "buffer-duration", 5LL * GST_SECOND, NULL);
+			g_object_set(G_OBJECT(m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+		}
+		g_object_set (G_OBJECT (m_gst_playbin), "flags", flags, NULL);
+		g_object_set (G_OBJECT (m_gst_playbin), "uri", uri, NULL);
+		GstElement *subsink = gst_element_factory_make("subsink", "subtitle_sink");
+		if (!subsink)
+			eDebug("eServiceMP3::sorry, can't play: missing gst-plugin-subsink");
+		else
+		{
+			m_subs_to_pull_handler_id = g_signal_connect (subsink, "new-buffer", G_CALLBACK (gstCBsubtitleAvail), this);
+			g_object_set (G_OBJECT (subsink), "caps", gst_caps_from_string("text/plain; text/x-plain; text/x-raw; text/x-pango-markup; video/x-dvd-subpicture; subpicture/x-pgs"), NULL);
+			g_object_set (G_OBJECT (m_gst_playbin), "text-sink", subsink, NULL);
+			g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+		}
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_gst_playbin));
+#if GST_VERSION_MAJOR < 1
+		gst_bus_set_sync_handler(bus, gstBusSyncHandler, this);
+#else
+		gst_bus_set_sync_handler(bus, gstBusSyncHandler, this, NULL);
+#endif
+		gst_object_unref(bus);
+		char srt_filename[ext - filename + 5];
+		strncpy(srt_filename,filename, ext - filename);
+		srt_filename[ext - filename] = '\0';
+		strcat(srt_filename, ".srt");
+		if (::access(srt_filename, R_OK) >= 0)
+		{
+			eDebug("eServiceMP3::subtitle uri: %s", g_filename_to_uri(srt_filename, NULL, NULL));
+			g_object_set (G_OBJECT (m_gst_playbin), "suburi", g_filename_to_uri(srt_filename, NULL, NULL), NULL);
+		}
+	} else
+	{
+		m_event((iPlayableService*)this, evUser+12);
+		m_gst_playbin = 0;
+		m_errorInfo.error_message = "failed to create GStreamer pipeline!\n";
+
+		eDebug("eServiceMP3::sorry, can't play: %s",m_errorInfo.error_message.c_str());
+	}
+	g_free(uri);
+#else
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+		;
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+		;
+	else
+		strcat(file, "file://");
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+						audio.type = atMP3;
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+						audio.type = atMP3;
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+						audio.type = atAC3;
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+						audio.type = atDTS;
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+						audio.type = atAAC;
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+						audio.type = atPCM;
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+						audio.type = atOGG;
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+						audio.type = atFLAC;
+					else
+						audio.type = atUnknown;
+
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10) ||
+							!strncmp("S_SSA", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10) ||
+							!strncmp("S_AAS", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10) ||
+							!strncmp("S_SRT", TrackList[i+1], 5))
+						sub.type = stSRT;
+					else
+						sub.type = stPlainText;
+
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+		if (player)
+			free(player);
+		player = NULL;
+	}
+	//m_state = stRunning;
+	eDebug("eServiceMP3-<\n");
+#endif
+}
+
+eServiceMP3::~eServiceMP3()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	// disconnect subtitle callback
+	GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
+
+	if (subsink)
+	{
+		g_signal_handler_disconnect (subsink, m_subs_to_pull_handler_id);
+		gst_object_unref(subsink);
+	}
+#endif
+
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (m_gst_playbin)
+	{
+		// disconnect sync handler callback
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_gst_playbin));
+#if GST_VERSION_MAJOR < 1
+		gst_bus_set_sync_handler(bus, NULL, NULL);
+#else
+		gst_bus_set_sync_handler(bus, NULL, NULL, NULL);
+#endif
+		gst_object_unref(bus);
+	}
+#endif
+
+	if (m_state == stRunning)
+		stop();
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (m_stream_tags)
+		gst_tag_list_free(m_stream_tags);
+
+	if (audioSink)
+	{
+		gst_object_unref(GST_OBJECT(audioSink));
+		audioSink = NULL;
+	}
+	if (videoSink)
+	{
+		gst_object_unref(GST_OBJECT(videoSink));
+		videoSink = NULL;
+	}
+	if (m_gst_playbin)
+	{
+		gst_object_unref (GST_OBJECT (m_gst_playbin));
+		eDebug("eServiceMP3::destruct!");
+	}
+#endif
+}
+
+DEFINE_REF(eServiceMP3);
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+DEFINE_REF(eServiceMP3::GstMessageContainer);
+#endif
+
+RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	m_event(this, evSeekableStatusChanged);
+#endif
+	return 0;
+}
+
+RESULT eServiceMP3::start()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	ASSERT(m_state == stIdle);
+#else
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+#endif
+
+	m_state = stRunning;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (m_gst_playbin)
+	{
+		eDebug("eServiceMP3::starting pipeline");
+		gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
+	}
+#else
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+#endif
+
+	m_event(this, evStart);
+
+	return 0;
+}
+
+void eServiceMP3::sourceTimeout()
+{
+	eDebug("eServiceMP3::http source timeout! issuing eof...");
+	m_event((iPlayableService*)this, evEOF);
+}
+
+RESULT eServiceMP3::stop()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	ASSERT(m_state != stIdle);
+#else
+	if (m_state == stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+#endif
+
+	if (m_state == stStopped)
+		return -1;
+
+	eDebug("eServiceMP3::stop %s", m_ref.path.c_str());
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
+#else
+	if (player && player->playback && player->output)
+	{
+		player->playback->Command(player, PLAYBACK_STOP, NULL);
+		player->output->Command(player, OUTPUT_CLOSE, NULL);
+	}
+
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+	if (player)
+		free(player);
+
+	if (player != NULL)
+		player = NULL;
+#endif
+	m_state = stStopped;
+
+	return 0;
+}
+
+RESULT eServiceMP3::setTarget(int target)
+{
+	return -1;
+}
+
+RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
+{
+	ptr=this;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	m_event((iPlayableService*)this, evUpdatedInfo);
+#endif
+	return 0;
+}
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+#endif
+
+RESULT eServiceMP3::setSlowMotion(int ratio)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (!ratio)
+		return 0;
+	eDebug("eServiceMP3::setSlowMotion ratio=%f",1.0/(gdouble)ratio);
+	return trickSeek(1.0/(gdouble)ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
+}
+
+RESULT eServiceMP3::setFastForward(int ratio)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
+	return trickSeek(ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
+}
+
+		// iPausableService
+RESULT eServiceMP3::pause()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (!m_gst_playbin || m_state != stRunning)
+		return -1;
+
+	trickSeek(0.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#endif
+
+	return 0;
+}
+
+RESULT eServiceMP3::unpause()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (!m_gst_playbin || m_state != stRunning)
+		return -1;
+
+	trickSeek(1.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#endif
+
+	return 0;
+}
+
+	/* iSeekableService */
+RESULT eServiceMP3::seek(ePtr<iSeekableService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceMP3::getLength(pts_t &pts)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (!m_gst_playbin)
+		return -1;
+
+	if (m_state != stRunning)
+		return -1;
+
+	GstFormat fmt = GST_FORMAT_TIME;
+	gint64 len;
+#if GST_VERSION_MAJOR < 1
+	if (!gst_element_query_duration(m_gst_playbin, &fmt, &len))
+#else
+	if (!gst_element_query_duration(m_gst_playbin, fmt, &len))
+#endif
+		return -1;
+		/* len is in nanoseconds. we have 90 000 pts per second. */
+
+	pts = len / 11111LL;
+#else
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+#endif
+	return 0;
+}
+
+RESULT eServiceMP3::seekToImpl(pts_t to)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+		/* convert pts to nanoseconds */
+	gint64 time_nanoseconds = to * 11111LL;
+	if (!gst_element_seek (m_gst_playbin, m_currentTrickRatio, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
+		GST_SEEK_TYPE_SET, time_nanoseconds,
+		GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
+	{
+		eDebug("eServiceMP3::seekTo failed");
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+
+RESULT eServiceMP3::seekTo(pts_t to)
+{
+	RESULT ret = -1;
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (m_gst_playbin)
+	{
+		m_prev_decoder_time = -1;
+		m_decoder_time_valid_state = 0;
+		ret = seekToImpl(to);
+	}
+#else
+	float pos = (to/90000.0)-10;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	ret =0;
+#endif
+	return ret;
+}
+
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+RESULT eServiceMP3::trickSeek(gdouble ratio)
+{
+	if (!m_gst_playbin)
+		return -1;
+	if (ratio > -0.01 && ratio < 0.01)
+	{
+		gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
+		return 0;
+	}
+
+	m_currentTrickRatio = ratio;
+
+	bool validposition = false;
+	gint64 pos = 0;
+	pts_t pts;
+	if (getPlayPosition(pts) >= 0)
+	{
+		validposition = true;
+		pos = pts * 11111LL;
+	}
+
+	gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
+
+	if (validposition)
+	{
+		if (ratio >= 0.0)
+		{
+			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, -1);
+		}
+		else
+		{
+			/* note that most elements will not support negative speed */
+			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, pos);
+		}
+	}
+
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	return 0;
+}
+#endif
+
+
+RESULT eServiceMP3::seekRelative(int direction, pts_t to)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (!m_gst_playbin)
+		return -1;
+#endif
+	pts_t ppos;
+	if (getPlayPosition(ppos) < 0) return -1;
+	ppos += to * direction;
+	if (ppos < 0)
+		ppos = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	return seekTo(ppos);
+#else
+	float pos = direction*(to/90000.0);
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	return 0;
+#endif
+}
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+gint eServiceMP3::match_sinktype(GstElement *element, gpointer type)
+{
+	return strcmp(g_type_name(G_OBJECT_TYPE(element)), (const char*)type);
+}
+#endif
+
+RESULT eServiceMP3::getPlayPosition(pts_t &pts)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	gint64 pos;
+	pts = 0;
+
+	if (!m_gst_playbin)
+		return -1;
+	if (m_state != stRunning)
+		return -1;
+
+	if (audioSink || videoSink)
+	{
+		g_signal_emit_by_name(audioSink ? audioSink : videoSink, "get-decoder-time", &pos);
+		if (!GST_CLOCK_TIME_IS_VALID(pos)) return -1;
+	}
+	else
+	{
+		GstFormat fmt = GST_FORMAT_TIME;
+#if GST_VERSION_MAJOR < 1
+		if (!gst_element_query_position(m_gst_playbin, &fmt, &pos))
+#else
+		if (!gst_element_query_position(m_gst_playbin, fmt, &pos))
+#endif
+		{
+			eDebug("gst_element_query_position failed in getPlayPosition");
+			return -1;
+		}
+	}
+
+	/* pos is in nanoseconds. we have 90 000 pts per second. */
+	pts = pos / 11111LL;
+#else
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+#endif
+	return 0;
+}
+
+RESULT eServiceMP3::setTrickmode(int trick)
+{
+		/* trickmode is not yet supported by our dvbmediasinks. */
+	return -1;
+}
+
+RESULT eServiceMP3::isCurrentlySeekable()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER // Hellmaster1024: 1 for skipping 3 for skipping anf fast forward
+	int ret = 3; /* just assume that seeking and fast/slow winding are possible */
+
+	if (!m_gst_playbin)
+		return 0;
+	if (m_state != stRunning)
+		return 0;
+
+	return ret;
+#else
+	return 3;
+#endif
+}
+
+RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
+{
+	i = this;
+	return 0;
+}
+
+RESULT eServiceMP3::getName(std::string &name)
+{
+	std::string title = m_ref.getName();
+	if (title.empty())
+	{
+		name = m_ref.path;
+		size_t n = name.rfind('/');
+		if (n != std::string::npos)
+			name = name.substr(n + 1);
+	}
+	else
+		name = title;
+	return 0;
+}
+
+int eServiceMP3::getInfo(int w)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	const gchar *tag = 0;
+#endif
+
+	switch (w)
+	{
+	case sServiceref: return m_ref;
+	case sVideoHeight: return m_height;
+	case sVideoWidth: return m_width;
+	case sFrameRate: return m_framerate;
+	case sProgressive: return m_progressive;
+	case sAspect: return m_aspect;
+	case sTagTitle:
+	case sTagArtist:
+	case sTagAlbum:
+	case sTagTitleSortname:
+	case sTagArtistSortname:
+	case sTagAlbumSortname:
+	case sTagDate:
+	case sTagComposer:
+	case sTagGenre:
+	case sTagComment:
+	case sTagExtendedComment:
+	case sTagLocation:
+	case sTagHomepage:
+	case sTagDescription:
+	case sTagVersion:
+	case sTagISRC:
+	case sTagOrganization:
+	case sTagCopyright:
+	case sTagCopyrightURI:
+	case sTagContact:
+	case sTagLicense:
+	case sTagLicenseURI:
+	case sTagCodec:
+	case sTagAudioCodec:
+	case sTagVideoCodec:
+	case sTagEncoder:
+	case sTagLanguageCode:
+	case sTagKeywords:
+	case sTagChannelMode:
+	case sUser+12:
+#if not defined(__sh__)
+		return resIsString;
+#endif
+	case sTagTrackGain:
+	case sTagTrackPeak:
+	case sTagAlbumGain:
+	case sTagAlbumPeak:
+	case sTagReferenceLevel:
+	case sTagBeatsPerMinute:
+	case sTagImage:
+	case sTagPreviewImage:
+	case sTagAttachment:
+		return resIsPyObject;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	case sTagTrackNumber:
+		tag = GST_TAG_TRACK_NUMBER;
+		break;
+	case sTagTrackCount:
+		tag = GST_TAG_TRACK_COUNT;
+		break;
+	case sTagAlbumVolumeNumber:
+		tag = GST_TAG_ALBUM_VOLUME_NUMBER;
+		break;
+	case sTagAlbumVolumeCount:
+		tag = GST_TAG_ALBUM_VOLUME_COUNT;
+		break;
+	case sTagBitrate:
+		tag = GST_TAG_BITRATE;
+		break;
+	case sTagNominalBitrate:
+		tag = GST_TAG_NOMINAL_BITRATE;
+		break;
+	case sTagMinimumBitrate:
+		tag = GST_TAG_MINIMUM_BITRATE;
+		break;
+	case sTagMaximumBitrate:
+		tag = GST_TAG_MAXIMUM_BITRATE;
+		break;
+	case sTagSerial:
+		tag = GST_TAG_SERIAL;
+		break;
+	case sTagEncoderVersion:
+		tag = GST_TAG_ENCODER_VERSION;
+		break;
+	case sTagCRC:
+		tag = "has-crc";
+		break;
+#endif
+	default:
+		return resNA;
+	}
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (!m_stream_tags || !tag)
+		return 0;
+
+	guint value;
+	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
+		return (int) value;
+#endif
+
+	return 0;
+}
+
+std::string eServiceMP3::getInfoString(int w)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if ( !m_stream_tags && w < sUser && w > 26 )
+		return "";
+	const gchar *tag = 0;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = GST_TAG_TITLE;
+		break;
+	case sTagArtist:
+		tag = GST_TAG_ARTIST;
+		break;
+	case sTagAlbum:
+		tag = GST_TAG_ALBUM;
+		break;
+	case sTagTitleSortname:
+		tag = GST_TAG_TITLE_SORTNAME;
+		break;
+	case sTagArtistSortname:
+		tag = GST_TAG_ARTIST_SORTNAME;
+		break;
+	case sTagAlbumSortname:
+		tag = GST_TAG_ALBUM_SORTNAME;
+		break;
+	case sTagDate:
+		GDate *date;
+		if (gst_tag_list_get_date(m_stream_tags, GST_TAG_DATE, &date))
+		{
+			gchar res[5];
+ 			g_date_strftime (res, sizeof(res), "%Y-%M-%D", date);
+			return (std::string)res;
+		}
+		break;
+	case sTagComposer:
+		tag = GST_TAG_COMPOSER;
+		break;
+	case sTagGenre:
+		tag = GST_TAG_GENRE;
+		break;
+	case sTagComment:
+		tag = GST_TAG_COMMENT;
+		break;
+	case sTagExtendedComment:
+		tag = GST_TAG_EXTENDED_COMMENT;
+		break;
+	case sTagLocation:
+		tag = GST_TAG_LOCATION;
+		break;
+	case sTagHomepage:
+		tag = GST_TAG_HOMEPAGE;
+		break;
+	case sTagDescription:
+		tag = GST_TAG_DESCRIPTION;
+		break;
+	case sTagVersion:
+		tag = GST_TAG_VERSION;
+		break;
+	case sTagISRC:
+		tag = GST_TAG_ISRC;
+		break;
+	case sTagOrganization:
+		tag = GST_TAG_ORGANIZATION;
+		break;
+	case sTagCopyright:
+		tag = GST_TAG_COPYRIGHT;
+		break;
+	case sTagCopyrightURI:
+		tag = GST_TAG_COPYRIGHT_URI;
+		break;
+	case sTagContact:
+		tag = GST_TAG_CONTACT;
+		break;
+	case sTagLicense:
+		tag = GST_TAG_LICENSE;
+		break;
+	case sTagLicenseURI:
+		tag = GST_TAG_LICENSE_URI;
+		break;
+	case sTagCodec:
+		tag = GST_TAG_CODEC;
+		break;
+	case sTagAudioCodec:
+		tag = GST_TAG_AUDIO_CODEC;
+		break;
+	case sTagVideoCodec:
+		tag = GST_TAG_VIDEO_CODEC;
+		break;
+	case sTagEncoder:
+		tag = GST_TAG_ENCODER;
+		break;
+	case sTagLanguageCode:
+		tag = GST_TAG_LANGUAGE_CODE;
+		break;
+	case sTagKeywords:
+		tag = GST_TAG_KEYWORDS;
+		break;
+	case sTagChannelMode:
+		tag = "channel-mode";
+		break;
+	case sUser+12:
+		return m_errorInfo.error_message;
+	default:
+		return "";
+	}
+	if ( !tag )
+		return "";
+	gchar *value;
+	if (m_stream_tags && gst_tag_list_get_string(m_stream_tags, tag, &value))
+	{
+		std::string res = value;
+		g_free(value);
+		return res;
+	}
+#else
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+#endif
+	return "";
+}
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+ePtr<iServiceInfoContainer> eServiceMP3::getInfoObject(int w)
+{
+	eServiceMP3InfoContainer *container = new eServiceMP3InfoContainer;
+	ePtr<iServiceInfoContainer> retval = container;
+	const gchar *tag = 0;
+	bool isBuffer = false;
+	switch (w)
+	{
+		case sTagTrackGain:
+			tag = GST_TAG_TRACK_GAIN;
+			break;
+		case sTagTrackPeak:
+			tag = GST_TAG_TRACK_PEAK;
+			break;
+		case sTagAlbumGain:
+			tag = GST_TAG_ALBUM_GAIN;
+			break;
+		case sTagAlbumPeak:
+			tag = GST_TAG_ALBUM_PEAK;
+			break;
+		case sTagReferenceLevel:
+			tag = GST_TAG_REFERENCE_LEVEL;
+			break;
+		case sTagBeatsPerMinute:
+			tag = GST_TAG_BEATS_PER_MINUTE;
+			break;
+		case sTagImage:
+			tag = GST_TAG_IMAGE;
+			isBuffer = true;
+			break;
+		case sTagPreviewImage:
+			tag = GST_TAG_PREVIEW_IMAGE;
+			isBuffer = true;
+			break;
+		case sTagAttachment:
+			tag = GST_TAG_ATTACHMENT;
+			isBuffer = true;
+			break;
+		default:
+			break;
+	}
+
+	if (m_stream_tags && tag)
+	{
+		if (isBuffer)
+		{
+			const GValue *gv_buffer = gst_tag_list_get_value_index(m_stream_tags, tag, 0);
+			if ( gv_buffer )
+			{
+				GstBuffer *buffer;
+				buffer = gst_value_get_buffer (gv_buffer);
+				container->setBuffer(buffer);
+			}
+		}
+		else
+		{
+			gdouble value = 0.0;
+			gst_tag_list_get_double(m_stream_tags, tag, &value);
+			container->setDouble(value);
+		}
+	}
+	return retval;
+}
+#endif
+
+RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceMP3::audioTracks(ePtr<iAudioTrackSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceMP3::subtitle(ePtr<iSubtitleOutput> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceMP3::audioDelay(ePtr<iAudioDelay> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+int eServiceMP3::getNumberOfTracks()
+{
+ 	return m_audioStreams.size();
+}
+
+int eServiceMP3::getCurrentTrack()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (m_currentAudioStream == -1)
+		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+#endif
+	return m_currentAudioStream;
+}
+
+RESULT eServiceMP3::selectTrack(unsigned int i)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	bool validposition = false;
+	pts_t ppos = 0;
+	if (getPlayPosition(ppos) >= 0)
+	{
+		validposition = true;
+		ppos -= 90000;
+		if (ppos < 0)
+			ppos = 0;
+	}
+#endif
+
+	int ret = selectAudioStream(i);
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	if (!ret)
+	{
+		if (validposition)
+		{
+			/* flush */
+			seekTo(ppos);
+		}
+	}
+#endif
+
+	return ret;
+}
+
+int eServiceMP3::selectAudioStream(int i)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	int current_audio;
+	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
+	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
+	if ( current_audio == i )
+	{
+		eDebug ("eServiceMP3::switched to audio stream %i", current_audio);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+#else
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+#endif
+}
+
+int eServiceMP3::getCurrentChannel()
+{
+	return STEREO;
+}
+
+RESULT eServiceMP3::selectChannel(int i)
+{
+	eDebug("eServiceMP3::selectChannel(%i)",i);
+	return 0;
+}
+
+RESULT eServiceMP3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
+{
+ 	if (i >= m_audioStreams.size())
+		return -2;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+		info.m_description = m_audioStreams[i].codec;
+/*	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+	else if (m_audioStreams[i].type == atFLAC)
+		info.m_description = "FLAC";
+	else
+		info.m_description = "???";*/
+#else
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+#endif
+	if (info.m_language.empty())
+		info.m_language = m_audioStreams[i].language_code;
+	return 0;
+}
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
+{
+	subtype_t type = stUnknown;
+#if GST_VERSION_MAJOR < 1
+	GstCaps* caps = gst_pad_get_negotiated_caps(pad);
+#else
+	GstCaps* caps = gst_pad_get_current_caps(pad);
+#endif
+	if (!caps && !g_codec)
+	{
+		caps = gst_pad_get_allowed_caps(pad);
+	}
+
+	if (caps && !gst_caps_is_empty(caps))
+	{
+		GstStructure* str = gst_caps_get_structure(caps, 0);
+		if (str)
+		{
+			const gchar *g_type = gst_structure_get_name(str);
+			eDebug("getSubtitleType::subtitle probe caps type=%s", g_type ? g_type : "(null)");
+			if (g_type)
+			{
+				if ( !strcmp(g_type, "video/x-dvd-subpicture") )
+					type = stVOB;
+				else if ( !strcmp(g_type, "text/x-pango-markup") )
+					type = stSRT;
+				else if ( !strcmp(g_type, "text/plain") || !strcmp(g_type, "text/x-plain") || !strcmp(g_type, "text/x-raw") )
+					type = stPlainText;
+				else if ( !strcmp(g_type, "subpicture/x-pgs") )
+					type = stPGS;
+				else
+					eDebug("getSubtitleType::unsupported subtitle caps %s (%s)", g_type, g_codec ? g_codec : "(null)");
+			}
+		}
+	}
+	else if ( g_codec )
+	{
+		eDebug("getSubtitleType::subtitle probe codec tag=%s", g_codec);
+		if ( !strcmp(g_codec, "VOB") )
+			type = stVOB;
+		else if ( !strcmp(g_codec, "SubStation Alpha") || !strcmp(g_codec, "SSA") )
+			type = stSSA;
+		else if ( !strcmp(g_codec, "ASS") )
+			type = stASS;
+		else if ( !strcmp(g_codec, "SRT") )
+			type = stSRT;
+		else if ( !strcmp(g_codec, "UTF-8 plain text") )
+			type = stPlainText;
+		else
+			eDebug("getSubtitleType::unsupported subtitle codec %s", g_codec);
+	}
+	else
+		eDebug("getSubtitleType::unidentifiable subtitle stream!");
+
+	return type;
+}
+
+void eServiceMP3::gstBusCall(GstMessage *msg)
+{
+	if (!msg)
+		return;
+	gchar *sourceName;
+	GstObject *source;
+	source = GST_MESSAGE_SRC(msg);
+	if (!GST_IS_OBJECT(source))
+		return;
+	sourceName = gst_object_get_name(source);
+#if 0
+	gchar *string;
+	if (gst_message_get_structure(msg))
+		string = gst_structure_to_string(gst_message_get_structure(msg));
+	else
+		string = g_strdup(GST_MESSAGE_TYPE_NAME(msg));
+	eDebug("eTsRemoteSource::gst_message from %s: %s", sourceName, string);
+	g_free(string);
+#endif
+	switch (GST_MESSAGE_TYPE (msg))
+	{
+		case GST_MESSAGE_EOS:
+			m_event((iPlayableService*)this, evEOF);
+			break;
+		case GST_MESSAGE_STATE_CHANGED:
+		{
+			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+				break;
+
+			GstState old_state, new_state;
+			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+
+			if(old_state == new_state)
+				break;
+
+			eDebug("eServiceMP3::state transition %s -> %s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
+
+			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+
+			switch(transition)
+			{
+				case GST_STATE_CHANGE_NULL_TO_READY:
+				{
+				}	break;
+				case GST_STATE_CHANGE_READY_TO_PAUSED:
+				{
+#if GST_VERSION_MAJOR >= 1
+					GValue element = { 0, };
+#endif
+					GstIterator *children;
+					GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
+					if (subsink)
+					{
+#ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
+						/*
+						 * HACK: disable sync mode for now, gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
+						 * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
+						 * Sideeffect of using sync=false is that we receive subtitle buffers (far) ahead of their
+						 * display time.
+						 * Not too far ahead for subtitles contained in the media container.
+						 * But for external srt files, we could receive all subtitles at once.
+						 * And not just once, but after each pause/resume / skip.
+						 * So as soon as gstreamer has been fixed to keep sync in sparse streams, sync needs to be re-enabled.
+						 */
+						g_object_set (G_OBJECT (subsink), "sync", FALSE, NULL);
+#endif
+#if 0
+						/* we should not use ts-offset to sync with the decoder time, we have to do our own decoder timekeeping */
+						g_object_set (G_OBJECT (subsink), "ts-offset", -2LL * GST_SECOND, NULL);
+						/* late buffers probably will not occur very often */
+						g_object_set (G_OBJECT (subsink), "max-lateness", 0LL, NULL);
+						/* avoid prerolling (it might not be a good idea to preroll a sparse stream) */
+						g_object_set (G_OBJECT (subsink), "async", TRUE, NULL);
+#endif
+						eDebug("eServiceMP3::subsink properties set!");
+						gst_object_unref(subsink);
+					}
+					if (audioSink)
+					{
+						gst_object_unref(GST_OBJECT(audioSink));
+						audioSink = NULL;
+					}
+					if (videoSink)
+					{
+						gst_object_unref(GST_OBJECT(videoSink));
+						videoSink = NULL;
+					}
+					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
+#if GST_VERSION_MAJOR < 1
+					audioSink = GST_ELEMENT_CAST(gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, (gpointer)"GstDVBAudioSink"));
+#else
+					if (gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &element, (gpointer)"GstDVBAudioSink"))
+					{
+						audioSink = g_value_dup_object(&element);
+						g_value_unset(&element);
+					}
+#endif
+					gst_iterator_free(children);
+					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
+#if GST_VERSION_MAJOR < 1
+					videoSink = GST_ELEMENT_CAST(gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, (gpointer)"GstDVBVideoSink"));
+#else
+					if (gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &element, (gpointer)"GstDVBVideoSink"))
+					{
+						videoSink = g_value_dup_object(&element);
+						g_value_unset(&element);
+					}
+#endif
+					gst_iterator_free(children);
+
+					m_is_live = (gst_element_get_state(m_gst_playbin, NULL, NULL, 0LL) == GST_STATE_CHANGE_NO_PREROLL);
+
+					setAC3Delay(ac3_delay);
+					setPCMDelay(pcm_delay);
+				}	break;
+				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+				{
+					if ( m_sourceinfo.is_streaming && m_streamingsrc_timeout )
+						m_streamingsrc_timeout->stop();
+				}	break;
+				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+				{
+				}	break;
+				case GST_STATE_CHANGE_PAUSED_TO_READY:
+				{
+					if (audioSink)
+					{
+						gst_object_unref(GST_OBJECT(audioSink));
+						audioSink = NULL;
+					}
+					if (videoSink)
+					{
+						gst_object_unref(GST_OBJECT(videoSink));
+						videoSink = NULL;
+					}
+				}	break;
+				case GST_STATE_CHANGE_READY_TO_NULL:
+				{
+				}	break;
+			}
+			break;
+		}
+		case GST_MESSAGE_ERROR:
+		{
+			gchar *debug;
+			GError *err;
+			gst_message_parse_error (msg, &err, &debug);
+			g_free (debug);
+			eWarning("Gstreamer error: %s (%i) from %s", err->message, err->code, sourceName );
+			if ( err->domain == GST_STREAM_ERROR )
+			{
+				if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
+				{
+					if ( g_strrstr(sourceName, "videosink") )
+						m_event((iPlayableService*)this, evUser+11);
+					else if ( g_strrstr(sourceName, "audiosink") )
+						m_event((iPlayableService*)this, evUser+10);
+				}
+			}
+			g_error_free(err);
+			break;
+		}
+		case GST_MESSAGE_INFO:
+		{
+			gchar *debug;
+			GError *inf;
+
+			gst_message_parse_info (msg, &inf, &debug);
+			g_free (debug);
+			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
+			{
+				if ( g_strrstr(sourceName, "videosink") )
+					m_event((iPlayableService*)this, evUser+14);
+			}
+			g_error_free(inf);
+			break;
+		}
+		case GST_MESSAGE_TAG:
+		{
+			GstTagList *tags, *result;
+			gst_message_parse_tag(msg, &tags);
+
+			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
+			if (result)
+			{
+				if (m_stream_tags)
+					gst_tag_list_free(m_stream_tags);
+				m_stream_tags = result;
+			}
+
+			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
+			if ( gv_image )
+			{
+				GstBuffer *buf_image;
+				buf_image = gst_value_get_buffer (gv_image);
+				int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
+				if (fd >= 0)
+				{
+					guint8 *data;
+					gsize size;
+#if GST_VERSION_MAJOR < 1
+					data = GST_BUFFER_DATA(buf_image);
+					size = GST_BUFFER_SIZE(buf_image);
+#else
+					GstMapInfo map;
+					gst_buffer_map(buf_image, &map, GST_MAP_READ);
+					data = map.data;
+					size = map.size;
+#endif
+					int ret = write(fd, data, size);
+#if GST_VERSION_MAJOR >= 1
+					gst_buffer_unmap(buf_image, &map);
+#endif
+					close(fd);
+					eDebug("eServiceMP3::/tmp/.id3coverart %d bytes written ", ret);
+				}
+				m_event((iPlayableService*)this, evUser+13);
+			}
+			gst_tag_list_free(tags);
+			m_event((iPlayableService*)this, evUpdatedInfo);
+			break;
+		}
+		case GST_MESSAGE_ASYNC_DONE:
+		{
+			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+				break;
+			
+			gint i, n_video = 0, n_audio = 0, n_text = 0;
+
+			g_object_get (m_gst_playbin, "n-video", &n_video, NULL);
+			g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
+			g_object_get (m_gst_playbin, "n-text", &n_text, NULL);
+
+			eDebug("eServiceMP3::async-done - %d video, %d audio, %d subtitle", n_video, n_audio, n_text);
+
+			if ( n_video + n_audio <= 0 )
+				stop();
+
+			m_audioStreams.clear();
+			m_subtitleStreams.clear();
+
+			for (i = 0; i < n_audio; i++)
+			{
+				audioStream audio;
+				gchar *g_codec, *g_lang;
+				GstTagList *tags = NULL;
+				GstPad* pad = 0;
+				g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
+#if GST_VERSION_MAJOR < 1
+				GstCaps* caps = gst_pad_get_negotiated_caps(pad);
+#else
+				GstCaps* caps = gst_pad_get_current_caps(pad);
+#endif
+				if (!caps)
+					continue;
+				GstStructure* str = gst_caps_get_structure(caps, 0);
+				const gchar *g_type = gst_structure_get_name(str);
+				eDebug("AUDIO STRUCT=%s", g_type);
+				audio.type = gstCheckAudioPad(str);
+				audio.language_code = "und";
+				audio.codec = g_type;
+				g_codec = NULL;
+				g_lang = NULL;
+				g_signal_emit_by_name (m_gst_playbin, "get-audio-tags", i, &tags);
+#if GST_VERSION_MAJOR < 1
+				if (tags && gst_is_tag_list(tags))
+#else
+				if (tags && GST_IS_TAG_LIST(tags))
+#endif
+				{
+					if (gst_tag_list_get_string(tags, GST_TAG_AUDIO_CODEC, &g_codec))
+					{
+						audio.codec = std::string(g_codec);
+						g_free(g_codec);
+					}
+					if (gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang))
+					{
+						audio.language_code = std::string(g_lang);
+						g_free(g_lang);
+					}
+					gst_tag_list_free(tags);
+				}
+				eDebug("eServiceMP3::audio stream=%i codec=%s language=%s", i, audio.codec.c_str(), audio.language_code.c_str());
+				m_audioStreams.push_back(audio);
+				gst_caps_unref(caps);
+			}
+
+			for (i = 0; i < n_text; i++)
+			{
+				gchar *g_codec = NULL, *g_lang = NULL;
+				GstTagList *tags = NULL;
+				g_signal_emit_by_name (m_gst_playbin, "get-text-tags", i, &tags);
+				subtitleStream subs;
+				subs.language_code = "und";
+#if GST_VERSION_MAJOR < 1
+				if (tags && gst_is_tag_list(tags))
+#else
+				if (tags && GST_IS_TAG_LIST(tags))
+#endif
+				{
+					if (gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang))
+					{
+						subs.language_code = g_lang;
+						g_free(g_lang);
+					}
+					gst_tag_list_get_string(tags, GST_TAG_SUBTITLE_CODEC, &g_codec);
+					gst_tag_list_free(tags);
+				}
+
+				eDebug("eServiceMP3::subtitle stream=%i language=%s codec=%s", i, subs.language_code.c_str(), g_codec ? g_codec : "(null)");
+
+				GstPad* pad = 0;
+				g_signal_emit_by_name (m_gst_playbin, "get-text-pad", i, &pad);
+				if ( pad )
+					g_signal_connect (G_OBJECT (pad), "notify::caps", G_CALLBACK (gstTextpadHasCAPS), this);
+
+				subs.type = getSubtitleType(pad, g_codec);
+				g_free(g_codec);
+				m_subtitleStreams.push_back(subs);
+			}
+			m_event((iPlayableService*)this, evUpdatedInfo);
+
+			if ( m_errorInfo.missing_codec != "" )
+			{
+				if (m_errorInfo.missing_codec.find("video/") == 0 || (m_errorInfo.missing_codec.find("audio/") == 0 && m_audioStreams.empty()))
+					m_event((iPlayableService*)this, evUser+12);
+			}
+			break;
+		}
+		case GST_MESSAGE_ELEMENT:
+		{
+			const GstStructure *msgstruct = gst_message_get_structure(msg);
+			if (msgstruct)
+			{
+				if ( gst_is_missing_plugin_message(msg) )
+				{
+					GstCaps *caps = NULL;
+					gst_structure_get (msgstruct, "detail", GST_TYPE_CAPS, &caps, NULL);
+					if (caps)
+					{
+						std::string codec = (const char*) gst_caps_to_string(caps);
+						gchar *description = gst_missing_plugin_message_get_description(msg);
+						if ( description )
+						{
+							eDebug("eServiceMP3::m_errorInfo.missing_codec = %s", codec.c_str());
+							m_errorInfo.error_message = "GStreamer plugin " + (std::string)description + " not available!\n";
+							m_errorInfo.missing_codec = codec.substr(0,(codec.find_first_of(',')));
+							g_free(description);
+						}
+						gst_caps_unref(caps);
+					}
+				}
+				else
+				{
+					const gchar *eventname = gst_structure_get_name(msgstruct);
+					if ( eventname )
+					{
+						if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
+						{
+							gst_structure_get_int (msgstruct, "aspect_ratio", &m_aspect);
+							gst_structure_get_int (msgstruct, "width", &m_width);
+							gst_structure_get_int (msgstruct, "height", &m_height);
+							if (strstr(eventname, "Changed"))
+								m_event((iPlayableService*)this, evVideoSizeChanged);
+						}
+						else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
+						{
+							gst_structure_get_int (msgstruct, "frame_rate", &m_framerate);
+							if (strstr(eventname, "Changed"))
+								m_event((iPlayableService*)this, evVideoFramerateChanged);
+						}
+						else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
+						{
+							gst_structure_get_int (msgstruct, "progressive", &m_progressive);
+							if (strstr(eventname, "Changed"))
+								m_event((iPlayableService*)this, evVideoProgressiveChanged);
+						}
+						else if (!strcmp(eventname, "redirect"))
+						{
+							const char *uri = gst_structure_get_string(msgstruct, "new-location");
+							eDebug("redirect to %s", uri);
+							gst_element_set_state (m_gst_playbin, GST_STATE_NULL);
+							g_object_set(G_OBJECT (m_gst_playbin), "uri", uri, NULL);
+							gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
+						}
+					}
+				}
+			}
+			break;
+		}
+		case GST_MESSAGE_BUFFERING:
+			if (m_state == stRunning && m_sourceinfo.is_streaming)
+			{
+				GstBufferingMode mode;
+				gst_message_parse_buffering(msg, &(m_bufferInfo.bufferPercent));
+				eDebug("Buffering %u percent done", m_bufferInfo.bufferPercent);
+				gst_message_parse_buffering_stats(msg, &mode, &(m_bufferInfo.avgInRate), &(m_bufferInfo.avgOutRate), &(m_bufferInfo.bufferingLeft));
+				m_event((iPlayableService*)this, evBuffering);
+				/*
+				 * we don't react to buffer level messages, unless we are configured to use a prefill buffer
+				 * (even if we are not configured to, we still use the buffer, but we rely on it to remain at the
+				 * healthy level at all times, without ever having to pause the stream)
+				 *
+				 * Also, it does not make sense to pause the stream if it is a live stream
+				 * (in which case the sink will not produce data while paused, so we won't
+				 * recover from an empty buffer)
+				 */
+				if (m_use_prefillbuffer && !m_is_live && --m_ignore_buffering_messages <= 0)
+				{
+					if (m_bufferInfo.bufferPercent == 100)
+					{
+						GstState state;
+						gst_element_get_state(m_gst_playbin, &state, NULL, 0LL);
+						if (state != GST_STATE_PLAYING)
+						{
+							eDebug("start playing");
+							gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
+						}
+						/*
+						 * when we start the pipeline, the contents of the buffer will immediately drain
+						 * into the (hardware buffers of the) sinks, so we will receive low buffer level
+						 * messages right away.
+						 * Ignore the first few buffering messages, giving the buffer the chance to recover
+						 * a bit, before we start handling empty buffer states again.
+						 */
+						m_ignore_buffering_messages = 5;
+					}
+					else if (m_bufferInfo.bufferPercent == 0)
+					{
+						eDebug("start pause");
+						gst_element_set_state (m_gst_playbin, GST_STATE_PAUSED);
+						m_ignore_buffering_messages = 0;
+					}
+					else
+					{
+						m_ignore_buffering_messages = 0;
+					}
+				}
+			}
+			break;
+		case GST_MESSAGE_STREAM_STATUS:
+		{
+			GstStreamStatusType type;
+			GstElement *owner;
+			gst_message_parse_stream_status (msg, &type, &owner);
+			if ( type == GST_STREAM_STATUS_TYPE_CREATE && m_sourceinfo.is_streaming )
+			{
+				if ( GST_IS_PAD(source) )
+					owner = gst_pad_get_parent_element(GST_PAD(source));
+				else if ( GST_IS_ELEMENT(source) )
+					owner = GST_ELEMENT(source);
+				else
+					owner = 0;
+				if ( owner )
+				{
+					GstElementFactory *factory = gst_element_get_factory(GST_ELEMENT(owner));
+					const gchar *name = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(factory));
+					if (!strcmp(name, "souphttpsrc"))
+					{
+						m_streamingsrc_timeout->start(HTTP_TIMEOUT*1000, true);
+						g_object_set (G_OBJECT (owner), "timeout", HTTP_TIMEOUT, NULL);
+						eDebug("eServiceMP3::GST_STREAM_STATUS_TYPE_CREATE -> setting timeout on %s to %is", name, HTTP_TIMEOUT);
+					}
+				}
+				if ( GST_IS_PAD(source) )
+					gst_object_unref(owner);
+			}
+			break;
+		}
+		default:
+			break;
+	}
+	g_free (sourceName);
+}
+
+void eServiceMP3::handleMessage(GstMessage *msg)
+{
+	if (GST_MESSAGE_TYPE(msg) == GST_MESSAGE_STATE_CHANGED && GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+	{
+		/*
+		 * ignore verbose state change messages for all active elements;
+		 * we only need to handle state-change events for the playbin
+		 */
+		gst_message_unref(msg);
+		return;
+	}
+	m_pump.send(new GstMessageContainer(1, msg, NULL, NULL));
+}
+
+GstBusSyncReply eServiceMP3::gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data)
+{
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if (_this) _this->handleMessage(message);
+	return GST_BUS_DROP;
+}
+
+void eServiceMP3::playbinNotifySource(GObject *object, GParamSpec *unused, gpointer user_data)
+{
+	GstElement *source = NULL;
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	g_object_get(object, "source", &source, NULL);
+	if (source)
+	{
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "user-agent") != 0 && !_this->m_useragent.empty())
+		{
+			g_object_set(G_OBJECT(source), "user-agent", _this->m_useragent.c_str(), NULL);
+		}
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "extra-headers") != 0 && !_this->m_extra_headers.empty())
+		{
+			GstStructure *extras = gst_structure_empty_new("extras");
+			size_t pos = 0;
+			while (pos != std::string::npos)
+			{
+				std::string name, value;
+				size_t start = pos;
+				size_t len = std::string::npos;
+				pos = _this->m_extra_headers.find(':', pos);
+				if (pos != std::string::npos)
+				{
+					len = pos - start;
+					pos++;
+					name = _this->m_extra_headers.substr(start, len);
+					start = pos;
+					len = std::string::npos;
+					pos = _this->m_extra_headers.find('|', pos);
+					if (pos != std::string::npos)
+					{
+						len = pos - start;
+						pos++;
+					}
+					value = _this->m_extra_headers.substr(start, len);
+				}
+				if (!name.empty() && !value.empty())
+				{
+					GValue header;
+					eDebug("setting extra-header '%s:%s'", name.c_str(), value.c_str());
+					memset(&header, 0, sizeof(GValue));
+					g_value_init(&header, G_TYPE_STRING);
+					g_value_set_string(&header, value.c_str());
+					gst_structure_set_value(extras, name.c_str(), &header);
+				}
+				else
+				{
+					eDebug("Invalid header format %s", _this->m_extra_headers.c_str());
+					break;
+				}
+			}
+			if (gst_structure_n_fields(extras) > 0)
+			{
+				g_object_set(G_OBJECT(source), "extra-headers", extras, NULL);
+			}
+			gst_structure_free(extras);
+		}
+		gst_object_unref(source);
+	}
+}
+
+void eServiceMP3::handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data)
+{
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if (_this)
+	{
+		gchar *elementname = gst_element_get_name(element);
+
+		if (g_str_has_prefix(elementname, "queue2"))
+		{
+			if (_this->m_download_buffer_path != "")
+			{
+				g_object_set(G_OBJECT(element), "temp-template", _this->m_download_buffer_path.c_str(), NULL);
+			}
+			else
+			{
+				g_object_set(G_OBJECT(element), "temp-template", NULL, NULL);
+			}
+		}
+		else if (g_str_has_prefix(elementname, "uridecodebin")
+#if GST_VERSION_MAJOR < 1
+			|| g_str_has_prefix(elementname, "decodebin2"))
+#else
+			|| g_str_has_prefix(elementname, "decodebin"))
+#endif
+		{
+			/*
+			 * Listen for queue2 element added to uridecodebin/decodebin2 as well.
+			 * Ignore other bins since they may have unrelated queues
+			 */
+				g_signal_connect(element, "element-added", G_CALLBACK(handleElementAdded), user_data);
+		}
+		g_free(elementname);
+	}
+}
+
+audiotype_t eServiceMP3::gstCheckAudioPad(GstStructure* structure)
+{
+	if (!structure)
+		return atUnknown;
+
+	if ( gst_structure_has_name (structure, "audio/mpeg"))
+	{
+		gint mpegversion, layer = -1;
+		if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
+			return atUnknown;
+
+		switch (mpegversion) {
+			case 1:
+				{
+					gst_structure_get_int (structure, "layer", &layer);
+					if ( layer == 3 )
+						return atMP3;
+					else
+						return atMPEG;
+					break;
+				}
+			case 2:
+				return atAAC;
+			case 4:
+				return atAAC;
+			default:
+				return atUnknown;
+		}
+	}
+
+	else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
+		return atAC3;
+	else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
+		return atDTS;
+	else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
+		return atPCM;
+
+	return atUnknown;
+}
+
+void eServiceMP3::gstPoll(ePtr<GstMessageContainer> const &msg)
+{
+	switch (msg->getType())
+	{
+		case 1:
+		{
+			GstMessage *gstmessage = *((GstMessageContainer*)msg);
+			if (gstmessage)
+			{
+				gstBusCall(gstmessage);
+			}
+			break;
+		}
+		case 2:
+		{
+			GstBuffer *buffer = *((GstMessageContainer*)msg);
+			if (buffer)
+			{
+				pullSubtitle(buffer);
+			}
+			break;
+		}
+		case 3:
+		{
+			GstPad *pad = *((GstMessageContainer*)msg);
+			gstTextpadHasCAPS_synced(pad);
+			break;
+		}
+	}
+}
+#endif
+
+eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+void eServiceMP3::gstCBsubtitleAvail(GstElement *subsink, GstBuffer *buffer, gpointer user_data)
+{
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if (_this->m_currentSubtitleStream < 0)
+	{
+		if (buffer) gst_buffer_unref(buffer);
+		return;
+	}
+#if GST_VERSION_MAJOR < 1
+	guint8 *label = GST_BUFFER_DATA(buffer);
+#else
+	guint8 label[32] = {0};
+	gst_buffer_extract(buffer, 0, label, sizeof(label));
+#endif
+	eDebug("gstCBsubtitleAvail: %s", (const char*)label);
+	_this->m_pump.send(new GstMessageContainer(2, NULL, NULL, buffer));
+}
+
+void eServiceMP3::gstTextpadHasCAPS(GstPad *pad, GParamSpec * unused, gpointer user_data)
+{
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+
+	gst_object_ref (pad);
+
+	_this->m_pump.send(new GstMessageContainer(3, NULL, pad, NULL));
+}
+
+void eServiceMP3::gstTextpadHasCAPS_synced(GstPad *pad)
+{
+	GstCaps *caps = NULL;
+
+	g_object_get (G_OBJECT (pad), "caps", &caps, NULL);
+
+	if (caps)
+	{
+		subtitleStream subs;
+
+		eDebug("gstTextpadHasCAPS:: signal::caps = %s", gst_caps_to_string(caps));
+//		eDebug("gstGhostpadHasCAPS_synced %p %d", pad, m_subtitleStreams.size());
+
+		if (m_currentSubtitleStream >= 0 && m_currentSubtitleStream < (int)m_subtitleStreams.size())
+			subs = m_subtitleStreams[m_currentSubtitleStream];
+		else {
+			subs.type = stUnknown;
+			subs.pad = pad;
+		}
+
+		if ( subs.type == stUnknown )
+		{
+			GstTagList *tags = NULL;
+			gchar *g_lang = NULL;
+			g_signal_emit_by_name (m_gst_playbin, "get-text-tags", m_currentSubtitleStream, &tags);
+
+			subs.language_code = "und";
+			subs.type = getSubtitleType(pad);
+#if GST_VERSION_MAJOR < 1
+			if (tags && gst_is_tag_list(tags))
+#else
+			if (tags && GST_IS_TAG_LIST(tags))
+#endif
+			{
+				if (gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang))
+				{
+					subs.language_code = std::string(g_lang);
+					g_free(g_lang);
+				}
+			}
+
+			if (m_currentSubtitleStream >= 0 && m_currentSubtitleStream < (int)m_subtitleStreams.size())
+				m_subtitleStreams[m_currentSubtitleStream] = subs;
+			else
+				m_subtitleStreams.push_back(subs);
+		}
+
+//		eDebug("gstGhostpadHasCAPS:: m_gst_prev_subtitle_caps=%s equal=%i",gst_caps_to_string(m_gst_prev_subtitle_caps),gst_caps_is_equal(m_gst_prev_subtitle_caps, caps));
+
+		gst_caps_unref (caps);
+	}
+}
+
+void eServiceMP3::pullSubtitle(GstBuffer *buffer)
+{
+	uint32_t start_ms, end_ms;
+
+	if (buffer && m_currentSubtitleStream >= 0 && m_currentSubtitleStream < (int)m_subtitleStreams.size())
+	{
+		gint64 buf_pos = GST_BUFFER_TIMESTAMP(buffer);
+		gint64 duration_ns = GST_BUFFER_DURATION(buffer);
+#if GST_VERSION_MAJOR < 1
+		size_t len = GST_BUFFER_SIZE(buffer);
+#else
+		size_t len = gst_buffer_get_size(buffer);
+#endif
+		eDebug("pullSubtitle m_subtitleStreams[m_currentSubtitleStream].type=%i",m_subtitleStreams[m_currentSubtitleStream].type);
+
+		if ( m_subtitleStreams[m_currentSubtitleStream].type )
+		{
+			if ( m_subtitleStreams[m_currentSubtitleStream].type < stVOB )
+			{
+				int delay = eConfigManager::getConfigIntValue("config.subtitles.pango_subtitles_delay");
+				int subtitle_fps = eConfigManager::getConfigIntValue("config.subtitles.pango_subtitles_fps");
+
+				double convert_fps = 1.0;
+				if (subtitle_fps > 1 && m_framerate > 0)
+					convert_fps = subtitle_fps / (double)m_framerate;
+
+				unsigned char line[len+1];
+#if GST_VERSION_MAJOR < 1
+				memcpy(line, GST_BUFFER_DATA(buffer), len);
+#else
+				gst_buffer_extract(buffer, 0, line, len);
+#endif
+				line[len] = 0;
+				eDebug("got new text subtitle @ buf_pos = %lld ns (in pts=%lld), dur=%lld: '%s' ", buf_pos, buf_pos/11111, duration_ns, line);
+
+				start_ms = ((buf_pos / 1000000ULL) * convert_fps) + delay;
+				end_ms = start_ms + (duration_ns / 1000000ULL);
+				m_subtitle_pages.insert(subtitle_pages_map_pair_t(end_ms, subtitle_page_t(start_ms, end_ms, (const char *)line)));
+				m_subtitle_sync_timer->start(1, true);
+			}
+			else
+			{
+				eDebug("unsupported subpicture... ignoring");
+			}
+		}
+	}
+}
+#else
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif
+
+void eServiceMP3::pushSubtitles()
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	pts_t running_pts = 0;
+	int32_t next_timer = 0, decoder_ms, start_ms, end_ms, diff_start_ms, diff_end_ms;
+	subtitle_pages_map_t::iterator current;
+
+	// wait until clock is stable
+
+	if (getPlayPosition(running_pts) < 0)
+		m_decoder_time_valid_state = 0;
+
+	if (m_decoder_time_valid_state < 4)
+	{
+		m_decoder_time_valid_state++;
+
+		if (m_prev_decoder_time == running_pts)
+			m_decoder_time_valid_state = 0;
+
+		if (m_decoder_time_valid_state < 4)
+		{
+			//eDebug("*** push subtitles, waiting for clock to stabilise");
+			m_prev_decoder_time = running_pts;
+			next_timer = 50;
+			goto exit;
+		}
+
+		//eDebug("*** push subtitles, clock stable");
+	}
+
+	decoder_ms = running_pts / 90;
+
+#if 0
+		eDebug("\n*** all subs: ");
+
+		for (current = m_subtitle_pages.begin(); current != m_subtitle_pages.end(); current++)
+		{
+			start_ms = current->second.start_ms;
+			end_ms = current->second.end_ms;
+			diff_start_ms = start_ms - decoder_ms;
+			diff_end_ms = end_ms - decoder_ms;
+
+			eDebug("    start: %d, end: %d, diff_start: %d, diff_end: %d: %s",
+					start_ms, end_ms, diff_start_ms, diff_end_ms, current->second.text.c_str());
+		}
+
+		eDebug("\n\n");
+#endif
+
+	for (current = m_subtitle_pages.lower_bound(decoder_ms); current != m_subtitle_pages.end(); current++)
+	{
+		start_ms = current->second.start_ms;
+		end_ms = current->second.end_ms;
+		diff_start_ms = start_ms - decoder_ms;
+		diff_end_ms = end_ms - decoder_ms;
+
+#if 0
+		eDebug("*** next subtitle: decoder: %d, start: %d, end: %d, duration_ms: %d, diff_start: %d, diff_end: %d : %s",
+			decoder_ms, start_ms, end_ms, end_ms - start_ms, diff_start_ms, diff_end_ms, current->second.text.c_str());
+#endif
+
+		if (diff_end_ms < 0)
+		{
+			//eDebug("*** current sub has already ended, skip: %d\n", diff_end_ms);
+			continue;
+		}
+
+		if (diff_start_ms > 20)
+		{
+			//eDebug("*** current sub in the future, start timer, %d\n", diff_start_ms);
+			next_timer = diff_start_ms;
+			goto exit;
+		}
+
+		// showtime
+
+		if (m_subtitle_widget)
+		{
+			//eDebug("*** current sub actual, show!");
+
+			ePangoSubtitlePage pango_page;
+			gRGB rgbcol(0xD0,0xD0,0xD0);
+
+			pango_page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, current->second.text.c_str()));
+			pango_page.m_show_pts = start_ms * 90;			// actually completely unused by widget!
+			pango_page.m_timeout = end_ms - decoder_ms;		// take late start into account
+
+			m_subtitle_widget->setPage(pango_page);
+		}
+
+		//eDebug("*** no next sub scheduled, check NEXT subtitle");
+	}
+
+	// no more subs in cache, fall through
+
+exit:
+	if (next_timer == 0)
+	{
+		//eDebug("*** next timer = 0, set default timer!");
+		next_timer = 1000;
+	}
+
+	m_subtitle_sync_timer->start(next_timer, true);
+
+	eDebug("\n\n");
+
+#endif
+}
+
+RESULT eServiceMP3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
+{
+	if (m_currentSubtitleStream != track.pid)
+	{	
+#ifdef ENABLE_MEDIAFWGSTREAMER
+ 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", -1, NULL);
+#endif
+		m_subtitle_sync_timer->stop();
+		m_subtitle_pages.clear();
+		m_prev_decoder_time = -1;
+		m_decoder_time_valid_state = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+		m_currentSubtitleStream = track.pid;
+		m_cachedSubtitleStream = m_currentSubtitleStream;
+		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
+
+		m_subtitle_widget = user;
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
+		eDebug ("eServiceMP3::switched to subtitle stream %i", m_currentSubtitleStream);
+
+#ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
+		/*
+		 * when we're running the subsink in sync=false mode,
+		 * we have to force a seek, before the new subtitle stream will start
+		 */
+		seekRelative(-1, 90000);
+#endif
+#endif
+	}
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
+
+	return 0;
+}
+
+RESULT eServiceMP3::disableSubtitles()
+{
+	eDebug("eServiceMP3::disableSubtitles");
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	m_currentSubtitleStream = -1;
+	m_cachedSubtitleStream = m_currentSubtitleStream;
+	g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
+	m_subtitle_sync_timer->stop();
+	m_subtitle_pages.clear();
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	int pid = -1;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
+	return 0;
+}
+
+RESULT eServiceMP3::getCachedSubtitle(struct SubtitleTrack &track)
+{
+
+	bool autoturnon = eConfigManager::getConfigBoolValue("config.subtitles.pango_autoturnon", true);
+	if (!autoturnon)
+		return -1;
+
+	if (m_cachedSubtitleStream >= 0 && m_cachedSubtitleStream < (int)m_subtitleStreams.size())
+	{
+		track.type = 2;
+		track.pid = m_cachedSubtitleStream;
+		track.page_number = int(m_subtitleStreams[m_cachedSubtitleStream].type);
+		track.magazine_number = 0;
+		return 0;
+	}
+	return -1;
+}
+
+RESULT eServiceMP3::getSubtitleList(std::vector<struct SubtitleTrack> &subtitlelist)
+{
+// 	eDebug("eServiceMP3::getSubtitleList");
+	int stream_idx = 0;
+
+	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
+	{
+		subtype_t type = IterSubtitleStream->type;
+		switch(type)
+		{
+		case stUnknown:
+		case stVOB:
+		case stPGS:
+			break;
+		default:
+		{
+			struct SubtitleTrack track;
+			track.type = 2;
+			track.pid = stream_idx;
+			track.page_number = int(type);
+			track.magazine_number = 0;
+			track.language_code = IterSubtitleStream->language_code;
+			subtitlelist.push_back(track);
+		}
+		}
+		stream_idx++;
+	}
+	eDebug("eServiceMP3::getSubtitleList finished");
+	return 0;
+}
+
+RESULT eServiceMP3::streamed(ePtr<iStreamedService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+ePtr<iStreamBufferInfo> eServiceMP3::getBufferCharge()
+{
+	return new eStreamBufferInfo(m_bufferInfo.bufferPercent, m_bufferInfo.avgInRate, m_bufferInfo.avgOutRate, m_bufferInfo.bufferingLeft, m_buffer_size);
+}
+
+int eServiceMP3::setBufferSize(int size)
+{
+	m_buffer_size = size;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
+	return 0;
+}
+
+int eServiceMP3::getAC3Delay()
+{
+	return ac3_delay;
+}
+
+int eServiceMP3::getPCMDelay()
+{
+	return pcm_delay;
+}
+
+void eServiceMP3::setAC3Delay(int delay)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	ac3_delay = delay;
+	if (!m_gst_playbin || m_state != stRunning)
+		return;
+	else
+	{
+		int config_delay_int = delay;
+
+		/*
+		 * NOTE: We only look for dvbmediasinks.
+		 * If either the video or audio sink is of a different type,
+		 * we have no chance to get them synced anyway.
+		 */
+		if (videoSink)
+		{
+			config_delay_int += eConfigManager::getConfigIntValue("config.av.generalAC3delay");
+		}
+		else
+		{
+			eDebug("dont apply ac3 delay when no video is running!");
+			config_delay_int = 0;
+		}
+
+		if (audioSink)
+		{
+			eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
+		}
+	}
+#endif
+}
+
+void eServiceMP3::setPCMDelay(int delay)
+{
+#ifdef ENABLE_MEDIAFWGSTREAMER
+	pcm_delay = delay;
+	if (!m_gst_playbin || m_state != stRunning)
+		return;
+	else
+	{
+		int config_delay_int = delay;
+
+		/*
+		 * NOTE: We only look for dvbmediasinks.
+		 * If either the video or audio sink is of a different type,
+		 * we have no chance to get them synced anyway.
+		 */
+		if (videoSink)
+		{
+			config_delay_int += eConfigManager::getConfigIntValue("config.av.generalPCMdelay");
+		}
+		else
+		{
+			eDebug("dont apply pcm delay when no video is running!");
+			config_delay_int = 0;
+		}
+
+		if (audioSink)
+		{
+			eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
+		}
+	}
+#endif
+}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/servicemp3.h enigma2-nightly.patched/lib/service/servicemp3.h
--- enigma2-nightly.org/lib/service/servicemp3.h	2013-08-11 08:11:19.342306128 +0200
+++ enigma2-nightly.patched/lib/service/servicemp3.h	2013-08-10 22:31:20.000000000 +0200
@@ -6,7 +6,18 @@
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
+#else
+#include <common.h>
+#include <subtitle.h>
+#define gint int
+#define gint64 int64_t
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+#endif
 /* for subtitles */
 #include <lib/gui/esubtitle.h>
 
@@ -67,7 +78,9 @@
 	DECLARE_REF(eServiceMP3InfoContainer);
 
 	double doubleValue;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	GstBuffer *bufferValue;
+#endif
 
 	unsigned char *bufferData;
 	unsigned int bufferSize;
@@ -83,10 +96,14 @@
 	unsigned char *getBuffer(unsigned int &size) const;
 
 	void setDouble(double value);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	void setBuffer(GstBuffer *buffer);
+#endif
 };
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 typedef struct _GstElement GstElement;
+#endif
 
 typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
 typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
@@ -144,7 +161,9 @@
 	RESULT getName(std::string &name);
 	int getInfo(int w);
 	std::string getInfoString(int w);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ePtr<iServiceInfoContainer> getInfoObject(int w);
+#endif
 
 		// iAudioTrackSelection	
 	int getNumberOfTracks();
@@ -173,6 +192,7 @@
 	void setAC3Delay(int);
 	void setPCMDelay(int);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	struct audioStream
 	{
 		GstPad* pad;
@@ -205,6 +225,38 @@
 		{
 		}
 	};
+#else
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+#endif
 	struct bufferInfo
 	{
 		gint bufferPercent;
@@ -232,13 +284,19 @@
 	std::vector<audioStream> m_audioStreams;
 	std::vector<subtitleStream> m_subtitleStreams;
 	iSubtitleUser *m_subtitle_widget;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gdouble m_currentTrickRatio;
+#else
+	int m_currentTrickRatio;
+#endif
 	friend class eServiceFactoryMP3;
 	eServiceReference m_ref;
 	int m_buffer_size;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	int m_ignore_buffering_messages;
 	bool m_is_live;
 	bool m_use_prefillbuffer;
+#endif
 	bufferInfo m_bufferInfo;
 	errorInfo m_errorInfo;
 	std::string m_download_buffer_path;
@@ -249,6 +307,7 @@
 		stIdle, stRunning, stStopped,
 	};
 	int m_state;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	GstElement *m_gst_playbin, *audioSink, *videoSink;
 	GstTagList *m_stream_tags;
 
@@ -293,6 +352,22 @@
 	static void playbinNotifySource(GObject *object, GParamSpec *unused, gpointer user_data);
 	static gint match_sinktype(GstElement *element, gpointer type);
 	static void handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data);
+#else
+	Context_t * player;
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+#endif
 
 	struct subtitle_page_t
 	{
@@ -316,17 +391,23 @@
 	int m_decoder_time_valid_state;
 
 	void pushSubtitles();
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	void pullSubtitle(GstBuffer *buffer);
+#endif
 	void sourceTimeout();
 	sourceStream m_sourceinfo;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gulong m_subs_to_pull_handler_id;
+#endif
 
 	RESULT seekToImpl(pts_t to);
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
 	std::string m_useragent;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	std::string m_extra_headers;
 	RESULT trickSeek(gdouble ratio);
+#endif
 };
 
 #endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/m4/ax_python_devel.m4 enigma2-nightly.patched/m4/ax_python_devel.m4
--- enigma2-nightly.org/m4/ax_python_devel.m4	2013-08-11 08:11:19.346306128 +0200
+++ enigma2-nightly.patched/m4/ax_python_devel.m4	2013-08-11 08:18:50.314295931 +0200
@@ -154,7 +154,7 @@
 		python_path=`$PYTHON -c "import distutils.sysconfig; \
 			print (distutils.sysconfig.get_python_inc ());"`
 		if test -n "${python_path}"; then
-			python_path="-I$python_path"
+			python_path="-I$PY_PATH/include/python$PYTHON_VERSION"
 		fi
 		PYTHON_CPPFLAGS=$python_path
 	fi
@@ -235,7 +235,8 @@
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LDFLAGS="-L$PY_PATH/include/python$PYTHON_VERSION -lpython$ac_python_version"
+#			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
 		fi
 
 		if test -z "PYTHON_LDFLAGS"; then
@@ -253,8 +254,9 @@
 	#
 	AC_MSG_CHECKING([for Python site-packages path])
 	if test -z "$PYTHON_SITE_PKG"; then
-		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
-			print (distutils.sysconfig.get_python_lib(0,0));"`
+		PYTHON_SITE_PKG="$PY_PATH/lib/python$PYTHON_VERSION/site-packages"
+#		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+#			print (distutils.sysconfig.get_python_lib(0,0));"`
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/main/bsod.cpp enigma2-nightly.patched/main/bsod.cpp
--- enigma2-nightly.org/main/bsod.cpp	2013-08-11 08:11:19.346306128 +0200
+++ enigma2-nightly.patched/main/bsod.cpp	2013-08-11 08:18:50.314295931 +0200
@@ -17,8 +17,11 @@
 #include "version_info.h"
 
 /************************************************/
-
+#if defined(__sh__) // dont send mails to dm
+#define CRASH_EMAILADDR "somebody who cares"
+#else
 #define CRASH_EMAILADDR "forum at www.openpli.org"
+#endif
 #define INFOFILE "/maintainer.info"
 
 #define RINGBUFFER_SIZE 16384
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/main/enigma.cpp enigma2-nightly.patched/main/enigma.cpp
--- enigma2-nightly.org/main/enigma.cpp	2013-08-11 08:11:19.346306128 +0200
+++ enigma2-nightly.patched/main/enigma.cpp	2013-08-11 09:49:25.542173027 +0200
@@ -29,10 +29,15 @@
 #include <lib/python/python.h>
 #include <lib/python/pythonconfig.h>
 
+#if defined(__sh__) // vfd class
+#include <lib/driver/vfd.h>
+#endif
 #include "bsod.h"
 #include "version_info.h"
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
+#endif
 
 #ifdef OBJECT_DEBUG
 int object_total_remaining;
@@ -135,7 +140,9 @@
 	atexit(object_dump);
 #endif
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gst_init(&argc, &argv);
+#endif
 
 	// set pythonpath if unset
 	setenv("PYTHONPATH", eEnv::resolve("${libdir}/enigma2/python").c_str(), 0);
@@ -168,7 +175,11 @@
 	eWidgetDesktop dsk_lcd(my_lcd_dc->size());
 
 	dsk.setStyleID(0);
+#ifdef HAVE_GRAPHLCD
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 320 ? 1 : 2);
+#else
 	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 96 ? 2 : 1);
+#endif
 
 /*	if (double_buffer)
 	{
@@ -222,6 +233,12 @@
 	gRC::getInstance()->setSpinnerDC(my_dc);
 
 	eRCInput::getInstance()->keyEvent.connect(slot(keyEvent));
+
+#if defined(__sh__) // initialise the vfd class
+	evfd * vfd = new evfd;
+	vfd->init();
+	delete vfd;
+#endif
 	
 	printf("executing main\n");
 	
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/main/enigma.cpp~ enigma2-nightly.patched/main/enigma.cpp~
--- enigma2-nightly.org/main/enigma.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/main/enigma.cpp~	2013-08-11 08:18:50.314295931 +0200
@@ -0,0 +1,347 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <libsig_comp.h>
+
+#include <lib/actions/action.h>
+#include <lib/driver/rc.h>
+#include <lib/base/ioprio.h>
+#include <lib/base/ebase.h>
+#include <lib/base/eenv.h>
+#include <lib/base/eerror.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+#include <lib/gdi/gmaindc.h>
+#include <lib/gdi/glcddc.h>
+#include <lib/gdi/grc.h>
+#include <lib/gdi/epng.h>
+#include <lib/gdi/font.h>
+#include <lib/gui/ebutton.h>
+#include <lib/gui/elabel.h>
+#include <lib/gui/elistboxcontent.h>
+#include <lib/gui/ewidget.h>
+#include <lib/gui/ewidgetdesktop.h>
+#include <lib/gui/ewindow.h>
+#include <lib/gui/evideo.h>
+#include <lib/python/connections.h>
+#include <lib/python/python.h>
+#include <lib/python/pythonconfig.h>
+
+#if defined(__sh__) // vfd class
+#include <lib/driver/vfd.h>
+#endif
+#include "bsod.h"
+#include "version_info.h"
+
+#ifndef ENABLE_LIBEPLAYER3
+#include <gst/gst.h>
+#endif
+
+#ifdef OBJECT_DEBUG
+int object_total_remaining;
+
+void object_dump()
+{
+	printf("%d items left\n", object_total_remaining);
+}
+#endif
+
+static eWidgetDesktop *wdsk, *lcddsk;
+
+static int prev_ascii_code;
+
+int getPrevAsciiCode()
+{
+	int ret = prev_ascii_code;
+	prev_ascii_code = 0;
+	return ret;
+}
+
+void keyEvent(const eRCKey &key)
+{
+	static eRCKey last(0, 0, 0);
+	static int num_repeat;
+
+	ePtr<eActionMap> ptr;
+	eActionMap::getInstance(ptr);
+
+	if ((key.code == last.code) && (key.producer == last.producer) && key.flags & eRCKey::flagRepeat)
+		num_repeat++;
+	else
+	{
+		num_repeat = 0;
+		last = key;
+	}
+
+	if (num_repeat == 4)
+	{
+		ptr->keyPressed(key.producer->getIdentifier(), key.code, eRCKey::flagLong);
+		num_repeat++;
+	}
+
+	if (key.flags & eRCKey::flagAscii)
+	{
+		prev_ascii_code = key.code;
+		ptr->keyPressed(key.producer->getIdentifier(), 510 /* faked KEY_ASCII */, 0);
+	}
+	else
+		ptr->keyPressed(key.producer->getIdentifier(), key.code, key.flags);
+}
+
+/************************************************/
+#include <unistd.h>
+#include <lib/components/scan.h>
+#include <lib/dvb/idvb.h>
+#include <lib/dvb/dvb.h>
+#include <lib/dvb/db.h>
+#include <lib/dvb/dvbtime.h>
+#include <lib/dvb/epgcache.h>
+
+class eMain: public eApplication, public Object
+{
+	eInit init;
+	ePythonConfigQuery config;
+
+	ePtr<eDVBDB> m_dvbdb;
+	ePtr<eDVBResourceManager> m_mgr;
+	ePtr<eDVBLocalTimeHandler> m_locale_time_handler;
+	ePtr<eEPGCache> m_epgcache;
+
+public:
+	eMain()
+	{
+		init.setRunlevel(eAutoInitNumbers::main);
+		/* TODO: put into init */
+		m_dvbdb = new eDVBDB();
+		m_mgr = new eDVBResourceManager();
+		m_locale_time_handler = new eDVBLocalTimeHandler();
+		m_epgcache = new eEPGCache();
+		m_mgr->setChannelList(m_dvbdb);
+	}
+	
+	~eMain()
+	{
+		m_dvbdb->saveServicelist();
+		m_mgr->releaseCachedChannel();
+	}
+};
+
+int exit_code;
+
+int main(int argc, char **argv)
+{
+#ifdef MEMLEAK_CHECK
+	atexit(DumpUnfreed);
+#endif
+
+#ifdef OBJECT_DEBUG
+	atexit(object_dump);
+#endif
+
+#ifndef ENABLE_LIBEPLAYER3
+	gst_init(&argc, &argv);
+#endif
+
+	// set pythonpath if unset
+	setenv("PYTHONPATH", eEnv::resolve("${libdir}/enigma2/python").c_str(), 0);
+	printf("PYTHONPATH: %s\n", getenv("PYTHONPATH"));
+	
+	bsodLogInit();
+
+	ePython python;
+	eMain main;
+
+#if 1
+	ePtr<gMainDC> my_dc;
+	gMainDC::getInstance(my_dc);
+	
+	//int double_buffer = my_dc->haveDoubleBuffering();
+
+	ePtr<gLCDDC> my_lcd_dc;
+	gLCDDC::getInstance(my_lcd_dc);
+
+
+		/* ok, this is currently hardcoded for arabic. */
+			/* some characters are wrong in the regular font, force them to use the replacement font */
+	for (int i = 0x60c; i <= 0x66d; ++i)
+		eTextPara::forceReplacementGlyph(i);
+	eTextPara::forceReplacementGlyph(0xfdf2);
+	for (int i = 0xfe80; i < 0xff00; ++i)
+		eTextPara::forceReplacementGlyph(i);
+
+	eWidgetDesktop dsk(my_dc->size());
+	eWidgetDesktop dsk_lcd(my_lcd_dc->size());
+
+	dsk.setStyleID(0);
+#ifdef HAVE_GRAPHLCD
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 320 ? 1 : 2);
+#else
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 96 ? 2 : 1);
+#endif
+
+/*	if (double_buffer)
+	{
+		eDebug(" - double buffering found, enable buffered graphics mode.");
+		dsk.setCompositionMode(eWidgetDesktop::cmBuffered);
+	} */
+	
+	wdsk = &dsk;
+	lcddsk = &dsk_lcd;
+
+	dsk.setDC(my_dc);
+	dsk_lcd.setDC(my_lcd_dc);
+
+	dsk.setBackgroundColor(gRGB(0,0,0,0xFF));
+#endif
+
+		/* redrawing is done in an idle-timer, so we have to set the context */
+	dsk.setRedrawTask(main);
+	dsk_lcd.setRedrawTask(main);
+	
+	
+	eDebug("Loading spinners...");
+	
+	{
+		int i;
+#define MAX_SPINNER 64
+		ePtr<gPixmap> wait[MAX_SPINNER];
+		for (i=0; i<MAX_SPINNER; ++i)
+		{
+			char filename[64];
+			std::string rfilename;
+			snprintf(filename, sizeof(filename), "${datadir}/enigma2/skin_default/spinner/wait%d.png", i + 1);
+			rfilename = eEnv::resolve(filename);
+			loadPNG(wait[i], rfilename.c_str());
+			
+			if (!wait[i])
+			{
+				if (!i)
+					eDebug("failed to load %s! (%m)", rfilename.c_str());
+				else
+					eDebug("found %d spinner!\n", i);
+				break;
+			}
+		}
+		if (i)
+			my_dc->setSpinner(eRect(ePoint(100, 100), wait[0]->size()), wait, i);
+		else
+			my_dc->setSpinner(eRect(100, 100, 0, 0), wait, 1);
+	}
+	
+	gRC::getInstance()->setSpinnerDC(my_dc);
+
+	eRCInput::getInstance()->keyEvent.connect(slot(keyEvent));
+
+#if defined(__sh__) // initialise the vfd class
+	evfd * vfd = new evfd;
+	vfd->init();
+	delete vfd;
+#endif
+	
+	printf("executing main\n");
+	
+	bsodCatchSignals();
+
+	setIoPrio(IOPRIO_CLASS_BE, 3);
+
+	/* start at full size */
+	eVideoWidget::setFullsize(true);
+
+//	python.execute("mytest", "__main__");
+	python.execFile(eEnv::resolve("${libdir}/enigma2/python/mytest.py").c_str());
+
+	/* restore both decoders to full size */
+	eVideoWidget::setFullsize(true);
+
+	if (exit_code == 5) /* python crash */
+	{
+		eDebug("(exit code 5)");
+		bsodFatal(0);
+	}
+	
+	dsk.paint();
+	dsk_lcd.paint();
+
+	{
+		gPainter p(my_lcd_dc);
+		p.resetClip(eRect(ePoint(0, 0), my_lcd_dc->size()));
+		p.clear();
+		p.flush();
+	}
+
+	return exit_code;
+}
+
+eWidgetDesktop *getDesktop(int which)
+{
+	return which ? lcddsk : wdsk;
+}
+
+eApplication *getApplication()
+{
+	return eApp;
+}
+
+void quitMainloop(int exitCode)
+{
+	FILE *f = fopen("/proc/stb/fp/was_timer_wakeup", "w");
+	if (f)
+	{
+		fprintf(f, "%d", 0);
+		fclose(f);
+	}
+	else
+	{
+		int fd = open("/dev/dbox/fp0", O_WRONLY);
+		if (fd >= 0)
+		{
+			if (ioctl(fd, 10 /*FP_CLEAR_WAKEUP_TIMER*/) < 0)
+				eDebug("FP_CLEAR_WAKEUP_TIMER failed (%m)");
+			close(fd);
+		}
+		else
+			eDebug("open /dev/dbox/fp0 for wakeup timer clear failed!(%m)");
+	}
+	exit_code = exitCode;
+	eApp->quit(0);
+}
+
+static void sigterm_handler(int num)
+{
+	quitMainloop(128 + num);
+}
+
+void runMainloop()
+{
+	struct sigaction act;
+
+	act.sa_handler = sigterm_handler;
+	act.sa_flags = SA_RESTART;
+
+	if (sigemptyset(&act.sa_mask) == -1)
+		perror("sigemptyset");
+	if (sigaction(SIGTERM, &act, 0) == -1)
+		perror("SIGTERM");
+
+	eApp->runLoop();
+}
+
+const char *getEnigmaVersionString()
+{
+	return enigma2_version;
+}
+
+const char *getBoxType()
+{
+	return BOXTYPE;
+}
+
+#include <malloc.h>
+
+void dump_malloc_stats(void)
+{
+	struct mallinfo mi = mallinfo();
+	eDebug("MALLOC: %d total", mi.uordblks);
+}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/main/Makefile.am enigma2-nightly.patched/main/Makefile.am
--- enigma2-nightly.org/main/Makefile.am	2013-08-11 08:11:19.346306128 +0200
+++ enigma2-nightly.patched/main/Makefile.am	2013-08-11 08:18:50.314295931 +0200
@@ -9,6 +9,8 @@
 
 bin_PROGRAMS = enigma2
 
+installdir = $(targetprefix)/usr/local/bin
+
 enigma2_SOURCES = \
 	bsod.cpp \
 	bsod.h \
@@ -51,7 +53,17 @@
 	@PTHREAD_LIBS@ \
 	@PYTHON_LDFLAGS@ \
 	@LIBDDVD_LIBS@ \
-	-ltuxtxt -ltuxtxt32bpp -lcrypt -lrt
+	-ltuxtxt -ltuxtxt32bpp -lcrypt -lrt \
+	-ldl -lpthread -lcrypt -lresolv -lmmeimage
+
+if ENABLE_LIBEPLAYER3
+enigma2_LDADD += \
+	-leplayer3
+endif
+
+if HAVE_GRAPHLCD
+enigma2_LDADD += -lglcddrivers -lglcdgraphics -lglcdskin
+endif
 
 enigma2_LDFLAGS = -Wl,--export-dynamic
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/mytest.py enigma2-nightly.patched/mytest.py
--- enigma2-nightly.org/mytest.py	2013-08-11 08:11:19.346306128 +0200
+++ enigma2-nightly.patched/mytest.py	2013-08-11 08:18:50.314295931 +0200
@@ -301,6 +301,10 @@
 
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+
+		if dlg is None:
+			return
+
 		dlg.isTmp = True
 		dlg.callback = None
 		self.execBegin()
@@ -509,10 +513,10 @@
 	if wakeupList:
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+		if (startTime[0] - nowTime) < 330: # no time to switch box back on
 			wptime = nowTime + 30  # so switch back on in 30 seconds
 		else:
-			wptime = startTime[0] - 240
+			wptime = startTime[0] - 300
 		if not config.misc.useTransponderTime.value:
 			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
 			setRTCtime(nowTime)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/skin.py enigma2-nightly.patched/skin.py
--- enigma2-nightly.org/skin.py	2013-08-11 08:11:19.626306121 +0200
+++ enigma2-nightly.patched/skin.py	2013-08-11 08:18:50.318295930 +0200
@@ -68,7 +68,7 @@
 
 # example: loadSkin("nemesis_greenline/skin.xml")
 config.skin = ConfigSubsection()
-DEFAULT_SKIN = "PLi-HD/skin.xml"
+DEFAULT_SKIN = "Nobile/skin.xml"
 # on SD hardware, PLi-HD will not be available
 if not fileExists(resolveFilename(SCOPE_SKIN, DEFAULT_SKIN)):
 	# in that case, fallback to Magic (which is an SD skin)
